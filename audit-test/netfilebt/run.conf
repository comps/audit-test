#!/bin/bash
# =============================================================================
# (c) Copyright Hewlett-Packard Development Company, L.P., 2005, 2006, 2007
#
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of version 2 the GNU General Public License as
#   published by the Free Software Foundation.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
# =============================================================================

######################################################################
# global variables
######################################################################

tstsvr_lock_timeout_lspp=3000           # in seconds (50m)
tstsvr_lock_timeout_capp=120            # in seconds (2m)
tstsvr_lock_timeout=0
tstsvr_lock_held=0
tst_port1=4100
tst_port2=4200
tst_port3=4300

######################################################################
# helper functions
######################################################################

#
# get_test_domain - Get the SELinux domain for the test applet
#
# INPUT
# $1 : the labeling type
# $2 : the host type
#
# OUTPUT
# Writes the SELinux domain to stdout
#
# DESCRIPTION
# This function determines the correct SELinux domain to use for the test
# applet based on the given labeling type.
#
function get_test_domain {
    declare type_arg=$1 host_arg=$2

    case $PPROFILE-$host_arg in
	lspp-*|capp-remote)
            case $type_arg in
		unlabeled)
                    echo "lspp_test_generic_t"
		    ;;
		*)
		    exit_fail "invalid test argument"
	            ;;
	    esac
	    ;;
	capp-local)
	    case $type_arg in
	        *)
		    echo "unconfined_t"
		    ;;
	    esac
	    ;;
    esac
}

#
# get_label_subj - Get the subject's sensitivity label for the test run
#
# INPUT
# $1 : the MLS "op"
#
# OUPUT
# Writes the subject's untranslated sensivity label to stdout
#
# DESCRIPTION
# This function sets the subject's sensitivity label for the test run
# based on the MLS "op". The MLS "op" will always specify  the subject
# is to be equal to (eq) the object for the ebtables filtering tests.
# This MLS "op" definition assumes the Bell-LaPadula based MLS
# constraints in use by the SELinux MLS policy derived from the SELinux
# Reference Policy.
#
function get_label_subj {
    declare mlsop_arg=$1

    case $PPROFILE in
	lspp)
            case $mlsop_arg in
		eq)
		    echo "SystemLow"
		    ;;
		*)
		    exit_fail "invalid test argument"
		    ;;
	    esac
	    ;;
	capp)
            case $mlsop_arg in
		*)
		    # in targeted policy (the likely policy for CAPP) the s0
		    # sensitivity label is translated into a NULL string so we
		    # have to use the untranslated sensitivity label
		    echo "s0"
		    ;;
	    esac
	    ;;
    esac
}

#
# get_label_obj - Get the object's sensitivity label for the test run
#
# INPUT
# $1 : the MLS "op"
#
# OUPUT
# Writes the object's untranslated sensivity label to stdout
#
# DESCRIPTION
# This function determines the objects's sensitivity label for the test run
# based on the MLS "op".  The MLS "op" specifies the subject is to be equal
# to (eq) the object.
# This MLS "op" definition assumes the Bell-LaPadula based MLS
# constraints in use by the SELinux MLS policy derived from the SELinux
# Reference Policy.
#
function get_label_obj {
    declare mlsop_arg=$1

    case $PPROFILE in
	lspp)
            case $mlsop_arg in
		eq)
                    echo "SystemLow"
		    ;;
		*)
		    exit_fail "invalid test argument"
		    ;;
	    esac
	    ;;
	capp)
            case $mlsop_arg in
		*)
		    # in targeted policy (the likely policy for CAPP) the s0
		    # sensitivity label is translated into a NULL string so we
		    # have to use the untranslated sensitivity label
		    echo "s0"
		    ;;
	    esac
	    ;;
    esac
}

#
# get_host_local - Get the IP address to use as the local address for the test
#
# INPUT
# $1 : the IP version
# $2 : the host type
#
# OUTPUT
# Writes the IP address to stdout
#
# DESCRIPTION
# This function determines the correct local address to use for the test run
# based on an IP version string, "ipv4" or "ipv6", and the host type, "local"
# or "remote".  While the "local" host types resolve to the IPv4 or IPv6
# localhost address the "remote" host types resolve to IP addresses specified
# in environment variables which are queried at the start of the test run.
#
function get_host_local {
    declare ipv_arg=$1 host_arg=$2

    case $ipv_arg in
	ipv4)
	    case $host_arg in
		local)
		    echo "127.0.0.1"
		    ;;
		remote)
		    echo "$lblnet_loc4_host"
		    ;;
		*)
		    exit_fail "invalid test argument"
		    ;;
	    esac
	    ;;
	ipv6)
	    case $host_arg in
		local)
		    echo "::1"
		    ;;
		remote)
		    echo "$lblnet_loc6_host"
		    ;;
		*)
		    exit_fail "invalid test argument"
		    ;;
	    esac
	    ;;
	*)
	    exit_fail "invalid test argument"
	    ;;
	esac
}

#
# get_host_remote - Get the IP address to use as the remote address
#
# INPUT
# $1 : the IP version
# $2 : the host type
#
# OUTPUT
# Writes the IP address to stdout
#
# DESCRIPTION
# This function determines the correct remote address to use for the test
# run based on an IP version string, "ipv4" or "ipv6", and the host type,
# "local" or "remote".  While the "local" host types resolve to the IPv4 or
# IPv6 localhost address the "remote" host types resolve to IP addresses
# specified in environment variables which are queried at the start of the
# test run.
#
function get_host_remote {
    declare ipv_arg=$1 host_arg=$2

    case $ipv_arg in
	ipv4)
	    case $host_arg in
		local)
		    echo "127.0.0.1"
		    ;;
		remote)
		    echo "$lblnet_svr4_host"
		    ;;
		*)
		    exit_fail "invalid test argument"
		    ;;
	    esac
	    ;;
	ipv6)
	    case $host_arg in
		local)
		    echo "::1"
		    ;;
		remote)
		    echo "$lblnet_svr6_host"
		    ;;
		*)
		    exit_fail "invalid test argument"
		    ;;
	    esac
	    ;;
	*)
	    exit_fail "invalid test argument"
	    ;;
	esac
}

#
# tstsvr_lock - Lock the remote test server
#
# INPUT
# none
#
# OUTPUT
# Returns true if the test server was able to be locked, false otherwise
#
# DESCRIPTION
# This function attempts to lock the remote test server with the timeout value
# specified in the global variable $tstsvr_lock_timeout.  If the function is
# able to lock the remote test server then it returns true and sets the global
# variable $tstsvr_lock_held to 1 for use in the tstsvr_unlock() function.  If
# for any reason the function is not able to lock the remote test server then
# the function returns false and the value in $tstsvr_lock_held is unchanged.
# This function assumes the remote node is running a test driver similar to the
# one found in "utils/network-server/lblnet_tst_server.c".
#
function tstsvr_lock {
    declare rc
    declare cmd_str="lock:set,$tstsvr_lock_timeout;"

    echo $lblnet_svr6_host
    rc="$(nc -6 -w 3 $lblnet_svr6_host 4000 <<< $cmd_str)"
    if [[ $rc == 0 ]]; then
	tstsvr_lock_held=1
	return 0
    fi

    return 1
}

#
# tstsvr_unlock - Unlock the remote test server
#
# INPUT
# none
#
# OUTPUT
# none
#
# DESCRIPTION
# This function attempts to unlock the remote test server if it was locked
# previously during this test run.  The function checks the $tstsvr_lock_held
# global variable and if the value is 1, set by the tstsvr_lock() function,
# then the function sends an unlock command to the remote test server.  If the
# $tstsvr_lock_held variable is not set to 1 then this function does nothing.
# This function assumes the remote node is running a test driver similar to the
# one found in "utils/network-server/lblnet_tst_server.c".
#
function tstsvr_unlock {
    declare cmd_str="lock:release;"

    if [[ $tstsvr_lock_held == 1 ]]; then
	nc -6 -w 3 $lblnet_svr6_host 4000 <<< $cmd_str
    fi
}

#
# verify_remote - Verify that the remote test server is available for use
#
# INPUT
# none
#
# OUTPUT
# Returns true if the remote test server is available, false otherwise
#
# DESCRIPTION
# This function checks to see if the remote test server is available for use
# and is able to be locked for this test run in which case it returns true.
# If the test server is offline, or in use by another host and unable to be
# locked then this function returns false.
#
function verify_remote {
    tstsvr_lock
    return $?
}

######################################################################
# defaults
######################################################################

#
# setup_default - Setup the remote test driver
#
# INPUT
# none
#
# OUTPUT
# none
#
# DESCRIPTION
# All of the ebtables tests in this file need to either send data to a remote
# node or receive data from a remote node; this function does the required
# setup to initialize the remote node based on the individual test case. This
# function works for both "local" (localhost) and "remote" (non-localhost)
# host types using both IPv4 and IPv6. No ebtables tests are run on the local
# loopback device.  This function determines the setup
# needed by the test using the "op", "host", "type", "mlsop", "ipv", and
# "port" named arguments as given on the test command line.  On error the
# function calls exit_error() which marks the test case as resulting in an
# error.  This function assumes the remote node is running a test driver
# similar to the one found in "utils/network-server/lblnet_tst_server.c".
#
function setup_default {
    declare rc=1
    declare tspid=0
    declare cmd_str
    declare remote_obj local_host
    declare loop_cnt

    # generate the host command string
    remote_obj="$(get_label_obj $mlsop)"
    cmd_str="sockcon:full,system_u:system_r:$(get_test_domain $type $host):$remote_obj;"
    cmd_str+="detach;"
    case $op in
	sendrand_tcp)
            local_host="$(get_host_local $ipv $host)"
            cmd_str+="sleep:5;"
            cmd_str+="sendrand:$local_host,tcp,$port,1;"
	    ;;
	sendrand_udp)
            local_host="$(get_host_local $ipv $host)"
            cmd_str+="sleep:5;"
            cmd_str+="sendrand:$local_host,udp,$port,1;"
	    ;;
	recv_tcp)
            cmd_str+="recv:$ipv,tcp,$port,0;"
	    ;;

#       recv_udp is not used in ebtables testing currently but is
#       left in for possible future test cases as the operation
#       already coded in the lblnet_tst_server

	recv_udp)
            cmd_str+="recv:$ipv,udp,$port,1;"
	    ;;
	*)
	    exit_fail "invalid test argument no1"
	    ;;
    esac

    # setup the remote test server (try more than once)
    for ((loop_cnt=0; loop_cnt<=2 && rc!=0; loop_cnt++)); do
	case $host in
	    remote)
	        rc="$(nc -6 -w 3 $lblnet_svr6_host 4000 <<< $cmd_str)"
		;;
	    local)
	        # use the same port as the remote IPv4 setting
	        rc="$(nc -w 3 ::1 4000 <<< $cmd_str)"
	        ;;
	    *)
	        exit_fail "invalid test argument"
		;;
	esac
	if [[ $rc != 0 ]]; then
	    echo "notice: failed to setup remote test server, retrying"
            echo "return code = "$rc" "
	    sleep 10
	fi
    done

    # verify the setup
    if [[ $rc != 0 ]]; then
	exit_error "could not setup remote test server"
    fi
}


######################################################################
# run.bash overrides
######################################################################

# Rename the original run.bash + function to run+ and create our own + function
# that generates a tag for the test based on the named parameters.

#
# + - Generate a unique tag for each test case and run the default "+" function
#
# INPUT
# $@ : test command line
#
# OUTPUT
# none
#
# DESCRIPTION
# This function acts as a wrapper for the original "+" function which is
# responsibile for running each test case shown at the bottom of this file.
# This wrapper function is necessary to automatically generate a unique tag for
# each test case based on it's named arguments.  This tag is then used as an
# additional named argument for the default "+" function.
#
eval "function run+ $(type + | sed '1,2d')"
function + {
    declare test=$1 tag # make sure it's not inherited from caller
    shift
    eval "$(parse_named "$@")" || exit_error
    if [[ -z $tag ]]; then
        # extract the named args that identify a unique testcase
        run+ $test \
	    tag="${test}__${host}_${type}_${ipv}_${expres}_subj_${mlsop}_obj" \
	    "$@"
    else
        # use tag supplied in run.conf
        run+ $test "$@"
    fi
}

#
# show_test - Display the test case details
#
# INPUT
# $@ : test command line
#
# OUTPUT
# Writes the test case details to stdout
#
# DESCRIPTION
# This function reads in the entire test case command line and depending on
# the verbosity of the test harness either the entire command line is dumped
# to stdout or just the tag named variable as generated by the +() function
# defined in this file.  All output is handled by the fmt_test() function
# which is defined as by the test harness.  This function was overloaded
# because of the special handling for the tag named variable.
#
function show_test {
    if ! $opt_verbose; then
	declare tag # make sure it's not inherited from caller
	eval "$(parse_named "$@")" || exit_error
	[[ -n $tag ]] && set -- "$tag"
    fi
    fmt_test "[$TESTNUM]" "$@"
}

#
# network_cleanup - Release the lock on the remote test server
#
# INPUT
# none
#
# OUTPUT
# none
#
# DESCRIPTION
# This function tries to unlock the remote test server by calling the
# tstsvr_unlock() function.
#
function network_cleanup {
    tstsvr_unlock
}
prepend_cleanup 'network_cleanup'


#
# This function sets up the ebtables targets that allow an audit log
# of packets matching the rule that uses either AUDIT_DROP or
# AUDIT_ACCEPT as the target in the rule.
#
function ebtaudit_setup {

ebtables -A INPUT -p arp -j ACCEPT
ebtables -A INPUT -p ipv6 --ip6-protocol ipv6-icmp -j ACCEPT

ebtables -N AUDIT_DROP
ebtables -A AUDIT_DROP -j AUDIT --audit-type DROP
ebtables -A AUDIT_DROP -j DROP

ebtables -N AUDIT_ACCEPT
ebtables -A AUDIT_ACCEPT -j AUDIT --audit-type ACCEPT
ebtables -A AUDIT_ACCEPT -j ACCEPT
}

######################################################################
# run_test
######################################################################

#
# run_test - Execute an individual test case
#
# INPUT
# $@ : test command line
#
# OUTPUT
# Returns true on test success, other error values on test failure
#
# DESCRIPTION
# This function is responsibile for executing all aspects of an individual
# test case including the following: setup, audit configuration and rotation,
# test case execution, test case verification, and audit verification.  Most of
# these tasks are handled by other helper function defined either in this file
# or in the test harness, however, they are called from inside this function
# based on the individual test case's requirements.  In the case where a test
# is run and it returns true and the audit verification is successful then this
# function returns true and the test case can be considered to have passed.
# However, if either the test case returns non-true, the audit trail is not
# correct, or an error occurs elsewhere then this function calls either the
# exit_fail() or exit_error() functions to signify a test case failure.
#
function run_test {
    declare syscall=$1 tst_name=$1
    declare x name value status log_mark
    declare test_domain label_subj label_obj host_local host_remote
    shift
    eval "$(parse_named "$@")" || exit_error

    source netfilebt_functions.bash || exit_error

    if [[ tnum -eq 41 ]]; then
       ./testperm.bash
       return $?
    fi

    # backup original ruleset, schedule ruleset restoration, clean current one
    # NOTE: clean the ruleset before original -restore, to clean tables used by
    #       this test, but unused/unspecified by original ruleset
    original_rules="$(mktemp)"
    ebtables-save > "$original_rules"
    append_cleanup "{ ebtables-save | xtables_empty | ebtables-restore; cat $original_rules | ebtables-restore; rm -f $original_rules; }"
    ebtables-save | xtables_empty | ebtables-restore

    # get the derived variables
    #  NOTE: the $test_domain variable is always using the "local" version of
    #        the test domain because the value is always only used on the
    #        local machine (see below)
    test_domain=$(get_test_domain $type local)
    label_subj=$(get_label_subj $mlsop)
    label_obj=$(get_label_obj $mlsop)
    host_local=$(get_host_local $ipv $host)
    host_remote=$(get_host_remote $ipv $host)

    # prepare cleanup and run the default setup
        append_cleanup "tstsvr_cleanup $host_remote"
        ebtaudit_setup
        setup_default

        case $tnum in
              2)
               ebtables -A INPUT -i $LOCAL_SEC_DEV -j AUDIT_DROP
                 ;;
              4)
               ebtables -A INPUT -p IPv4 --ip-source $SECNET_SVR_IPV4 -j AUDIT_DROP
                 ;;
              5)
               ebtables -A INPUT -p IPv4 --ip-destination $LOCAL_SEC_IPV4 -j AUDIT_DROP
                 ;;
              7)
               ebtables -A INPUT -p IPv4 --ip-proto TCP --ip-source-port $tst_port1 -j AUDIT_DROP
                 ;;
              8)
               ebtables -A INPUT -p IPv4 --ip-proto TCP --ip-destination-port $tst_port1 -j AUDIT_DROP
                 ;;
             10)
               srcrange=$(cat /proc/sys/net/ipv4/ip_local_port_range | tr '\t' ':')
               ebtables -A INPUT -p IPv4 --ip-proto UDP --ip-source-port $srcrange -j AUDIT_DROP
                 ;;
             11)
               ebtables -A INPUT -p IPv4 --ip-proto UDP --ip-destination-port $tst_port1 -j AUDIT_DROP
                 ;;
             13)
               ebtables -A INPUT -p IPv4 --ip-proto TCP --ip-destination-port 22 -j AUDIT_ACCEPT
               ebtables -A INPUT -p IPv4 --ip-proto TCP --ip-destination-port $tst_port1 -j AUDIT_ACCEPT
               ebtables -P INPUT DROP
                 ;;
             14)
               ebtables -A INPUT -p IPv4 --ip-proto TCP --ip-destination-port 22 -j AUDIT_ACCEPT
               ebtables -P INPUT DROP
                 ;;
             15)
               ebtables -A INPUT --logical-in $BRIDGE_FILTER -j AUDIT_ACCEPT
                 ;;
             16)
               ebtables -A INPUT --logical-in $BRIDGE_FILTER -j AUDIT_DROP
                 ;;
             17)
               ebtables -A INPUT -s $SECNET_SVR_MAC -j AUDIT_ACCEPT
                 ;;
             18)
               ebtables -A INPUT -s $SECNET_SVR_MAC -j AUDIT_DROP
                 ;;
             19)
               ebtables -A INPUT -d $LOCAL_SEC_MAC -j AUDIT_ACCEPT
                 ;;
             20)
               ebtables -A INPUT -d $LOCAL_SEC_MAC -j AUDIT_DROP
                 ;;
             22)
               ebtables -A INPUT -i $LOCAL_SEC_DEV -j AUDIT_DROP
                 ;;
             24)
               ebtables -A INPUT -p IPv6 --ip6-source $SECNET_SVR_IPV6 -j AUDIT_DROP
                 ;;
             25)
               ebtables -A INPUT -p IPv6 --ip6-destination $LOCAL_SEC_IPV6 -j AUDIT_DROP
                 ;;
             27)
               ebtables -A INPUT -p IPv6 --ip6-proto TCP --ip6-source-port $tst_port1 -j AUDIT_DROP
                 ;;
             28)
               ebtables -A INPUT -p IPv6 --ip6-proto TCP --ip6-destination-port $tst_port1 -j AUDIT_DROP
                 ;;
             30)
               srcrange=$(cat /proc/sys/net/ipv4/ip_local_port_range | tr '\t' ':')
               ebtables -A INPUT -p IPv6 --ip6-proto UDP --ip6-source-port $srcrange -j AUDIT_DROP
                 ;;
             31)
               ebtables -A INPUT -p IPv6 --ip6-proto UDP --ip6-destination-port $tst_port1 -j AUDIT_DROP
                 ;;
             33)
               ebtables -A INPUT -p IPv6 --ip6-proto TCP --ip6-destination-port 22 -j AUDIT_ACCEPT
               ebtables -A INPUT -p IPv6 --ip6-proto TCP --ip6-destination-port $tst_port1 -j AUDIT_ACCEPT
               ebtables -P INPUT DROP
                 ;;
             34)
               ebtables -A INPUT -p IPv6 --ip6-proto TCP --ip6-destination-port 22 -j AUDIT_ACCEPT
               ebtables -P INPUT DROP
                 ;;
             35)
               ebtables -A INPUT --logical-in $BRIDGE_FILTER -j AUDIT_ACCEPT
                 ;;
             36)
               ebtables -A INPUT --logical-in $BRIDGE_FILTER -j AUDIT_DROP
                 ;;
             37)
               ebtables -A INPUT -s $SECNET_SVR_MAC -j AUDIT_ACCEPT
                 ;;
             38)
               ebtables -A INPUT -s $SECNET_SVR_MAC -j AUDIT_DROP
                 ;;
             39)
               ebtables -A INPUT -d $LOCAL_SEC_MAC -j AUDIT_ACCEPT
                 ;;
             40)
               ebtables -A INPUT -d $LOCAL_SEC_MAC -j AUDIT_DROP
                 ;;
              *)
               echo "test case = $tnum"
                 ;;
        esac

    # display ruleset in use
    echo "=== ebtables ==="
    ebtables-save

    # force the audit log to rotate
    rotate_audit_logs || exit_error

    # mark the log for augrok later
    log_mark=$(stat -c %s $audit_log)
    # run this in a subshell so that exit_* doesn't abort early
    (
        declare testres exitval pid
	declare tst_args=( $(eval echo \"${unnamed[*]}\") )
        set -x
        # run the test itself
        read testres exitval pid <<< \
          "$(runcon -t $test_domain -l $(get_label_subj $mlsop) \
               do_$tst_name "${tst_args[@]}" 2>&1 1>/dev/null)"

        echo "testres is "$testres" and exitval is "$exitval" "
        [[ -z $testres || -z $exitval || -z $pid ]] && exit_error
        check_result $expres $testres $exitval $err

##  audit.log is checked for packets of message type NETFILTER_PKT,
##  the appropriate action (0 = accepted, 1 = dropped), and the interface on
##  which it occurred ($LOCAL_SEC_DEV) against the tnums where an audit
##  record is expected

        case $tnum in
              2 | 4 | 5 | 7 | 8 | 10 | 11)
               asreturn=$(ausearch -m NETFILTER_PKT -if /var/log/audit/audit.log \
                    | grep action=1 | grep -m 1 inif="$LOCAL_SEC_DEV")
               if [[ -n $asreturn ]]; then
                  echo " "$asreturn" "
                  exit_pass
               else
                  exit_fail "missing log in audit.log"
               fi
                   ;;
              13 | 15 | 19 | 33 | 37 | 39)
               asreturn=$(ausearch -m NETFILTER_PKT -if /var/log/audit/audit.log \
                    | grep action=0 | grep -m 1 inif="$LOCAL_SEC_DEV")
               if [[ -n $asreturn ]]; then
                  echo " "$asreturn" "
                  exit_pass
               else
                  exit_fail "missing log in audit.log"
               fi
                   ;;
              16 | 18 | 20 | 22 | 24 | 25 | 27)
               asreturn=$(ausearch -m NETFILTER_PKT -if /var/log/audit/audit.log \
                    | grep action=1 | grep -m 1 inif="$LOCAL_SEC_DEV")
               if [[ -n $asreturn ]]; then
                  echo " "$asreturn" "
                  exit_pass
               else
                  exit_fail "missing log in audit.log"
               fi
                   ;;
              28 | 30 | 31 | 38 | 40)
                asreturn=$(ausearch -m NETFILTER_PKT | grep action=1 | grep -m 1 inif="$LOCAL_SEC_DEV")
               if [[ -n $asreturn ]]; then
                  echo " "$asreturn" "
                  exit_pass
               else
                  exit_fail "missing log in audit.log"
               fi
                   ;;
              *)
                exit_pass
                ;;
        esac

    )
    status=$?

    # display the audit log items
    if [[ $status != 0 ]]; then
        echo
        echo augrok output
        echo -------------
        augrok --seek=$log_mark type!=DAEMON_ROTATE
    fi

    return $status
}

######################################################################
# pre-testrun checks/configuration
######################################################################

# check the test profile
[[ -z "$PPROFILE" ]] && die "error: profile not set (PPROFILE)"

# the remote labeled networking host/server
[[ -z "$SECNET_SVR_IPV4" ]] && \
    die "error: labeled networking test server not specified (SECNET_SVR_IPV4)"
[[ -z "$SECNET_SVR_IPV6" ]] && \
    die "error: labeled networking test server not specified (SECNET_SVR_IPV6)"

# the bridge with enslaved secnet device
[[ -z "$BRIDGE_FILTER" ]] && \
    die "error: bridge interface not specified (BRIDGE_FILTER undefined)"


# the local machine
lblnet_loc4_host="$LOCAL_SEC_IPV4"
lblnet_loc6_host="$LOCAL_SEC_IPV6"

# the remote machine
lblnet_svr4_host="$SECNET_SVR_IPV4"
lblnet_svr6_host="$SECNET_SVR_IPV6"

case $PPROFILE in
    lspp)
	tstsvr_lock_timeout=$tstsvr_lock_timeout_lspp
	;;
    capp)
        tstsvr_lock_timeout=$tstsvr_lock_timeout_capp
        ;;
    *)
        die "error: unknown test profile ($PPROFILE)"
	;;
esac

# wait until remote is available
while ! verify_remote; do
    echo "notice: test server is busy, sleeping for 60s ..."
    sleep 60
done

######################################################################
# test configuration
######################################################################

# It is important to note that prior to running any of the test below the
# system must be properly configured. See the README.netfilter file.

##
##  ebtables system calls
##

# The test cases below are in the following format, with optional elements
# denoted by square brackets ([...]):
#
#  + <_syscall_> \
#    mlsop=<_mlsop_> expres=<_expres_> err=<_err_> \
#    host=<_host_> type=<_type_> op=<_op_> ipv=<_ipv_> port=<_port_> \
#    <_test_args_>
#
# Where the arguments are defined as follows:
#
#  _syscall_     : the syscall itself is not being tested for ebtables but
#                  is being used to generate the traffic for the test
#
#  _mlsop_       : the MLS label comparison operator for more information see
#                  the comments elsewhere in this file, only 1 value used for
#                  ebtables. For compatibitlity with lblnet_tst_server
#                  value:
#                    eq     : the local test process label equals the remote
#                             process/packet/connection's label
#  _expres_      : indicates that the operation should succeed (success) or
#                  fail (fail) based on the system's security policy
#  _err_         : if the test should fail, it should fail with this error
#                  code/value
#  _host_        : indicates if the test is against a local (local) or
#                  remote (remote) host, the actual remote IP address is
#                  determined from the SECNET_SVR_IPV4 and SECNET_SVR_IPV6
#                  environment variables
#  _type_        : the labeling protocol, kept for purposes of compatibility
#                    with the lblnet_tst_server. Only 1 type used:
#                    unlabeled : not a labeling protocol, no need for ebtables
#  _op_          : the remote test driver command, there are four valid values:
#                    sendrand_tcp : initiate a TCP connection with the test
#                                   machine and send data
#                    sendrand_udp : send UDP traffic to the test machine
#                    recv_tcp     : accept TCP connections from the test
#                                   machine and receive data from established
#                                   connections
#                    recv_udp     : receive UDP traffic from the test machine
#  _ipv_         : the IP version, there are two values: ipv4 and ipv6
#  _port_        : the TCP or UDP port
#  _test_args_   : arguments to supply to the test applet/program, these may
#                  be variables which are later expanded inside the run_test()
#                  function

## SYSCALLS:     accept() connect() recvfrom()
## PURPOSE:
## Verify that incoming packets are only allowed to pass on the bridge device
## when the ebtables chain rule or policy is set to accept the packet and
## are dropped when a chain rule or policy so dictates. A check is also made
## for an audit record of the accepted or dropped packet when the rule so
## specifies a target of AUDIT_ACCEPT or AUDIT_DROP.
## These test cases make use of a remote test driver to initiate a connection
## from the remote node to the host under test, see the setup_default()
## function above for details on configuring the remote test driver.  In
## The test procedure is as follows:
##  1. Configure the audit subsystem to watch for the syscall record
##  2. Restart ebtables to set it to a known condition, add the AUDIT_ACCEPT
##     and AUDIT_DROP chains and set the INPUT chain with the appropriate
##     rule to test the specific filter feature.
##  3. Execute the test case on the local system and verify the result
##  4. Check the audit log for the correct syscall result and in the case of
##     failure check for generated audit records indicating that a packet
##     was dropped  or in some cases of success we check that an audit record
##     was generated for a packet that was acccepted.
## TESTCASE: Test #0 tnum 1
##   Table Rule       no blocking
##   Input            TOE sends tcp connect to remote server over bridge
##   Expected Result  packets pass, connection succeeds
+ connect \
    mlsop=eq expres=success \
    host=remote type=unlabeled op=recv_tcp ipv=ipv4 port=$tst_port1 \
    tnum=1 '$host_remote tcp $port'
## TESTCASE: Test #1 tnum 2
##   Table Rule       drop incoming packets on device enslaved to bridge
##                    and log in audit.log
##   Input            TOE sends tcp connect to remote server over bridge
##   Expected Result  response packets dropped, connect times out, audit.log
##                    has record
+ connect \
    mlsop=eq expres=fail err=ETIMEDOUT \
    host=remote type=unlabeled op=recv_tcp ipv=ipv4 port=$tst_port1\
    tnum=2 '$host_remote tcp $port'
## TESTCASE: Test #2 tnum 3
##   Table Rule       no blocking
##   Input            TOE sends tcp connect to remote server over bridge
##   Expected Result  packets pass, connection succeeds
+ connect \
    mlsop=eq expres=success \
    host=remote type=unlabeled op=recv_tcp ipv=ipv4 port=$tst_port1 \
    tnum=3 '$host_remote tcp $port'
## TESTCASE: Test #3 tnum 4
##   Table Rule       drop packets with source address of remote server and log
##                    in audit.log
##   Input            TOE sends tcp connect to remote server over bridge
##   Expected Result  response packets dropped, connect times out, audit.log
##                    has record
+ connect \
    mlsop=eq expres=fail err=ETIMEDOUT \
    host=remote type=unlabeled op=recv_tcp ipv=ipv4 port=$tst_port1 \
    tnum=4 '$host_remote tcp $port'
## TESTCASE: Test #4 tnum 5
##   Table Rule       drop incoming packets to TOE bridge ipv4 address and log
##                    in audit.log
##   Input            TOE sends TCP connect to remote server over bridge
##   Expected Result  response packets dropped, connect times out, audit.log
##                    has record
+ connect \
    mlsop=eq expres=fail err=ETIMEDOUT \
    host=remote type=unlabeled op=recv_tcp ipv=ipv4 port=$tst_port1 \
    tnum=5 '$host_remote tcp $port'
## TESTCASE: Test #5 tnum 6
##   Table Rule       no blocking
##   Input            remote server sends tcp connect to bridge ipv4 address
##   Expected Result  packets pass, connection succeeds
+ connect \
    mlsop=eq expres=success \
    host=remote type=unlabeled op=recv_tcp ipv=ipv4 port=$tst_port1 \
    tnum=6 '$host_remote tcp $port'
## TESTCASE: Test #6 tnum 7
##   Table Rule       drop TCP packets with source port (tst_port1) and log
##                    in audit.log
##   Input            TOE sends TCP connect to remote server over bridge
##   Expected Result  response packets dropped, connect times out, audit.log
##                    has record
+ connect \
    mlsop=eq expres=fail err=ETIMEDOUT \
    host=remote type=unlabeled op=recv_tcp ipv=ipv4 port=$tst_port1 \
    tnum=7 '$host_remote tcp $port'
## TESTCASE: Test #7 tnum 8
##   Table Rule       drop TCP packets with destination port (tst_port1) and log
##                    in audit.log
##   Input            remote server sends tcp connect to bridge ipv4 address
##                    with destination port (tst_port1)
##   Expected Result  response packets dropped, listen times out, audit.log
##                    has record
+ accept \
    mlsop=eq expres=fail err=EINTR\
    host=remote type=unlabeled op=sendrand_tcp ipv=ipv4 port=$tst_port1 \
    tnum=8 '$ipv $port'
## TESTCASE: Test #8 tnum 9
##   Table Rule       no blocking
##   Input            remote server sends udp packets to bridge ipv4 address
##   Expected Result  packets pass through
+ recvfrom \
    mlsop=eq expres=success \
    host=remote type=unlabeled op=sendrand_udp ipv=ipv4 port=$tst_port1 \
    tnum=9 '$ipv $port'
## TESTCASE: Test #9 tnum 10
##   Table Rule       drop UDP from source port range $srcrange and log in
##                    audit.log
##   Input            remote server sends udp packets to bridge ipv4 address
##   Expected Result  packets dropped, audit.log has record
+ recvfrom \
    mlsop=eq expres=fail err=EINTR \
    host=remote type=unlabeled op=sendrand_udp ipv=ipv4 port=$tst_port1 \
    tnum=10 '$ipv $port'
## TESTCASE: Test #10 tnum 11
##   Table Rule       drop UDP packets to destination port (tst_port1) and log
##                    audit.log
##   Input            remote server sends udp packets to bridge ipv4 address
##                    at destination port
##   Expected Result  packets dropped, audit.log has record
+ recvfrom \
    mlsop=eq expres=fail err=EINTR \
    host=remote type=unlabeled op=sendrand_udp ipv=ipv4 port=$tst_port1 \
    tnum=11 '$ipv $port'
## TESTCASE: Test #11 tnum 12
##   Table Rule       no blocking
##   Input            remote server sends tcp connect to bridge ipv4 address
##   Expected Result  packets pass, connection succeeds
+ accept \
    mlsop=eq expres=success \
    host=remote type=unlabeled op=sendrand_tcp ipv=ipv4 port=$tst_port1 \
    tnum=12 '$ipv $port'
## TESTCASE: Test #12 tnum 13
##   Table Rule       INPUT chain policy set to DROP, ACCEPT TCP packets to
##                    port destination port (tst_port1) and log in audit.log
##   Input            remote server sends tcp connect to bridge at destination
##                    port (tst_port1)
##   Expected Result  packets pass, connection succeeds, audit.log has record
+ accept \
    mlsop=eq expres=success \
    host=remote type=unlabeled op=sendrand_tcp ipv=ipv4 port=$tst_port1 \
    tnum=13 '$ipv $port'
## TESTCASE: Test #13 tnum 14
##   Table Rule       INPUT chain policy set to DROP no other rule
##   Input            remote server sends tcp connect to bridge ipv4 address
##   Expected Result  packets dropped, listen times out, no audit record
##                    because the DROP policy is used due to the test
##                    requirement and not the AUDIT_DROP target/chain
+ accept \
    mlsop=eq expres=fail err=EINTR\
    host=remote type=unlabeled op=sendrand_tcp ipv=ipv4 port=$tst_port1 \
    tnum=14 '$ipv $port'
## TESTCASE: Test #14 tnum 15
##   Table Rule       accept packets to logical bridge device (BRIDGE_FILTER)
##   Input            remote server sends tcp connect to bridge ipv4 address
##   Expected Result  packets pass, connection succeeds, audit.log has record
+ accept \
    mlsop=eq expres=success \
    host=remote type=unlabeled op=sendrand_tcp ipv=ipv4 port=$tst_port1 \
    tnum=15 '$ipv $port'
## TESTCASE: Test #15 tnum 16
##   Table Rule       drop packets to logical bridge device (BRIDGE_FILTER)
##   Input            remote server sends tcp connect to bridge ipv4 address
##   Expected Result  packets dropped, listen times out, audit.log has record
+ accept \
    mlsop=eq expres=fail err=EINTR\
    host=remote type=unlabeled op=sendrand_tcp ipv=ipv4 port=$tst_port1 \
    tnum=16 '$ipv $port'
## TESTCASE: Test #16 tnum 17
##   Table Rule       accepts packets from mac address of remote server eth1
##   Input            remote server sends tcp connect to bridge ipv4 address
##   Expected Result  packets pass, connection succeeds, audit.log has record
+ accept \
    mlsop=eq expres=success \
    host=remote type=unlabeled op=sendrand_tcp ipv=ipv4 port=$tst_port1 \
    tnum=17 '$ipv $port'
## TESTCASE: Test #17 tnum 18
##   Table Rule       drop packets from mac address of remote server
##   Input            remote server sends tcp connect to bridge ipv4 address
##   Expected Result  packets dropped, listen times out, audit.log has record
+ accept \
    mlsop=eq expres=fail err=EINTR \
    host=remote type=unlabeled op=sendrand_tcp ipv=ipv4 port=$tst_port1 \
    tnum=18 '$ipv $port'
## TESTCASE: Test #18 tnum 19
##   Table Rule       accepts packets to mac address of TOE device enslaved
##                    to bridge
##   Input            remote server sends tcp connect to bridge ipv4 address
##   Expected Result  packets pass, connection succeeds, audit.log has record
+ accept \
    mlsop=eq expres=success \
    host=remote type=unlabeled op=sendrand_tcp ipv=ipv4 port=$tst_port1 \
    tnum=19 '$ipv $port'
## TESTCASE: Test #19 tnum 20
##   Table Rule       drop packets to mac address of TOE device enslaved
##                    to bridge
##   Input            remote server sends tcp connect to bridge ipv4 address
##   Expected Result  packets dropped, listen times out, audit.log has record
+ accept \
    mlsop=eq expres=fail err=EINTR \
    host=remote type=unlabeled op=sendrand_tcp ipv=ipv4 port=$tst_port1 \
    tnum=20 '$ipv $port'
## TESTCASE: Test #20 tnum 21
##   Table Rule       no blocking
##   Input            TOE sends tcp connect (ipv6) to remote server over bridge
##   Expected Result  connection succeeds
+ connect \
    mlsop=eq expres=success \
    host=remote type=unlabeled op=recv_tcp ipv=ipv6 port=$tst_port1 \
    tnum=21 '$host_remote tcp $port'
## TESTCASE: Test #21 tnum 22
##   Table Rule       drop packets to TOE device enslaved to bridge
##   Input            TOE sends tcp connect (ipv6) to remote server over bridge
##   Expected Result  response packets dropped, connect times out, audit.log
##                    has record
+ connect \
    mlsop=eq expres=fail err=ETIMEDOUT \
    host=remote type=unlabeled op=recv_tcp ipv=ipv6 port=$tst_port1 \
    tnum=22 '$host_remote tcp $port'
## TESTCASE: Test #22 tnum 23
##   Table Rule       no blocking
##   Input            TOE sends tcp connect (ipv6) to remote server over bridge
##   Expected Result  connection succeeds
+ connect \
    mlsop=eq expres=success \
    host=remote type=unlabeled op=recv_tcp ipv=ipv6 port=$tst_port1 \
    tnum=23 '$host_remote tcp $port'
## TESTCASE: Test #23 tnum 24
##   Table Rule       drop packets with ipv6 source address of remote server
##                    and log in audit.log
##   Input            TOE sends tcp connect (ipv6) to remote server over bridge
##   Expected Result  response packets from remote server are dropped and
##                    connect times out. audit.log has records
+ connect \
    mlsop=eq expres=fail err=ETIMEDOUT \
    host=remote type=unlabeled op=recv_tcp ipv=ipv6 port=$tst_port1 \
    tnum=24 '$host_remote tcp $port'
## TESTCASE: Test #24 tnum 25
##   Table Rule       drop packets to TOE ipv6 address of bridge device and log
##                    in audit.log
##   Input            TOE sends tcp connect (ipv6) to remote server over bridge
##   Expected Result  response packets (ipv6) from remote server are dropped
##                    and connect times out.
+ connect \
    mlsop=eq expres=fail err=ETIMEDOUT \
    host=remote type=unlabeled op=recv_tcp ipv=ipv6 port=$tst_port1 \
    tnum=25 '$host_remote tcp $port'
## TESTCASE: Test #25 tnum 26
##   Table Rule       no blocking
##   Input            TOE sends tcp connect (ipv6) to remote server over bridge
##   Expected Result  connection succeeds
+ connect \
    mlsop=eq expres=success \
    host=remote type=unlabeled op=recv_tcp ipv=ipv6 port=$tst_port1 \
    tnum=26 '$host_remote tcp $port'
## TESTCASE: Test #26 tnum 27
##   Table Rule       drop tcp (ipv6) packets with remote server source port
##                    tst_port1 and log in audit.log
##   Input            TOE sends tcp connect (ipv6) to remote server over bridge
##   Expected Result  response packets from remote server with specified source
##                    port are dropped, connect times out, audit.log has record
+ connect \
    mlsop=eq expres=fail err=ETIMEDOUT \
    host=remote type=unlabeled op=recv_tcp ipv=ipv6 port=$tst_port1 \
    tnum=27 '$host_remote tcp $port'
## TESTCASE: Test #27 tnum 28
##   Table Rule       drop tcp (ipv6) packets to TOE bridge with destination
##                    port tst_port1 and log in audit.log
##   Input            remote server sends tcp (ipv6) connect to TOE at port
##                    tst_port1
##   Expected Result  packets to port are dropped, listen times out,
##                    audit.log has record
+ accept \
    mlsop=eq expres=fail err=EINTR\
    host=remote type=unlabeled op=sendrand_tcp ipv=ipv6 port=$tst_port1 \
    tnum=28 '$ipv $port'
## TESTCASE: Test #28 tnum 29
##   Table Rule       no blocking
##   Input            remote server sends udp packets to bridge ipv6 address
##   Expected Result  packets pass through
+ recvfrom \
    mlsop=eq expres=success \
    host=remote type=unlabeled op=sendrand_udp ipv=ipv6 port=$tst_port1 \
    tnum=29 '$ipv $port'
## TESTCASE: Test #29 tnum 30
##   Table Rule       udp (ipv6) packets to TOE with source port $srcrange range
##                    are dropped
##   Input            remote server sends udp packets to bridge ipv6 address
##   Expected Result  packets dropped, audit.log has record
+ recvfrom \
    mlsop=eq expres=fail err=EINTR \
    host=remote type=unlabeled op=sendrand_udp ipv=ipv6 port=$tst_port1 \
    tnum=30 '$ipv $port'
## TESTCASE: Test #30 tnum 31
##   Table Rule       udp (ipv6) packets to TOE with destination port tst_port1
##                    are dropped
##   Input            remote server sends udp packets to bridge ipv6 address
##   Expected Result  packets dropped, audit.log has record
+ recvfrom \
    mlsop=eq expres=fail err=EINTR \
    host=remote type=unlabeled op=sendrand_udp ipv=ipv6 port=$tst_port1 \
    tnum=31 '$ipv $port'
## TESTCASE: Test #31 tnum 32
##   Table Rule       no blocking
##   Input            remote server sends tcp connect (ipv6) to TOE
##   Expected Result  connection succeeds
+ accept \
    mlsop=eq expres=success \
    host=remote type=unlabeled op=sendrand_tcp ipv=ipv6 port=$tst_port1 \
    tnum=32 '$ipv $port'
## TESTCASE: Test #32 tnum 33
##   Table Rule       INPUT chain policy set to DROP, tcp (ipv6) packets to
##                    TOE port tst_port1 allowed. log of accepted packets to
##                    to audit.log
##   Input            remote server sends tcp connect (ipv6) to TOE port
##                    tst_port1
##   Expected Result  connect succeeds, audit log has record
+ accept \
    mlsop=eq expres=success \
    host=remote type=unlabeled op=sendrand_tcp ipv=ipv6 port=$tst_port1 \
    tnum=33 '$ipv $port'
## TESTCASE: Test #33 tnum 34
##   Table Rule       INPUT chain policy set to DROP, only port 22 allowed.
##   Input            remote server sends tcp connect (ipv6) to TOE port
##                    tst_port1
##   Expected Result  connect fails, listen times out, no log of connect packets
+ accept \
    mlsop=eq expres=fail err=EINTR\
    host=remote type=unlabeled op=sendrand_tcp ipv=ipv6 port=$tst_port1 \
    tnum=34 '$ipv $port'
## TESTCASE: Test #34 tnum 35
##   Table Rule       logical bridge device accepts traffic and logs
##                    to audit.log
##   Input            remote server sends tcp connect (ipv6) to TOE bridge
##                    address
##   Expected Result  connect succeeds, audit.log has record
+ accept \
    mlsop=eq expres=success \
    host=remote type=unlabeled op=sendrand_tcp ipv=ipv6 port=$tst_port1 \
    tnum=35 '$ipv $port'
## TESTCASE: Test #35 tnum 36
##   Table Rule       logical bridge device drops packets and logs to audit.log
##   Input            remote server sends tcp connect (ipv6) to TOE bridge
##                    address
##   Expected Result  connect fails, listen times out, audit.log has record
+ accept \
    mlsop=eq expres=fail err=EINTR\
    host=remote type=unlabeled op=sendrand_tcp ipv=ipv6 port=$tst_port1 \
    tnum=36 '$ipv $port'
## TESTCASE: Test #36 tnum 37
##   Table Rule       accept packets (ipv6) from mac address of remote server
##                    and log to audit.log
##   Input            remote server sends tcp connect (ipv6) to TOE bridge
##   Expected Result  connect succeeds, packets logged in audit.log
+ accept \
    mlsop=eq expres=success \
    host=remote type=unlabeled op=sendrand_tcp ipv=ipv6 port=$tst_port1 \
    tnum=37 '$ipv $port'
## TESTCASE: Test #37 tnum 38
##   Table Rule       drop packets (ipv6) from mac address of remote server
##                    and log to audit.log
##   Input            remote server sends tcp connect (ipv6) to TOE bridge
##   Expected Result  connect fails, listen times out, audit.log has record
+ accept \
    mlsop=eq expres=fail err=EINTR \
    host=remote type=unlabeled op=sendrand_tcp ipv=ipv6 port=$tst_port1 \
    tnum=38 '$ipv $port'
## TESTCASE: Test #38 tnum 39
##   Table Rule       accept packets (ipv6) to mac address of TOE device
##                    enslaved to bridge and log to audit.log
##   Input            remote server sends tcp connect (ipv6) to TOE bridge
##   Expected Result  connect succeeds, packets logged in audit.log
+ accept \
    mlsop=eq expres=success \
    host=remote type=unlabeled op=sendrand_tcp ipv=ipv6 port=$tst_port1 \
    tnum=39 '$ipv $port'
## TESTCASE: Test #39 tnum 40
##   Table Rule       drop packets (ipv6) to mac address of TOE device
##                    enslaved to bridge and log to audit.log
##   Input            remote server sends tcp connect (ipv6) to TOE bridge
##   Expected Result  connect fails, dropped packets logged in audit.log
+ accept \
    mlsop=eq expres=fail err=EINTR \
    host=remote type=unlabeled op=sendrand_tcp ipv=ipv6 port=$tst_port1 \
    tnum=40 '$ipv $port'
## TESTCASE Test #40 tnum 41
##  No Table Rule     This test insures a normal user does not have
##                    permision to modify the ebtables
##  Input             testperm.bash script adds a regular user and then
##                    su to the user and attempts to add a ebtables rule
##  Expected Result   Permission is denied and rule is not added
+ testperm.bash \
    mlsop=eq expres=success \
    host=local tnum=41
