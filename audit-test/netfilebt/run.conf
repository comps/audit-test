#!/bin/bash
# =============================================================================
# (c) Copyright Hewlett-Packard Development Company, L.P., 2005, 2006, 2007
#
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of version 2 the GNU General Public License as
#   published by the Free Software Foundation.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
# =============================================================================

######################################################################
# global variables
######################################################################

tst_port1=4100

######################################################################
# helper functions
######################################################################

#
# get_test_domain - Get the SELinux domain for the test applet
#
# INPUT
# $1 : the labeling type
# $2 : the host type
#
# OUTPUT
# Writes the SELinux domain to stdout
#
# DESCRIPTION
# This function determines the correct SELinux domain to use for the test
# applet based on the given labeling type.
#
function get_test_domain {
    declare type_arg=$1 host_arg=$2

    case $PPROFILE-$host_arg in
	lspp-*|capp-remote)
            case $type_arg in
		unlabeled)
                    echo "lspp_test_generic_t"
		    ;;
		*)
		    exit_fail "invalid test argument"
	            ;;
	    esac
	    ;;
	capp-local)
	    case $type_arg in
	        *)
		    echo "unconfined_t"
		    ;;
	    esac
            ;;
    esac
}

#
# get_label_subj - Get the subject's sensitivity label for the test run
#
# INPUT
# $1 : the MLS "op"
#
# OUPUT
# Writes the subject's untranslated sensivity label to stdout
#
# DESCRIPTION
# This function sets the subject's sensitivity label for the test run
# based on the MLS "op". The MLS "op" will always specify  the subject
# is to be equal to (eq) the object for the ebtables filtering tests.
# This MLS "op" definition assumes the Bell-LaPadula based MLS
# constraints in use by the SELinux MLS policy derived from the SELinux
# Reference Policy.
#
function get_label_subj {
    declare mlsop_arg=$1

    case $PPROFILE in
	lspp)
            case $mlsop_arg in
		eq)
		    echo "SystemLow"
		    ;;
		*)
		    exit_fail "invalid test argument"
		    ;;
	    esac
	    ;;
	capp)
            case $mlsop_arg in
		*)
		    # in targeted policy (the likely policy for CAPP) the s0
		    # sensitivity label is translated into a NULL string so we
		    # have to use the untranslated sensitivity label
		    echo "s0"
		    ;;
	    esac
	    ;;
    esac
}

#
# get_label_obj - Get the object's sensitivity label for the test run
#
# INPUT
# $1 : the MLS "op"
#
# OUPUT
# Writes the object's untranslated sensivity label to stdout
#
# DESCRIPTION
# This function determines the objects's sensitivity label for the test run
# based on the MLS "op".  The MLS "op" specifies the subject is to be equal
# to (eq) the object.
# This MLS "op" definition assumes the Bell-LaPadula based MLS
# constraints in use by the SELinux MLS policy derived from the SELinux
# Reference Policy.
#
function get_label_obj {
    declare mlsop_arg=$1

    case $PPROFILE in
	lspp)
            case $mlsop_arg in
		eq)
		    echo "SystemLow"
		    ;;
		*)
		    exit_fail "invalid test argument"
		    ;;
	    esac
	    ;;
	capp)
            case $mlsop_arg in
		*)
		    # in targeted policy (the likely policy for CAPP) the s0
		    # sensitivity label is translated into a NULL string so we
		    # have to use the untranslated sensitivity label
		    echo "s0"
		    ;;
	    esac
	    ;;
    esac
}

######################################################################
# defaults
######################################################################

#
# setup_default - Setup the remote test driver
#
# INPUT
# none
#
# OUTPUT
# none
#
# DESCRIPTION
# All of the ebtables tests in this file need to either send data to a remote
# node or receive data from a remote node; this function does the required
# setup to initialize the remote node based on the individual test case. This
# function works for both "local" (localhost) and "remote" (non-localhost)
# host types using both IPv4 and IPv6. No ebtables tests are run on the local
# loopback device.  This function determines the setup
# needed by the test using the "op", "host", "type", "mlsop", "ipv", and
# "port" named arguments as given on the test command line.  On error the
# function calls exit_error() which marks the test case as resulting in an
# error.  This function assumes the remote node is running a test driver
# similar to the one found in "utils/network-server/lblnet_tst_server.c".
#
function setup_default {
    declare cmd_str remote_obj ipf s

    ipf="${ipv:+-${ipv#ipv}}"  # ipv flag, -4 or -6 or empty

    s=$(send_ns $ipf -S "$host") || exit_error
    append_cleanup "send_ns $ipf -s \"$s\" -K \"$host\""

    remote_obj="$(get_label_obj $mlsop)"
    cmd_str="lock,sh;"
    cmd_str+="setsockcreatecon,system_u:system_r:$(get_test_domain $type $host):$remote_obj;"
    send_ns $ipf -s "$s" "$host" "$cmd_str" || exit_error
    check_ns $ipf -s "$s" "$host" -- '0 .*' || exit_error

    case $op in
        sendrand_tcp)
            send_ns $ipf -s "$s" "$host" "timeout,10;sendx,tcp,$port" || exit_error ;;
        sendrand_udp)
            send_ns $ipf -s "$s" "$host" "timeout,10;sendx,udp,$port" || exit_error ;;
        recv_tcp)
            port=$(send_ns $ipf -s "$s" "$host" "timeout,10;recvx,tcp") || exit_error ;;
        recv_udp)
            port=$(send_ns $ipf -s "$s" "$host" "timeout,10;recvx,udp") || exit_error ;;
        *)
            exit_fail "invalid test argument: $op" ;;
    esac

    ns_session="$s"
}

######################################################################
# run.bash overrides
######################################################################

# Rename the original run.bash + function to run+ and create our own + function
# that generates a tag for the test based on the named parameters.

#
# + - Generate a unique tag for each test case and run the default "+" function
#
# INPUT
# $@ : test command line
#
# OUTPUT
# none
#
# DESCRIPTION
# This function acts as a wrapper for the original "+" function which is
# responsibile for running each test case shown at the bottom of this file.
# This wrapper function is necessary to automatically generate a unique tag for
# each test case based on it's named arguments.  This tag is then used as an
# additional named argument for the default "+" function.
#
eval "function run+ $(type + | sed '1,2d')"
function + {
    declare test=$1 tag # make sure it's not inherited from caller
    shift
    eval "$(parse_named "$@")" || exit_error

    if sc_is_relevant "$test" || [[ "$test" == testperm* ]]; then
        if [[ -z $tag ]]; then
            # extract the named args that identify a unique testcase
            run+ "$test" \
                tag="${test}__${host}_${type}_${ipv}_${expres}_subj_${mlsop}_obj" \
                "$@"
        else
            # use tag supplied in run.conf
            run+ "$test" "$@"
        fi
    fi

    # if $test (syscall) has a socketcall counterpart, add it for testing
    if sc_is_relevant "socketcall" && is_socketcall_op "$test"; then
        if [[ -z $tag ]]; then
            run+ socketcall \
                tag="socketcall_${test}__${host}_${type}_${ipv}_${expres}_subj_${mlsop}_obj" \
                "$test" "$@"
        else
            run+ socketcall "$test" "$@"
        fi
    fi
}

#
# show_test - Display the test case details
#
# INPUT
# $@ : test command line
#
# OUTPUT
# Writes the test case details to stdout
#
# DESCRIPTION
# This function reads in the entire test case command line and depending on
# the verbosity of the test harness either the entire command line is dumped
# to stdout or just the tag named variable as generated by the +() function
# defined in this file.  All output is handled by the fmt_test() function
# which is defined as by the test harness.  This function was overloaded
# because of the special handling for the tag named variable.
#
function show_test {
    if ! $opt_verbose; then
	declare tag # make sure it's not inherited from caller
	eval "$(parse_named "$@")" || exit_error
	[[ -n $tag ]] && set -- "$tag"
    fi
    fmt_test "[$TESTNUM]" "$@"
}

#
#
# This function sets up the ebtables targets that allow an audit log
# of packets matching the rule that uses either AUDIT_DROP or
# AUDIT_ACCEPT as the target in the rule.
#
function ebtaudit_setup {

ebtables -A INPUT -p arp -j ACCEPT
ebtables -A INPUT -p ipv6 --ip6-protocol ipv6-icmp --ip6-icmp-type neighbour-solicitation -j ACCEPT
ebtables -A INPUT -p ipv6 --ip6-protocol ipv6-icmp --ip6-icmp-type neighbour-advertisement -j ACCEPT

ebtables -N AUDIT_DROP
ebtables -A AUDIT_DROP -j AUDIT --audit-type DROP
ebtables -A AUDIT_DROP -j DROP

ebtables -N AUDIT_ACCEPT
ebtables -A AUDIT_ACCEPT -j AUDIT --audit-type ACCEPT
ebtables -A AUDIT_ACCEPT -j ACCEPT
}

######################################################################
# run_test
######################################################################

#
# run_test - Execute an individual test case
#
# INPUT
# $@ : test command line
#
# OUTPUT
# Returns true on test success, other error values on test failure
#
# DESCRIPTION
# This function is responsibile for executing all aspects of an individual
# test case including the following: setup, audit configuration and rotation,
# test case execution, test case verification, and audit verification.  Most of
# these tasks are handled by other helper function defined either in this file
# or in the test harness, however, they are called from inside this function
# based on the individual test case's requirements.  In the case where a test
# is run and it returns true and the audit verification is successful then this
# function returns true and the test case can be considered to have passed.
# However, if either the test case returns non-true, the audit trail is not
# correct, or an error occurs elsewhere then this function calls either the
# exit_fail() or exit_error() functions to signify a test case failure.
#
function run_test {
    declare syscall=$1 tst_name=$1
    declare x name value status log_mark
    declare test_domain label_subj label_obj host_remote
    declare ns_session
    shift
    eval "$(parse_named "$@")" || exit_error

    source netfilebt_functions.bash || exit_error

    if [[ tnum -eq 41 ]]; then
       ./testperm.bash
       return $?
    fi

    # get the derived variables
    #  NOTE: the $test_domain variable is always using the "local" version of
    #        the test domain because the value is always only used on the
    #        local machine (see below)
    test_domain=$(get_test_domain $type local)
    label_subj=$(get_label_subj $mlsop)
    label_obj=$(get_label_obj $mlsop)
    host_remote=$(host_ns ${ipv:+-${ipv#ipv}} $host)

    # backup original ruleset, schedule ruleset restoration, clean current one
    # NOTE: clean the ruleset before original -restore, to clean tables used by
    #       this test, but unused/unspecified by original ruleset
    original_rules="$(mktemp)"
    ebtables-save > "$original_rules"
    append_cleanup "{ ebtables-save | xtables_empty | ebtables-restore; cat $original_rules | ebtables-restore; rm -f $original_rules; }"
    ebtables-save | xtables_empty | ebtables-restore

    # prepare cleanup and run the default setup
        append_cleanup "tstsvr_cleanup $host_remote"
        ebtaudit_setup
        setup_default

        case $tnum in
              2)
               ebtables -A INPUT -i $enslaved_if -j AUDIT_DROP
                 ;;
              4)
               ebtables -A INPUT -p IPv4 --ip-source $remote_ipv4 -j AUDIT_DROP
                 ;;
              5)
               ebtables -A INPUT -p IPv4 --ip-destination $local_ipv4 -j AUDIT_DROP
                 ;;
              7)
               ebtables -A INPUT -p IPv4 --ip-proto TCP --ip-source-port $port -j AUDIT_DROP
                 ;;
              8)
               ebtables -A INPUT -p IPv4 --ip-proto TCP --ip-destination-port $tst_port1 -j AUDIT_DROP
                 ;;
             10)
               srcrange=$(cat /proc/sys/net/ipv4/ip_local_port_range | tr '\t' ':')
               ebtables -A INPUT -p IPv4 --ip-proto UDP --ip-source-port $srcrange -j AUDIT_DROP
                 ;;
             11)
               ebtables -A INPUT -p IPv4 --ip-proto UDP --ip-destination-port $tst_port1 -j AUDIT_DROP
                 ;;
             13)
               ebtables -A INPUT -p IPv4 --ip-proto TCP --ip-destination-port 22 -j AUDIT_ACCEPT
               ebtables -A INPUT -p IPv4 --ip-proto TCP --ip-destination-port $tst_port1 -j AUDIT_ACCEPT
               ebtables -P INPUT DROP
                 ;;
             14)
               ebtables -A INPUT -p IPv4 --ip-proto TCP --ip-destination-port 22 -j AUDIT_ACCEPT
               ebtables -P INPUT DROP
                 ;;
             15)
               ebtables -A INPUT --logical-in $bridge_if -j AUDIT_ACCEPT
                 ;;
             16)
               ebtables -A INPUT --logical-in $bridge_if -j AUDIT_DROP
                 ;;
             17)
               ebtables -A INPUT -s $remote_mac -j AUDIT_ACCEPT
                 ;;
             18)
               ebtables -A INPUT -s $remote_mac -j AUDIT_DROP
                 ;;
             19)
               ebtables -A INPUT -d $local_mac -j AUDIT_ACCEPT
                 ;;
             20)
               ebtables -A INPUT -d $local_mac -j AUDIT_DROP
                 ;;
             22)
               ebtables -A INPUT -i $enslaved_if -j AUDIT_DROP
                 ;;
             24)
               ebtables -A INPUT -p IPv6 --ip6-source $remote_ipv6 -j AUDIT_DROP
                 ;;
             25)
               ebtables -A INPUT -p IPv6 --ip6-destination $local_ipv6 -j AUDIT_DROP
                 ;;
             27)
               ebtables -A INPUT -p IPv6 --ip6-proto TCP --ip6-source-port $port -j AUDIT_DROP
                 ;;
             28)
               ebtables -A INPUT -p IPv6 --ip6-proto TCP --ip6-destination-port $tst_port1 -j AUDIT_DROP
                 ;;
             30)
               srcrange=$(cat /proc/sys/net/ipv4/ip_local_port_range | tr '\t' ':')
               ebtables -A INPUT -p IPv6 --ip6-proto UDP --ip6-source-port $srcrange -j AUDIT_DROP
                 ;;
             31)
               ebtables -A INPUT -p IPv6 --ip6-proto UDP --ip6-destination-port $tst_port1 -j AUDIT_DROP
                 ;;
             33)
               ebtables -A INPUT -p IPv6 --ip6-proto TCP --ip6-destination-port 22 -j AUDIT_ACCEPT
               ebtables -A INPUT -p IPv6 --ip6-proto TCP --ip6-destination-port $tst_port1 -j AUDIT_ACCEPT
               ebtables -P INPUT DROP
                 ;;
             34)
               ebtables -A INPUT -p IPv6 --ip6-proto TCP --ip6-destination-port 22 -j AUDIT_ACCEPT
               ebtables -P INPUT DROP
                 ;;
             35)
               ebtables -A INPUT --logical-in $bridge_if -j AUDIT_ACCEPT
                 ;;
             36)
               ebtables -A INPUT --logical-in $bridge_if -j AUDIT_DROP
                 ;;
             37)
               ebtables -A INPUT -s $remote_mac -j AUDIT_ACCEPT
                 ;;
             38)
               ebtables -A INPUT -s $remote_mac -j AUDIT_DROP
                 ;;
             39)
               ebtables -A INPUT -d $local_mac -j AUDIT_ACCEPT
                 ;;
             40)
               ebtables -A INPUT -d $local_mac -j AUDIT_DROP
                 ;;
              *)
               echo "test case = $tnum"
                 ;;
        esac

    # display ruleset in use
    echo "=== ebtables ==="
    ebtables-save

    # force the audit log to rotate
    rotate_audit_logs || exit_error

    # mark the log for augrok later
    log_mark=$(stat -c %s $audit_log)
    # run this in a subshell so that exit_* doesn't abort early
    (
        declare testres exitval pid
	declare tst_args=( $(eval echo \"${unnamed[*]}\") )
        set -x
        # run the test itself
        read testres exitval pid <<< \
          "$(runcon -t $test_domain -l $(get_label_subj $mlsop) \
               do_$tst_name "${tst_args[@]}" 2>&1 1>/dev/null)"

        echo "testres is "$testres" and exitval is "$exitval" "
        [[ -z $testres || -z $exitval || -z $pid ]] && exit_error
        check_result $expres $testres $exitval $err

##  audit.log is checked for packets of message type NETFILTER_PKT,
##  the appropriate action (0 = accepted, 1 = dropped), and the interface on
##  which it occurred ($enslaved_if) against the tnums where an audit
##  record is expected

        case $tnum in
              2 | 4 | 5 | 7 | 8 | 10 | 11)
               asreturn=$(ausearch -m NETFILTER_PKT -if /var/log/audit/audit.log \
                    | grep action=1 | grep -m 1 inif="$enslaved_if")
               if [[ -n $asreturn ]]; then
                  echo " "$asreturn" "
                  exit_pass
               else
                  exit_fail "missing log in audit.log"
               fi
                   ;;
              13 | 15 | 19 | 33 | 37 | 39)
               asreturn=$(ausearch -m NETFILTER_PKT -if /var/log/audit/audit.log \
                    | grep action=0 | grep -m 1 inif="$enslaved_if")
               if [[ -n $asreturn ]]; then
                  echo " "$asreturn" "
                  exit_pass
               else
                  exit_fail "missing log in audit.log"
               fi
                   ;;
              16 | 18 | 20 | 22 | 24 | 25 | 27)
               asreturn=$(ausearch -m NETFILTER_PKT -if /var/log/audit/audit.log \
                    | grep action=1 | grep -m 1 inif="$enslaved_if")
               if [[ -n $asreturn ]]; then
                  echo " "$asreturn" "
                  exit_pass
               else
                  exit_fail "missing log in audit.log"
               fi
                   ;;
              28 | 30 | 31 | 38 | 40)
                asreturn=$(ausearch -m NETFILTER_PKT | grep action=1 | grep -m 1 inif="$enslaved_if")
               if [[ -n $asreturn ]]; then
                  echo " "$asreturn" "
                  exit_pass
               else
                  exit_fail "missing log in audit.log"
               fi
                   ;;
              *)
                exit_pass
                ;;
        esac

    )
    status=$?

    return $status
}

######################################################################
# pre-testrun checks/configuration
######################################################################

startup_hook()
{
    local_ipv4=$(send_ns -4 remote 'myaddr') || exit_error
    local_ipv6=$(send_ns -6 remote 'myaddr') || exit_error
    remote_ipv4=$(host_ns -4 remote) || exit_error
    remote_ipv6=$(host_ns -6 remote) || exit_error

    bridge_if=$(ip -o route get to "$remote_ipv4" | sed 's/.* dev \([^ ]\+\).*/\1/')
    ip -o -d link show dev "$bridge_if" | grep -q ' bridge' || \
        exit_error "$bridge_if is not a bridge"
    enslaved_if=$(ip -o link show | sed -n "/master $bridge_if/"'s/[0-9]\+: \([^:]\+\):.*/\1/p')
    [ "$enslaved_if" ] || exit_error "$bridge_if has no enslaved devices"
    [ "$(echo "$enslaved_if" | wc -l)" -eq 1 ] || \
        exit_error "$bridge_if has more than one enslaved device"

    local_mac=$(ip -o link show dev "$bridge_if" | sed 's/.* link\/ether \([^ ]\+\).*/\1/')
    [ "$local_mac" ] || exit_error "local MAC address for $bridge_if not found"

    local gw=$(ip -o route get to "$remote_ipv4" | sed 's/.* via \([^ ]\+\).*/\1/')
    local arping_out=$(arping -I "$bridge_if" -f "$gw") || exit_error "arping failed"
    remote_mac=$(echo "$arping_out" | sed -n '/Unicast reply from/s/.*\[\(.*\)\].*/\1/p')
    [ "$remote_mac" ] || exit_error "remote MAC address for $remote_ipv4 not found"

    # other tests may have changed time / confused rsyslog, try restarting it
    restart_service rsyslog
}

######################################################################
# test configuration
######################################################################

# It is important to note that prior to running any of the test below the
# system must be properly configured. See the README.netfilter file.

##
##  ebtables system calls
##

# The test cases below are in the following format, with optional elements
# denoted by square brackets ([...]):
#
#  + <_syscall_> \
#    mlsop=<_mlsop_> expres=<_expres_> err=<_err_> \
#    host=<_host_> type=<_type_> op=<_op_> ipv=<_ipv_> port=<_port_> \
#    <_test_args_>
#
# Where the arguments are defined as follows:
#
#  _syscall_     : the syscall itself is not being tested for ebtables but
#                  is being used to generate the traffic for the test
#
#  _mlsop_       : the MLS label comparison operator for more information see
#                  the comments elsewhere in this file, only 1 value used for
#                  ebtables. For compatibitlity with lblnet_tst_server
#                  value:
#                    eq     : the local test process label equals the remote
#                             process/packet/connection's label
#  _expres_      : indicates that the operation should succeed (success) or
#                  fail (fail) based on the system's security policy
#  _err_         : if the test should fail, it should fail with this error
#                  code/value
#  _host_        : indicates if the test is against a local (local) or
#                  remote (remote) host, the actual remote IP address is
#                  determined from the SECNET_SVR_IPV4 and SECNET_SVR_IPV6
#                  environment variables
#  _type_        : the labeling protocol, kept for purposes of compatibility
#                    with the lblnet_tst_server. Only 1 type used:
#                    unlabeled : not a labeling protocol, no need for ebtables
#  _op_          : the remote test driver command, there are four valid values:
#                    sendrand_tcp : initiate a TCP connection with the test
#                                   machine and send data
#                    sendrand_udp : send UDP traffic to the test machine
#                    recv_tcp     : accept TCP connections from the test
#                                   machine and receive data from established
#                                   connections
#                    recv_udp     : receive UDP traffic from the test machine
#  _ipv_         : the IP version, there are two values: ipv4 and ipv6
#  _port_        : the TCP or UDP port
#  _test_args_   : arguments to supply to the test applet/program, these may
#                  be variables which are later expanded inside the run_test()
#                  function

## SYSCALLS:     accept() connect() recvfrom()
## PURPOSE:
## Verify that incoming packets are only allowed to pass on the bridge device
## when the ebtables chain rule or policy is set to accept the packet and
## are dropped when a chain rule or policy so dictates. A check is also made
## for an audit record of the accepted or dropped packet when the rule so
## specifies a target of AUDIT_ACCEPT or AUDIT_DROP.
## These test cases make use of a remote test driver to initiate a connection
## from the remote node to the host under test, see the setup_default()
## function above for details on configuring the remote test driver.  In
## The test procedure is as follows:
##  1. Configure the audit subsystem to watch for the syscall record
##  2. Restart ebtables to set it to a known condition, add the AUDIT_ACCEPT
##     and AUDIT_DROP chains and set the INPUT chain with the appropriate
##     rule to test the specific filter feature.
##  3. Execute the test case on the local system and verify the result
##  4. Check the audit log for the correct syscall result and in the case of
##     failure check for generated audit records indicating that a packet
##     was dropped  or in some cases of success we check that an audit record
##     was generated for a packet that was acccepted.
## TESTCASE: Test #0 tnum 1
##   Table Rule       no blocking
##   Input            TOE sends tcp connect to remote server over bridge
##   Expected Result  packets pass, connection succeeds
+ connect \
    mlsop=eq expres=success \
    host=remote type=unlabeled op=recv_tcp ipv=ipv4 \
    tnum=1 '$host_remote tcp $port'
## TESTCASE: Test #1 tnum 2
##   Table Rule       drop incoming packets on device enslaved to bridge
##                    and log in audit.log
##   Input            TOE sends tcp connect to remote server over bridge
##   Expected Result  response packets dropped, connect times out, audit.log
##                    has record
+ connect \
    mlsop=eq expres=fail err=ETIMEDOUT \
    host=remote type=unlabeled op=recv_tcp ipv=ipv4 \
    tnum=2 '$host_remote tcp $port'
## TESTCASE: Test #2 tnum 3
##   Table Rule       no blocking
##   Input            TOE sends tcp connect to remote server over bridge
##   Expected Result  packets pass, connection succeeds
+ connect \
    mlsop=eq expres=success \
    host=remote type=unlabeled op=recv_tcp ipv=ipv4 \
    tnum=3 '$host_remote tcp $port'
## TESTCASE: Test #3 tnum 4
##   Table Rule       drop packets with source address of remote server and log
##                    in audit.log
##   Input            TOE sends tcp connect to remote server over bridge
##   Expected Result  response packets dropped, connect times out, audit.log
##                    has record
+ connect \
    mlsop=eq expres=fail err=ETIMEDOUT \
    host=remote type=unlabeled op=recv_tcp ipv=ipv4 \
    tnum=4 '$host_remote tcp $port'
## TESTCASE: Test #4 tnum 5
##   Table Rule       drop incoming packets to TOE bridge ipv4 address and log
##                    in audit.log
##   Input            TOE sends TCP connect to remote server over bridge
##   Expected Result  response packets dropped, connect times out, audit.log
##                    has record
+ connect \
    mlsop=eq expres=fail err=ETIMEDOUT \
    host=remote type=unlabeled op=recv_tcp ipv=ipv4 \
    tnum=5 '$host_remote tcp $port'
## TESTCASE: Test #5 tnum 6
##   Table Rule       no blocking
##   Input            remote server sends tcp connect to bridge ipv4 address
##   Expected Result  packets pass, connection succeeds
+ connect \
    mlsop=eq expres=success \
    host=remote type=unlabeled op=recv_tcp ipv=ipv4 \
    tnum=6 '$host_remote tcp $port'
## TESTCASE: Test #6 tnum 7
##   Table Rule       drop TCP packets with source port (tst_port1) and log
##                    in audit.log
##   Input            TOE sends TCP connect to remote server over bridge
##   Expected Result  response packets dropped, connect times out, audit.log
##                    has record
+ connect \
    mlsop=eq expres=fail err=ETIMEDOUT \
    host=remote type=unlabeled op=recv_tcp ipv=ipv4 \
    tnum=7 '$host_remote tcp $port'
## TESTCASE: Test #7 tnum 8
##   Table Rule       drop TCP packets with destination port (tst_port1) and log
##                    in audit.log
##   Input            remote server sends tcp connect to bridge ipv4 address
##                    with destination port (tst_port1)
##   Expected Result  response packets dropped, listen times out, audit.log
##                    has record
+ accept \
    mlsop=eq expres=fail err=EINTR \
    host=remote type=unlabeled op=sendrand_tcp ipv=ipv4 port=$tst_port1 \
    tnum=8 '$ipv $port'
## TESTCASE: Test #8 tnum 9
##   Table Rule       no blocking
##   Input            remote server sends udp packets to bridge ipv4 address
##   Expected Result  packets pass through
+ recvfrom \
    mlsop=eq expres=success \
    host=remote type=unlabeled op=sendrand_udp ipv=ipv4 port=$tst_port1 \
    tnum=9 '$ipv $port'
## TESTCASE: Test #9 tnum 10
##   Table Rule       drop UDP from source port range $srcrange and log in
##                    audit.log
##   Input            remote server sends udp packets to bridge ipv4 address
##   Expected Result  packets dropped, audit.log has record
+ recvfrom \
    mlsop=eq expres=fail err=EINTR \
    host=remote type=unlabeled op=sendrand_udp ipv=ipv4 port=$tst_port1 \
    tnum=10 '$ipv $port'
## TESTCASE: Test #10 tnum 11
##   Table Rule       drop UDP packets to destination port (tst_port1) and log
##                    audit.log
##   Input            remote server sends udp packets to bridge ipv4 address
##                    at destination port
##   Expected Result  packets dropped, audit.log has record
+ recvfrom \
    mlsop=eq expres=fail err=EINTR \
    host=remote type=unlabeled op=sendrand_udp ipv=ipv4 port=$tst_port1 \
    tnum=11 '$ipv $port'
## TESTCASE: Test #11 tnum 12
##   Table Rule       no blocking
##   Input            remote server sends tcp connect to bridge ipv4 address
##   Expected Result  packets pass, connection succeeds
+ accept \
    mlsop=eq expres=success \
    host=remote type=unlabeled op=sendrand_tcp ipv=ipv4 port=$tst_port1 \
    tnum=12 '$ipv $port'
## TESTCASE: Test #12 tnum 13
##   Table Rule       INPUT chain policy set to DROP, ACCEPT TCP packets to
##                    port destination port (tst_port1) and log in audit.log
##   Input            remote server sends tcp connect to bridge at destination
##                    port (tst_port1)
##   Expected Result  packets pass, connection succeeds, audit.log has record
+ accept \
    mlsop=eq expres=success \
    host=remote type=unlabeled op=sendrand_tcp ipv=ipv4 port=$tst_port1 \
    tnum=13 '$ipv $port'
## TESTCASE: Test #13 tnum 14
##   Table Rule       INPUT chain policy set to DROP no other rule
##   Input            remote server sends tcp connect to bridge ipv4 address
##   Expected Result  packets dropped, listen times out, no audit record
##                    because the DROP policy is used due to the test
##                    requirement and not the AUDIT_DROP target/chain
+ accept \
    mlsop=eq expres=fail err=EINTR \
    host=remote type=unlabeled op=sendrand_tcp ipv=ipv4 port=$tst_port1 \
    tnum=14 '$ipv $port'
## TESTCASE: Test #14 tnum 15
##   Table Rule       accept packets to logical bridge device (BRIDGE_FILTER)
##   Input            remote server sends tcp connect to bridge ipv4 address
##   Expected Result  packets pass, connection succeeds, audit.log has record
+ accept \
    mlsop=eq expres=success \
    host=remote type=unlabeled op=sendrand_tcp ipv=ipv4 port=$tst_port1 \
    tnum=15 '$ipv $port'
## TESTCASE: Test #15 tnum 16
##   Table Rule       drop packets to logical bridge device (BRIDGE_FILTER)
##   Input            remote server sends tcp connect to bridge ipv4 address
##   Expected Result  packets dropped, listen times out, audit.log has record
+ accept \
    mlsop=eq expres=fail err=EINTR \
    host=remote type=unlabeled op=sendrand_tcp ipv=ipv4 port=$tst_port1 \
    tnum=16 '$ipv $port'
## TESTCASE: Test #16 tnum 17
##   Table Rule       accepts packets from mac address of remote server eth1
##   Input            remote server sends tcp connect to bridge ipv4 address
##   Expected Result  packets pass, connection succeeds, audit.log has record
+ accept \
    mlsop=eq expres=success \
    host=remote type=unlabeled op=sendrand_tcp ipv=ipv4 port=$tst_port1 \
    tnum=17 '$ipv $port'
## TESTCASE: Test #17 tnum 18
##   Table Rule       drop packets from mac address of remote server
##   Input            remote server sends tcp connect to bridge ipv4 address
##   Expected Result  packets dropped, listen times out, audit.log has record
+ accept \
    mlsop=eq expres=fail err=EINTR \
    host=remote type=unlabeled op=sendrand_tcp ipv=ipv4 port=$tst_port1 \
    tnum=18 '$ipv $port'
## TESTCASE: Test #18 tnum 19
##   Table Rule       accepts packets to mac address of TOE device enslaved
##                    to bridge
##   Input            remote server sends tcp connect to bridge ipv4 address
##   Expected Result  packets pass, connection succeeds, audit.log has record
+ accept \
    mlsop=eq expres=success \
    host=remote type=unlabeled op=sendrand_tcp ipv=ipv4 port=$tst_port1 \
    tnum=19 '$ipv $port'
## TESTCASE: Test #19 tnum 20
##   Table Rule       drop packets to mac address of TOE device enslaved
##                    to bridge
##   Input            remote server sends tcp connect to bridge ipv4 address
##   Expected Result  packets dropped, listen times out, audit.log has record
+ accept \
    mlsop=eq expres=fail err=EINTR \
    host=remote type=unlabeled op=sendrand_tcp ipv=ipv4 port=$tst_port1 \
    tnum=20 '$ipv $port'
## TESTCASE: Test #20 tnum 21
##   Table Rule       no blocking
##   Input            TOE sends tcp connect (ipv6) to remote server over bridge
##   Expected Result  connection succeeds
+ connect \
    mlsop=eq expres=success \
    host=remote type=unlabeled op=recv_tcp ipv=ipv6 \
    tnum=21 '$host_remote tcp $port'
## TESTCASE: Test #21 tnum 22
##   Table Rule       drop packets to TOE device enslaved to bridge
##   Input            TOE sends tcp connect (ipv6) to remote server over bridge
##   Expected Result  response packets dropped, connect times out, audit.log
##                    has record
+ connect \
    mlsop=eq expres=fail err=ETIMEDOUT \
    host=remote type=unlabeled op=recv_tcp ipv=ipv6 \
    tnum=22 '$host_remote tcp $port'
## TESTCASE: Test #22 tnum 23
##   Table Rule       no blocking
##   Input            TOE sends tcp connect (ipv6) to remote server over bridge
##   Expected Result  connection succeeds
+ connect \
    mlsop=eq expres=success \
    host=remote type=unlabeled op=recv_tcp ipv=ipv6 \
    tnum=23 '$host_remote tcp $port'
## TESTCASE: Test #23 tnum 24
##   Table Rule       drop packets with ipv6 source address of remote server
##                    and log in audit.log
##   Input            TOE sends tcp connect (ipv6) to remote server over bridge
##   Expected Result  response packets from remote server are dropped and
##                    connect times out. audit.log has records
+ connect \
    mlsop=eq expres=fail err=ETIMEDOUT \
    host=remote type=unlabeled op=recv_tcp ipv=ipv6 \
    tnum=24 '$host_remote tcp $port'
## TESTCASE: Test #24 tnum 25
##   Table Rule       drop packets to TOE ipv6 address of bridge device and log
##                    in audit.log
##   Input            TOE sends tcp connect (ipv6) to remote server over bridge
##   Expected Result  response packets (ipv6) from remote server are dropped
##                    and connect times out.
+ connect \
    mlsop=eq expres=fail err=ETIMEDOUT \
    host=remote type=unlabeled op=recv_tcp ipv=ipv6 \
    tnum=25 '$host_remote tcp $port'
## TESTCASE: Test #25 tnum 26
##   Table Rule       no blocking
##   Input            TOE sends tcp connect (ipv6) to remote server over bridge
##   Expected Result  connection succeeds
+ connect \
    mlsop=eq expres=success \
    host=remote type=unlabeled op=recv_tcp ipv=ipv6 \
    tnum=26 '$host_remote tcp $port'
## TESTCASE: Test #26 tnum 27
##   Table Rule       drop tcp (ipv6) packets with remote server source port
##                    tst_port1 and log in audit.log
##   Input            TOE sends tcp connect (ipv6) to remote server over bridge
##   Expected Result  response packets from remote server with specified source
##                    port are dropped, connect times out, audit.log has record
+ connect \
    mlsop=eq expres=fail err=ETIMEDOUT \
    host=remote type=unlabeled op=recv_tcp ipv=ipv6 \
    tnum=27 '$host_remote tcp $port'
## TESTCASE: Test #27 tnum 28
##   Table Rule       drop tcp (ipv6) packets to TOE bridge with destination
##                    port tst_port1 and log in audit.log
##   Input            remote server sends tcp (ipv6) connect to TOE at port
##                    tst_port1
##   Expected Result  packets to port are dropped, listen times out,
##                    audit.log has record
+ accept \
    mlsop=eq expres=fail err=EINTR \
    host=remote type=unlabeled op=sendrand_tcp ipv=ipv6 port=$tst_port1 \
    tnum=28 '$ipv $port'
## TESTCASE: Test #28 tnum 29
##   Table Rule       no blocking
##   Input            remote server sends udp packets to bridge ipv6 address
##   Expected Result  packets pass through
+ recvfrom \
    mlsop=eq expres=success \
    host=remote type=unlabeled op=sendrand_udp ipv=ipv6 port=$tst_port1 \
    tnum=29 '$ipv $port'
## TESTCASE: Test #29 tnum 30
##   Table Rule       udp (ipv6) packets to TOE with source port $srcrange range
##                    are dropped
##   Input            remote server sends udp packets to bridge ipv6 address
##   Expected Result  packets dropped, audit.log has record
+ recvfrom \
    mlsop=eq expres=fail err=EINTR \
    host=remote type=unlabeled op=sendrand_udp ipv=ipv6 port=$tst_port1 \
    tnum=30 '$ipv $port'
## TESTCASE: Test #30 tnum 31
##   Table Rule       udp (ipv6) packets to TOE with destination port tst_port1
##                    are dropped
##   Input            remote server sends udp packets to bridge ipv6 address
##   Expected Result  packets dropped, audit.log has record
+ recvfrom \
    mlsop=eq expres=fail err=EINTR \
    host=remote type=unlabeled op=sendrand_udp ipv=ipv6 port=$tst_port1 \
    tnum=31 '$ipv $port'
## TESTCASE: Test #31 tnum 32
##   Table Rule       no blocking
##   Input            remote server sends tcp connect (ipv6) to TOE
##   Expected Result  connection succeeds
+ accept \
    mlsop=eq expres=success \
    host=remote type=unlabeled op=sendrand_tcp ipv=ipv6 port=$tst_port1 \
    tnum=32 '$ipv $port'
## TESTCASE: Test #32 tnum 33
##   Table Rule       INPUT chain policy set to DROP, tcp (ipv6) packets to
##                    TOE port tst_port1 allowed. log of accepted packets to
##                    to audit.log
##   Input            remote server sends tcp connect (ipv6) to TOE port
##                    tst_port1
##   Expected Result  connect succeeds, audit log has record
+ accept \
    mlsop=eq expres=success \
    host=remote type=unlabeled op=sendrand_tcp ipv=ipv6 port=$tst_port1 \
    tnum=33 '$ipv $port'
## TESTCASE: Test #33 tnum 34
##   Table Rule       INPUT chain policy set to DROP, only port 22 allowed.
##   Input            remote server sends tcp connect (ipv6) to TOE port
##                    tst_port1
##   Expected Result  connect fails, listen times out, no log of connect packets
+ accept \
    mlsop=eq expres=fail err=EINTR \
    host=remote type=unlabeled op=sendrand_tcp ipv=ipv6 port=$tst_port1 \
    tnum=34 '$ipv $port'
## TESTCASE: Test #34 tnum 35
##   Table Rule       logical bridge device accepts traffic and logs
##                    to audit.log
##   Input            remote server sends tcp connect (ipv6) to TOE bridge
##                    address
##   Expected Result  connect succeeds, audit.log has record
+ accept \
    mlsop=eq expres=success \
    host=remote type=unlabeled op=sendrand_tcp ipv=ipv6 port=$tst_port1 \
    tnum=35 '$ipv $port'
## TESTCASE: Test #35 tnum 36
##   Table Rule       logical bridge device drops packets and logs to audit.log
##   Input            remote server sends tcp connect (ipv6) to TOE bridge
##                    address
##   Expected Result  connect fails, listen times out, audit.log has record
+ accept \
    mlsop=eq expres=fail err=EINTR \
    host=remote type=unlabeled op=sendrand_tcp ipv=ipv6 port=$tst_port1 \
    tnum=36 '$ipv $port'
## TESTCASE: Test #36 tnum 37
##   Table Rule       accept packets (ipv6) from mac address of remote server
##                    and log to audit.log
##   Input            remote server sends tcp connect (ipv6) to TOE bridge
##   Expected Result  connect succeeds, packets logged in audit.log
+ accept \
    mlsop=eq expres=success \
    host=remote type=unlabeled op=sendrand_tcp ipv=ipv6 port=$tst_port1 \
    tnum=37 '$ipv $port'
## TESTCASE: Test #37 tnum 38
##   Table Rule       drop packets (ipv6) from mac address of remote server
##                    and log to audit.log
##   Input            remote server sends tcp connect (ipv6) to TOE bridge
##   Expected Result  connect fails, listen times out, audit.log has record
+ accept \
    mlsop=eq expres=fail err=EINTR \
    host=remote type=unlabeled op=sendrand_tcp ipv=ipv6 port=$tst_port1 \
    tnum=38 '$ipv $port'
## TESTCASE: Test #38 tnum 39
##   Table Rule       accept packets (ipv6) to mac address of TOE device
##                    enslaved to bridge and log to audit.log
##   Input            remote server sends tcp connect (ipv6) to TOE bridge
##   Expected Result  connect succeeds, packets logged in audit.log
+ accept \
    mlsop=eq expres=success \
    host=remote type=unlabeled op=sendrand_tcp ipv=ipv6 port=$tst_port1 \
    tnum=39 '$ipv $port'
## TESTCASE: Test #39 tnum 40
##   Table Rule       drop packets (ipv6) to mac address of TOE device
##                    enslaved to bridge and log to audit.log
##   Input            remote server sends tcp connect (ipv6) to TOE bridge
##   Expected Result  connect fails, dropped packets logged in audit.log
+ accept \
    mlsop=eq expres=fail err=EINTR \
    host=remote type=unlabeled op=sendrand_tcp ipv=ipv6 port=$tst_port1 \
    tnum=40 '$ipv $port'
## TESTCASE Test #40 tnum 41
##  No Table Rule     This test insures a normal user does not have
##                    permision to modify the ebtables
##  Input             testperm.bash script adds a regular user and then
##                    su to the user and attempts to add a ebtables rule
##  Expected Result   Permission is denied and rule is not added
+ testperm.bash \
    mlsop=eq expres=success \
    host=local tnum=41
