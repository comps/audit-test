#!/bin/bash
# =============================================================================
# (c) Copyright Hewlett-Packard Development Company, L.P., 2005, 2006, 2007
#
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of version 2 the GNU General Public License as
#   published by the Free Software Foundation.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
# =============================================================================

######################################################################
# global variables
######################################################################

tstsvr_lock_timeout_lspp=3000           # in seconds (50m)
tstsvr_lock_timeout_capp=120            # in seconds (2m)
tstsvr_lock_timeout=0
tstsvr_lock_held=0
tst_port1=4100                          # port for unlabeled traffic
tst_port2=4200                          # port for netlabel traffic
tst_port3=4300                          # port for labeled ipsec traffic
xndrst=0
######################################################################
# helper functions
######################################################################

#
# get_test_domain - Get the SELinux domain for the test applet
#
# INPUT
# $1 : the labeling type
# $2 : the host type
#
# OUTPUT
# Writes the SELinux domain to stdout
#
# DESCRIPTION
# This function determines the correct SELinux domain to use for the test
# applet based on the given labeling type.
#
function get_test_domain {
    declare type_arg=$1 host_arg=$2

    case $PPROFILE-$host_arg in
	lspp-*|capp-remote)
            case $type_arg in
		unlabeled)
                    echo "lspp_test_generic_t"
		    ;;
		*)
		    exit_fail "invalid test argument"
	            ;;
	    esac
	    ;;
	capp-local)
	    case $type_arg in
	        *)
		    echo "unconfined_t"
		    ;;
	    esac
            ;;
    esac
}

#
# get_label_subj - Get the subject's sensitivity label for the test run
#
# INPUT
# $1 : the MLS "op"
#
# OUPUT
# Writes the subject's untranslated sensivity label to stdout
#
# DESCRIPTION
# This function sets the subject's sensitivity label for the test run
# based on the MLS "op". The MLS "op" will always specify  the subject
# is to be equal to (eq) the object for the ebtables filtering tests.
# This MLS "op" definition assumes the Bell-LaPadula based MLS
# constraints in use by the SELinux MLS policy derived from the SELinux
# Reference Policy.
#
function get_label_subj {
    declare mlsop_arg=$1

    case $PPROFILE in
	lspp)
            case $mlsop_arg in
		eq)
		    echo "SystemLow"
		    ;;
		*)
		    exit_fail "invalid test argument"
		    ;;
	    esac
	    ;;
	capp)
            case $mlsop_arg in
		*)
		    # in targeted policy (the likely policy for CAPP) the s0
		    # sensitivity label is translated into a NULL string so we
		    # have to use the untranslated sensitivity label
		    echo "s0"
		    ;;
	    esac
	    ;;
    esac
}

#
# get_label_obj - Get the object's sensitivity label for the test run
#
# INPUT
# $1 : the MLS "op"
#
# OUPUT
# Writes the object's untranslated sensivity label to stdout
#
# DESCRIPTION
# This function determines the objects's sensitivity label for the test run
# based on the MLS "op".  The MLS "op" specifies the subject is to be equal
# to (eq) the object.
# This MLS "op" definition assumes the Bell-LaPadula based MLS
# constraints in use by the SELinux MLS policy derived from the SELinux
# Reference Policy.
#
function get_label_obj {
    declare mlsop_arg=$1

    case $PPROFILE in
	lspp)
            case $mlsop_arg in
		eq)
		    echo "SystemLow"
		    ;;
		*)
		    exit_fail "invalid test argument"
		    ;;
	    esac
	    ;;
	capp)
            case $mlsop_arg in
		*)
		    # in targeted policy (the likely policy for CAPP) the s0
		    # sensitivity label is translated into a NULL string so we
		    # have to use the untranslated sensitivity label
		    echo "s0"
		    ;;
	    esac
	    ;;
    esac
}

#
# get_host_local - Get the IP address to use as the local address for the test
#
# INPUT
# $1 : the IP version
# $2 : the host type
#
# OUTPUT
# Writes the IP address to stdout
#
# DESCRIPTION
# This function determines the correct local address to use for the test run
# based on an IP version string, "ipv4" or "ipv6", and the host type, "local"
# or "remote".  While the "local" host types resolve to the IPv4 or IPv6
# localhost address the "remote" host types resolve to IP addresses specified
# in environment variables which are queried at the start of the test run.
#
function get_host_local {
    declare ipv_arg=$1 host_arg=$2

    case $ipv_arg in
	ipv4)
	    case $host_arg in
		local)
		    echo "127.0.0.1"
		    ;;
		remote)
		    echo "$lblnet_loc4_host"
		    ;;
		*)
		    exit_fail "invalid test argument"
		    ;;
	    esac
	    ;;
	ipv6)
	    case $host_arg in
		local)
		    echo "::1"
		    ;;
		remote)
		    echo "$lblnet_loc6_host"
		    ;;
		*)
		    exit_fail "invalid test argument"
		    ;;
	    esac
	    ;;
	*)
	    exit_fail "invalid test argument"
	    ;;
	esac
}

#
# get_host_remote - Get the IP address to use as the remote address
#
# INPUT
# $1 : the IP version
# $2 : the host type
#
# OUTPUT
# Writes the IP address to stdout
#
# DESCRIPTION
# This function determines the correct remote address to use for the test
# run based on an IP version string, "ipv4" or "ipv6", and the host type,
# "local" or "remote".  While the "local" host types resolve to the IPv4 or
# IPv6 localhost address the "remote" host types resolve to IP addresses
# specified in environment variables which are queried at the start of the
# test run.
#
function get_host_remote {
    declare ipv_arg=$1 host_arg=$2

    case $ipv_arg in
	ipv4)
	    case $host_arg in
		local)
		    echo "127.0.0.1"
		    ;;
		remote)
		    echo "$lblnet_svr4_host"
		    ;;
		*)
		    exit_fail "invalid test argument"
		    ;;
	    esac
	    ;;
	ipv6)
	    case $host_arg in
		local)
		    echo "::1"
		    ;;
		remote)
		    echo "$lblnet_svr6_host"
		    ;;
		*)
		    exit_fail "invalid test argument"
		    ;;
	    esac
	    ;;
	*)
	    exit_fail "invalid test argument"
	    ;;
	esac
}

#
# tstsvr_lock - Lock the remote test server
#
# INPUT
# none
#
# OUTPUT
# Returns true if the test server was able to be locked, false otherwise
#
# DESCRIPTION
# This function attempts to lock the remote test server with the timeout value
# specified in the global variable $tstsvr_lock_timeout.  If the function is
# able to lock the remote test server then it returns true and sets the global
# variable $tstsvr_lock_held to 1 for use in the tstsvr_unlock() function.  If
# for any reason the function is not able to lock the remote test server then
# the function returns false and the value in $tstsvr_lock_held is unchanged.
# This function assumes the remote node is running a test driver similar to the
# one found in "utils/network-server/lblnet_tst_server.c".
#
function tstsvr_lock {
    declare rc
    declare cmd_str="lock:set,$tstsvr_lock_timeout;"

    rc="$(nc -6 -w 3 $lblnet_svr6_host 4000 <<< $cmd_str)"
    if [[ $rc == 0 ]]; then
	tstsvr_lock_held=1
	return 0
    fi

    return 1
}

#
# tstsvr_unlock - Unlock the remote test server
#
# INPUT
# none
#
# OUTPUT
# none
#
# DESCRIPTION
# This function attempts to unlock the remote test server if it was locked
# previously during this test run.  The function checks the $tstsvr_lock_held
# global variable and if the value is 1, set by the tstsvr_lock() function,
# then the function sends an unlock command to the remote test server.  If the
# $tstsvr_lock_held variable is not set to 1 then this function does nothing.
# This function assumes the remote node is running a test driver similar to the
# one found in "utils/network-server/lblnet_tst_server.c".
#
function tstsvr_unlock {
    declare cmd_str="lock:release;"

    if [[ $tstsvr_lock_held == 1 ]]; then
	nc -6 -w 3 $lblnet_svr6_host 4000 <<< $cmd_str
    fi
}

#
# verify_remote - Verify that the remote test server is available for use
#
# INPUT
# none
#
# OUTPUT
# Returns true if the remote test server is available, false otherwise
#
# DESCRIPTION
# This function checks to see if the remote test server is available for use
# and is able to be locked for this test run in which case it returns true.
# If the test server is offline, or in use by another host and unable to be
# locked then this function returns false.
#
function verify_remote {
    tstsvr_lock
    return $?
}

######################################################################
# defaults
######################################################################

#
# setup_default - Setup the remote test driver
#
# INPUT
# none
#
# OUTPUT
# none
#
# DESCRIPTION
# All of the netfilter tests in this file need to either send data to a remote
# or local lblnet_tst_server application or receive data from a remote or local
# lblnet_tst_server application. This function does the required setup to
# initialize the lblnet_tst_server based on the individual test case.  This
# function works for both "local" (localhost) and "remote" (non-localhost)
# host types using both IPv4 and IPv6.  This function determines the setup
# needed by the test using the "op", "host", "type", "mlsop", "ipv", and
# "port" named arguments as given on the test command line.  On error the
# function calls exit_error() which marks the test case as resulting in an
# error.  This function assumes the remote node is running a test driver
# similar to the one found in "utils/network-server/lblnet_tst_server.c".
# This function automatically starts the local lblnet_tst_server when required
# and kills it at the finish of the test. The remote lblnet_tst_server must
# be started manually and is checked for it's validity prior to the start
# of each test. So it must be running on the remote server regardless of
# whether the test being run uses the local loopback device or not.
#
function setup_default {
    declare rc=1
    declare tspid=0
    declare xndpid=0
    declare cmd_str
    declare remote_obj local_host
    declare loop_cnt

    # in the case where we are using the local device start/restart the
    # netfilter network server to insure needed ports are listened on.

    echo "host is "$host" "
    echo " "$lblnet_svr6_host" "
    if [[ $host == local ]]; then
       xndpid=$(ps -C xinetd -o pid=)
       tspid=$(ps -C lblnet_tst_server -o pid=)
       echo " xinetd pid is "$xndpid" "
       echo " pid is "$tspid" "
       if [[ $tspid ]]; then
          kill -9 $tspid
       fi
    fi

    # generate the host command string
    remote_obj="$(get_label_obj $mlsop)"
    cmd_str="sockcon:full,system_u:system_r:$(get_test_domain $type $host):$remote_obj;"
    cmd_str+="detach;"
    case $op in
	sendrand_tcp)
            local_host="$(get_host_local $ipv $host)"
            cmd_str+="sleep:5;"
            echo "local host is $local_host"
            cmd_str+="sendrand:$local_host,tcp,$port,1;"
	    ;;
	sendrand_udp)
	    local_host="$(get_host_local $ipv $host)"
            cmd_str+="sleep:5;"
            cmd_str+="sendrand:$local_host,udp,$port,1;"
	    ;;
	recv_tcp)
            cmd_str+="recv:$ipv,tcp,$port,0;"
	    ;;
	recv_udp)
            cmd_str+="recv:$ipv,udp,$port,1;"
	    ;;
	*)
	    exit_fail "invalid test argument"
	    ;;
    esac

    # setup the remote test server (try more than once)
    for ((loop_cnt=0; loop_cnt<=2 && rc!=0; loop_cnt++)); do
	case $host in
	    remote)
	        rc="$(nc -6 -w 3 $lblnet_svr6_host 4000 <<< $cmd_str)"
		;;
	    local)
	        # use the same port as the remote IPv4 setting
	        rc="$(nc -w 3 ::1 4000 <<< $cmd_str)"
	        ;;
	    *)
	        exit_fail "invalid test argument"
		;;
	esac
	if [[ $rc != 0 ]]; then
	    echo "notice: failed to setup remote test server, retrying"
            echo "return code = "$rc" "
	    sleep 10
	fi
    done

    # verify the setup
    if [[ $rc != 0 ]]; then
	exit_error "could not setup remote test server"
    fi
}

######################################################################
# run.bash overrides
######################################################################

# Rename the original run.bash + function to run+ and create our own + function
# that generates a tag for the test based on the named parameters.

#
# + - Generate a unique tag for each test case and run the default "+" function
#
# INPUT
# $@ : test command line
#
# OUTPUT
# none
#
# DESCRIPTION
# This function acts as a wrapper for the original "+" function which is
# responsibile for running each test case shown at the bottom of this file.
# This wrapper function is necessary to automatically generate a unique tag for
# each test case based on it's named arguments.  This tag is then used as an
# additional named argument for the default "+" function.
#
eval "function run+ $(type + | sed '1,2d')"
function + {
    declare test=$1 tag # make sure it's not inherited from caller
    shift
    eval "$(parse_named "$@")" || exit_error
    if [[ -z $tag ]]; then
        # extract the named args that identify a unique testcase
        run+ $test \
	    tag="${test}__${host}_${type}_${ipv}_${expres}_subj_${mlsop}_obj" \
	    "$@"
    else
        # use tag supplied in run.conf
        run+ $test "$@"
    fi
}

#
# show_test - Display the test case details
#
# INPUT
# $@ : test command line
#
# OUTPUT
# Writes the test case details to stdout
#
# DESCRIPTION
# This function reads in the entire test case command line and depending on
# the verbosity of the test harness either the entire command line is dumped
# to stdout or just the tag named variable as generated by the +() function
# defined in this file.  All output is handled by the fmt_test() function
# which is defined as by the test harness.  This function was overloaded
# because of the special handling for the tag named variable.
#
function show_test {
    if ! $opt_verbose; then
	declare tag # make sure it's not inherited from caller
	eval "$(parse_named "$@")" || exit_error
	[[ -n $tag ]] && set -- "$tag"
    fi
    fmt_test "[$TESTNUM]" "$@"
}

#
# network_cleanup - Release the lock on the remote test server
#
# INPUT
# none
#
# OUTPUT
# none
#
# DESCRIPTION
# This function tries to unlock the remote test server by calling the
# tstsvr_unlock() function.
#
function network_cleanup {
    tstsvr_unlock
}
prepend_cleanup 'network_cleanup'

#
# This function sets up the iptables targets that allow an audit log
# of packets matching the rule that uses either AUDIT_DROP, AUDIT_REJECT, or
# AUDIT_ACCEPT as the target in the rule.
#
function iptables_setup {

iptables -N AUDIT_DROP
iptables -A AUDIT_DROP -j AUDIT --type DROP
iptables -A AUDIT_DROP -j DROP

iptables -N AUDIT_REJECT
iptables -A AUDIT_REJECT -j AUDIT --type REJECT
iptables -A AUDIT_REJECT -j REJECT

iptables -N AUDIT_ACCEPT
iptables -A AUDIT_ACCEPT -j AUDIT --type ACCEPT
iptables -A AUDIT_ACCEPT -j ACCEPT
}
#
# This function sets up the ip6tables targets that allow an audit log
# of packets matching the rule that uses either AUDIT_DROP, AUDIT_REJECT, or
# AUDIT_ACCEPT as the target in the rule.
#
function ip6tables_setup {

ip6tables -N AUDIT_DROP
ip6tables -A AUDIT_DROP -j AUDIT --type DROP
ip6tables -A AUDIT_DROP -j DROP

ip6tables -N AUDIT_REJECT
ip6tables -A AUDIT_REJECT -j AUDIT --type REJECT
ip6tables -A AUDIT_REJECT -j REJECT

ip6tables -N AUDIT_ACCEPT
ip6tables -A AUDIT_ACCEPT -j AUDIT --type ACCEPT
ip6tables -A AUDIT_ACCEPT -j ACCEPT
}

######################################################################
# run_test
######################################################################

#
# run_test - Execute an individual test case
#
# INPUT
# $@ : test command line
#
# OUTPUT
# Returns true on test success, other error values on test failure
#
# DESCRIPTION
# This function is responsibile for executing all aspects of an individual
# test case including the following: setup, audit configuration and rotation,
# test case execution, test case verification, and audit verification.  Most of
# these tasks are handled by other helper function defined either in this file
# or in the test harness, however, they are called from inside this function
# based on the individual test case's requirements.  In the case where a test
# is run and it returns true and the audit verification is successful then this
# function returns true and the test case can be considered to have passed.
# However, if either the test case returns non-true, the audit trail is not
# correct, or an error occurs elsewhere then this function calls either the
# exit_fail() or exit_error() functions to signify a test case failure.
#
function run_test {
    declare syscall=$1 tst_name=$1
    declare x name value status log_mark lcreturn
    declare test_domain label_subj label_obj host_local host_remote
    declare inifv protov actv ouifv
    shift
    eval "$(parse_named "$@")" || exit_error

    source netfilter_functions.bash || exit_error

    if [[ tnum -eq 63 ]]; then
       ./testpermip4.bash
       return $?
    fi
    if [[ tnum -eq 64 ]]; then
       ./testpermip6.bash
       return $?
    fi

    # get the derived variables
    #  NOTE: the $test_domain variable is always using the "local" version of
    #        the test domain because the value is always only used on the
    #        local machine (see below)
    test_domain=$(get_test_domain $type local)
    label_subj=$(get_label_subj $mlsop)
    label_obj=$(get_label_obj $mlsop)
    host_local=$(get_host_local $ipv $host)
    host_remote=$(get_host_remote $ipv $host)

    # backup original ruleset, schedule ruleset restoration, clean current one
    # NOTE: clean the ruleset before original -restore, to clean tables used by
    #       this test, but unused/unspecified by original ruleset
    original_rules4="$(mktemp)"
    original_rules6="$(mktemp)"
    iptables-save > "$original_rules4"
    ip6tables-save > "$original_rules6"
    append_cleanup "{ iptables-save | xtables_empty | iptables-restore; cat $original_rules4 | iptables-restore; rm -f $original_rules4; }"
    append_cleanup "{ ip6tables-save | xtables_empty | ip6tables-restore; cat $original_rules6 | ip6tables-restore; rm -f $original_rules6; }"
    iptables-save | xtables_empty | iptables-restore
    ip6tables-save | xtables_empty | ip6tables-restore

    # run the setup callback (which has access to the named params)
    # default setup
        iptables_setup
        ip6tables_setup
        # exclude ping and RST tests
        if ! [[ $tnum -ge 29 && $tnum -le 36 ]] \
        && ! [[ $tnum -ge 45 && $tnum -le 46 ]]; then
             append_cleanup "tstsvr_cleanup $host_remote"
             setup_default
             echo "going to setup_default"
        fi
    #  This is the giant case statement that checks the tnum to determine
    #  how the iptables or ip6tables need to be setup. In most cases we use
    #  the -I <chain> 1 option since it's hard to predict what the default
    #  setting is going to be. Ideally the tables are empty and in an ACCEPT
    #  policy when we restart them.

        case $tnum in
              2)
               iptables -A INPUT -i lo -j AUDIT_DROP
               inifv="lo"
               actv=1
                 ;;
              4)
               ip6tables -A INPUT -i lo -j AUDIT_DROP
               inifv="lo"
               actv=1
                 ;;
              6)
               iptables -A INPUT -p tcp --sport $tst_port1 -j AUDIT_REJECT
               protov=6
               actv=2
                 ;;
              8)
               ip6tables -A OUTPUT -p tcp --sport $tst_port1 -j AUDIT_DROP
               proto=6
               actv=1
                 ;;
             10)
               iptables -A INPUT -p tcp --dport $tst_port1 -j AUDIT_REJECT
               proto=6
               actv=2
                 ;;
             12)
               ip6tables -A INPUT -p tcp --dport $tst_port1 -j AUDIT_REJECT
               proto=6
               actv=2
                 ;;
             14)
               srcrange=$(cat /proc/sys/net/ipv4/ip_local_port_range | tr '\t' ':')
               iptables -A OUTPUT -p udp --sport $srcrange -j AUDIT_DROP
               proto=17
               actv=1
                 ;;
             16)
               srcrange=$(cat /proc/sys/net/ipv4/ip_local_port_range | tr '\t' ':')
               ip6tables -A OUTPUT -p udp --sport $srcrange -j AUDIT_DROP
               proto=17
               actv=1
                 ;;
             18)
               iptables -A OUTPUT -p udp --dport $tst_port1 -j AUDIT_REJECT
               proto=17
               actv=2
                 ;;
             20)
               ip6tables -A OUTPUT -p udp --dport $tst_port1 -j AUDIT_REJECT
               proto=17
               actv=2
                 ;;
             22)
               iptables -A INPUT -d 127.0.0.1 -j AUDIT_DROP
               proto=6
               actv=1
                 ;;
             24)
               ip6tables -A INPUT -d ::1 -j AUDIT_DROP
               protov=6
               actv=1
                 ;;
             26)
               iptables -A OUTPUT -s 127.0.0.1 -j AUDIT_REJECT
               protov=6
               actv=2
                 ;;
             28)
               ip6tables -A OUTPUT -s ::1 -j AUDIT_REJECT
               protov=6
               actv=2
                 ;;
             29)
               iptables -A INPUT -p icmp --icmp-type echo-reply -j AUDIT_DROP
               protov=1
               actv=1
                 ;;
             30)
               iptables -A INPUT -p icmp --icmp-type echo-reply -j AUDIT_ACCEPT
               protov=1
               actv=0
                 ;;
             31)
               ip6tables -A INPUT -p icmpv6 --icmpv6-type echo-reply -j AUDIT_DROP
               protov=58
               actv=1
                 ;;
             32)
               ip6tables -A INPUT -p icmpv6 --icmpv6-type echo-reply -j AUDIT_ACCEPT
               protov=58
               actv=0
                 ;;
# tnums 33-36 test the filtering of the drop policy. Since packets dropped
# via the policy setting of the chain cannot be sent to the audit.log without
# adding a rule which would include the AUDIT_DROP target thus invalidating
# the test of the policy itself, we setup a rule that only allows 2 destination
# ports for tcp segments. The control port to the network server and a port
# for a positive test. tnum 33's connect request will time out due to the
# response being dropped and tnum 34 will succeed on the accepted port
# and include an audit log
           33 | 34)
               srcrange=$(cat /proc/sys/net/ipv4/ip_local_port_range | tr '\t' ':')
               iptables -P INPUT DROP
               # add rule to make sure our ssh session stays alive
               iptables -A INPUT -p tcp --dport 22 -j ACCEPT
               iptables -A INPUT -p tcp -m multiport --dports 4000,$tst_port2 -j AUDIT_ACCEPT
               iptables -A INPUT -p tcp --dport $srcrange -j AUDIT_ACCEPT
               setup_default
               actv=0
               protov=6
                 ;;
           35 | 36)
               srcrange=$(cat /proc/sys/net/ipv4/ip_local_port_range | tr '\t' ':')
               ip6tables -P INPUT DROP
               ip6tables -A INPUT -p tcp -m multiport --dports 4000,$tst_port2 -j AUDIT_ACCEPT
               ip6tables -A INPUT -p tcp --dport $srcrange -j AUDIT_ACCEPT
               setup_default
               actv=0
               protov=6
                 ;;
             38)
               iptables -A INPUT -p tcp --tcp-flags ALL SYN -j AUDIT_REJECT
               actv=2
               protov=6
                 ;;
             40)
               ip6tables -A INPUT -p tcp --tcp-flags ALL SYN -j AUDIT_REJECT
               actv=2
               protov=6
                 ;;
             42)
               iptables -A INPUT -p tcp --dport $tst_port1 --tcp-flags ALL ACK -j LOG --log-prefix "ack received ipv4"
               iptables -A INPUT -p tcp --dport $tst_port1 --tcp-flags ALL ACK -j AUDIT_ACCEPT
               logrotate -f /etc/logrotate.d/syslog
               actv=0
               protov=6
                 ;;
             44)
               ip6tables -A INPUT -i lo -p tcp --dport $tst_port1 --tcp-flags ALL ACK -j LOG --log-prefix "ack received ipv6"
               ip6tables -A INPUT -i lo -p tcp --dport $tst_port1 --tcp-flags ALL ACK -j AUDIT_ACCEPT
               logrotate -f /etc/logrotate.d/syslog
               actv=0
               protov=6
                 ;;
             45)
               ip6tables -A INPUT -i lo -p tcp --sport $tst_port1 --tcp-flags RST RST -j LOG --log-prefix "rst received ipv6"
               ip6tables -A INPUT -i lo -p tcp --sport $tst_port1 --tcp-flags RST RST -j AUDIT_ACCEPT
               logrotate -f /etc/logrotate.d/syslog
               actv=0
               protov=6
                 ;;
             46)
               iptables -A INPUT -i lo -p tcp --sport $tst_port1 --tcp-flags RST RST -j LOG --log-prefix "rst received ipv4"
               iptables -A INPUT -i lo -p tcp --sport $tst_port1 --tcp-flags RST RST -j AUDIT_ACCEPT
               logrotate -f /etc/logrotate.d/syslog
               actv=0
               protov=6
                 ;;
             47)
               iptables -A INPUT -p tcp --dport $tst_port1 --tcp-flags PSH PSH -j LOG --log-prefix "push received ipv4"
               iptables -A INPUT -p tcp --dport $tst_port1 --tcp-flags PSH PSH -j AUDIT_ACCEPT
               logrotate -f /etc/logrotate.d/syslog
               actv=0
               protov=6
                 ;;
             48)
               ip6tables -A INPUT -i lo -p tcp --dport $tst_port1 --tcp-flags PSH PSH -j LOG --log-prefix "push received ipv6"
               ip6tables -A INPUT -i lo -p tcp --dport $tst_port1 --tcp-flags PSH PSH -j AUDIT_ACCEPT
               logrotate -f /etc/logrotate.d/syslog
               actv=0
               protov=6
                 ;;
             49)
               iptables -A INPUT -p tcp --sport $tst_port1 --tcp-flags FIN FIN -j LOG --log-prefix "fin received ipv4"
               iptables -A INPUT -p tcp --sport $tst_port1 --tcp-flags FIN FIN -j AUDIT_ACCEPT
               logrotate -f /etc/logrotate.d/syslog
               actv=0
               protov=6
                 ;;
             50)
               ip6tables -A INPUT -i lo -p tcp --sport $tst_port1 --tcp-flags ALL FIN,ACK -j LOG --log-prefix "fin received ipv6"
               ip6tables -A INPUT -i lo -p tcp --sport $tst_port1 --tcp-flags ALL FIN,ACK -j AUDIT_ACCEPT
               logrotate -f /etc/logrotate.d/syslog
               actv=0
               protov=6
                 ;;
             51)
               iptables -A INPUT -i lo -p tcp --dport $tst_port1 --tcp-flags URG URG -j LOG --log-prefix "urgent received ipv4"
               iptables -A INPUT -i lo -p tcp --dport $tst_port1 --tcp-flags URG URG -j AUDIT_ACCEPT
               logrotate -f /etc/logrotate.d/syslog
               actv=0
               protov=6
                 ;;
             52)
               ip6tables -A INPUT -i lo -p tcp --dport $tst_port1 --tcp-flags URG URG -j LOG --log-prefix "urgent received ipv6"
               ip6tables -A INPUT -i lo -p tcp --dport $tst_port1 --tcp-flags URG URG -j AUDIT_ACCEPT
               logrotate -f /etc/logrotate.d/syslog
               actv=0
               protov=6
                 ;;
             53)
               iptables -A INPUT -p tcp --dport $tst_port1 -m conntrack --ctstate NEW -j LOG --log-prefix "NEW state ipv4"
               iptables -A INPUT -p tcp --dport $tst_port1 -m conntrack --ctstate NEW -j AUDIT_ACCEPT
               actv=0
               protov=6
                 ;;
             54)
               iptables -A INPUT -i lo -m conntrack --ctstate RELATED -j LOG --log-prefix "RELATED state ipv4"
               iptables -A INPUT -p tcp --dport $tst_port1 -j AUDIT_REJECT
               actv=2
               protov=6
                 ;;
             55)
               ip6tables -A INPUT -p tcp --dport $tst_port1 -m state --state NEW -j LOG --log-prefix "NEW state ipv6"
               ip6tables -A INPUT -p tcp --dport $tst_port1 -m state --state NEW -j AUDIT_ACCEPT
               actv=0
               protov=6
                 ;;
             56)
               ip6tables -A INPUT -i lo -m state --state RELATED -j LOG --log-prefix "RELATED state ipv6"
               ip6tables -A INPUT -p tcp --dport $tst_port1 -j AUDIT_REJECT
               actv=2
               protov=6
                 ;;
             57)
               iptables -A INPUT -p tcp --dport $tst_port1 -m conntrack --ctstate ESTABLISHED -j LOG --log-prefix "ESTABLISHED state ipv4"
               iptables -A INPUT -p tcp --dport $tst_port1 -m conntrack --ctstate ESTABLISHED -j AUDIT_ACCEPT
               actv=0
               protov=6
                 ;;
             58)
               ip6tables -A INPUT -p tcp --dport $tst_port1 -m state --state ESTABLISHED -j LOG --log-prefix "ESTABLISHED state ipv6"
               ip6tables -A INPUT -p tcp --dport $tst_port1 -m state --state ESTABLISHED -j AUDIT_ACCEPT
               actv=0
               protov=6
                 ;;
             60)
               # put in rule to prevent ssh session packets from dropping.
               iptables -A INPUT -p tcp --dport 22 -j ACCEPT
               iptables -A INPUT -i $LOCAL_DEV -j DROP
                 ;;
             62)
               ip6tables -A INPUT -i $LOCAL_DEV -j DROP
                 ;;
              *)
               echo "test case = $tnum"
                 ;;
        esac

    # display ruleset in use
    echo "=== iptables ==="
    iptables-save
    echo "=== ip6tables ==="
    ip6tables-save

    # force the audit log to rotate
    rotate_audit_logs || exit_error

    # mark the log for augrok later
    log_mark=$(stat -c %s $audit_log)
    # run this in a subshell so that exit_* doesn't abort early
    (
        declare testres exitval pid
	declare tst_args=( $(eval echo \"${unnamed[*]}\") )
        set -x

        # run the test itself, some of the iptables tests require
        # generation of icmp packets and particular tcp flags and states.
        # This is done through the use of ping, nc and a newly created do_send
        # utility which turns on MSG_OOB and forces the URG flag.
        # After the test has been run a check is done for the generated audit
        # messages and the log messages in /var/log/messages
        # where appropriate. The log messages are generated as a method of
        # recording that we have in fact filtered on various tcp flags and
        # states.

        case $tnum in
           29 | 30 | 31 | 32)
                    read testres exitval pid <<< \
                      "$(do_ping $host_remote $ipv $host $local_if)"
               ;;
           45 | 46 | 47 | 48)
                    read testres exitval pid <<< \
                      "$(do_nc $host_remote $ipv $tnum $port)"
               ;;
               *)
                read testres exitval pid <<< \
                  "$(runcon -t $test_domain -l $(get_label_subj $mlsop) \
                       do_$tst_name "${tst_args[@]}" 2>&1 1>/dev/null)"
                ;;
        esac

        # See if the netfilter test server is running. This should only be
        # be happening on the same platform if we are running local tests
        # This code keeps a test from leaving a lblnet_tst_server application
        # running after a local test has been run.

        tspid=$(ps -C lblnet_tst_server -o pid=)
        echo " pid is "$tspid" "
        if [[ $tspid ]]; then
           kill -9 $tspid
        fi
        echo "testres is "$testres" and exitval is "$exitval" "
        [[ -z $testres || -z $exitval || -z $pid ]] && exit_error
        check_result $expres $testres $exitval $err

        # all of the even tnums up through 28 have ip/ip6tables generated
        # audit messages.

        oddtnum=$(expr $tnum % 2)
        if [[ $oddtnum == 0 && $tnum -lt 29 ]]; then
            asreturn=$(ausearch -m NETFILTER_PKT -if /var/log/audit/audit.log \
                       | grep action=$actv | grep -m 1 proto=$protov)
              if [[ -n $asreturn ]]; then
                 echo " "$asreturn" "
                 exit_pass
              else
                 exit_fail "missing log in audit.log"
              fi
        fi
        # tnums 29 - 32 inclusive are the pings and have audit logs
        if [[ $tnum -gt 28 ]] && [[ $tnum -lt 33 ]]; then
           asreturn=$(ausearch -m NETFILTER_PKT -if /var/log/audit/audit.log \
                    | grep action=$actv | grep -m 1 proto=$protov)
           if [[ -n $asreturn ]]; then
              echo " "$asreturn" "
              exit_pass
           else
              exit_fail "missing log in audit.log"
           fi
        fi
        # even tnums 33 through 44 inclusive will have an audit log
        if [[ $oddtnum == 0 ]] && [[ $tnum -lt 45 ]]; then
           asreturn=$(ausearch -m NETFILTER_PKT -if /var/log/audit/audit.log \
                    | grep action=$actv | grep -m 1 proto=$protov)
           if [[ -n $asreturn ]]; then
              echo " "$asreturn" "
           else
              exit_fail "missing log in audit.log"
           fi
        fi
        # all tnums 45 through 58 inclusive have an audit log
        if [[ $tnum -gt 44 ]] && [[ $tnum -lt 59 ]]; then
           if [[ $tnum == 46 ]] && [[ $xndrst == 1 ]]; then
               if [[ $PPROFILE = lspp ]] ; then
                   expect -c'
                     spawn run_init service xinetd restart
                     expect "Password:"
                     sleep 1
                     send "$env(PASSWD)\r"
                     wait
                     close'
                else
                  service xinetd restart
                fi
                xndrst=0
           fi

           asreturn=$(augrok type=NETFILTER_PKT \
                    | grep action=$actv | grep -m 1 proto=$protov)
           if [[ -n $asreturn ]]; then
              echo " "$asreturn" "
           else
              exit_fail "missing log in audit.log"
           fi
        fi
        # Some filter tests ar verified through the us of the log target
        # Cases where a particular flag or tcp state is the item to filter
        # we can verify by writing a unique prefix to the logged message
        # in the message log created when a packet with the specific
        # flag or state associated with it is recognized, and then verify
        # message log has that prefix with the logged message.
        case $tnum in
              42)
                lcreturn=$(cat /var/log/messages | grep ack' 'received' 'ipv4)
                if [[ -n $lcreturn ]]; then
                   echo " "$lcreturn" "
                   exit_pass
                else
                   exit_fail "missing log in messages file"
                fi
                   ;;
              44)
                sleep 1
                lcreturn=$(cat /var/log/messages | grep ack' 'received' 'ipv6)
                if [[ -n $lcreturn ]]; then
                   echo " "$lcreturn" "
                   exit_pass
                else
                   exit_fail "missing log in messages file"
                fi
                   ;;
              45)
                sleep 1
                lcreturn=$(cat /var/log/messages | grep rst' 'received' 'ipv6)
                if [[ -n $lcreturn ]]; then
                   echo " "$lcreturn" "
                   exit_pass
                else
                   exit_fail "missing log in messages file"
                fi
                   ;;
              46)
                sleep 2
                lcreturn=$(cat /var/log/messages | grep rst' 'received' 'ipv4)
                if [[ -n $lcreturn ]]; then
                   echo " "$lcreturn" "
                   exit_pass
                else
                   exit_fail "missing log in messages file"
                fi
                   ;;
              47)
                sleep 2
                lcreturn=$(cat /var/log/messages | grep push' 'received' 'ipv4)
                if [[ -n $lcreturn ]]; then
                   echo " "$lcreturn" "
                   exit_pass
                else
                   exit_fail "missing log in messages file"
                fi
                   ;;
              48)
                sleep 1
                lcreturn=$(cat /var/log/messages | grep push' 'received' 'ipv6)
                if [[ -n $lcreturn ]]; then
                   echo " "$lcreturn" "
                   exit_pass
                else
                   exit_fail "missing log in messages file"
                fi
                   ;;
              49)
                sleep 2
                lcreturn=$(cat /var/log/messages | grep fin' 'received' 'ipv4)
                if [[ -n $lcreturn ]]; then
                   echo " "$lcreturn" "
                   exit_pass
                else
                   exit_fail "missing log in messages file"
                fi
                   ;;
              50)
                lcreturn=$(cat /var/log/messages | grep fin' 'received' 'ipv6)
                if [[ -n $lcreturn ]]; then
                   echo " "$lcreturn" "
                   exit_pass
                else
                   exit_fail "missing log in messages file"
                fi
                   ;;
              51)
                sleep 2
                lcreturn=$(cat /var/log/messages | grep urgent' 'received' 'ipv4)
                if [[ -n $lcreturn ]]; then
                   echo " "$lcreturn" "
                   exit_pass
                else
                   exit_fail "missing log in messages file"
                fi
                   ;;
              52)
                lcreturn=$(cat /var/log/messages | grep urgent' 'received' 'ipv6)
                if [[ -n $lcreturn ]]; then
                   echo " "$lcreturn" "
                   exit_pass
                else
                   exit_fail "missing log in messages file"
                fi
                   ;;
              53)
                lcreturn=$(cat /var/log/messages | grep NEW' 'state' 'ipv4)
                if [[ -n $lcreturn ]]; then
                   echo " "$lcreturn" "
                   exit_pass
                else
                   exit_fail "missing log in messages file"
                fi
                   ;;
              54)
                lcreturn=$(cat /var/log/messages | grep RELATED' 'state' 'ipv4)
                if [[ -n $lcreturn ]]; then
                   echo " "$lcreturn" "
                   exit_pass
                else
                   exit_fail "missing log in messages file"
                fi
                   ;;
              55)
                lcreturn=$(cat /var/log/messages | grep NEW' 'state' 'ipv6)
                if [[ -n $lcreturn ]]; then
                   echo " "$lcreturn" "
                   exit_pass
                else
                   exit_fail "missing log in messages file"
                fi
                   ;;
              56)
                lcreturn=$(cat /var/log/messages | grep RELATED' 'state' 'ipv6)
                if [[ -n $lcreturn ]]; then
                   echo " "$lcreturn" "
                   exit_pass
                else
                   exit_fail "missing log in messages file"
                fi
                   ;;
              57)
                lcreturn=$(cat /var/log/messages | grep ESTABLISHED' 'state' 'ipv4)
                if [[ -n $lcreturn ]]; then
                   echo " "$lcreturn" "
                   exit_pass
                else
                   exit_fail "missing log in messages file"
                fi
                   ;;
              58)
                lcreturn=$(cat /var/log/messages | grep ESTABLISHED' 'state' 'ipv6)
                if [[ -n $lcreturn ]]; then
                   echo " "$lcreturn" "
                   exit_pass
                else
                   exit_fail "missing log in messages file"
                fi
                   ;;
              62)
                if [[ $PPROFILE = lspp ]] ; then
                   expect -c'
                     spawn run_init service ip6tables restart
                     expect "Password:"
                     sleep 1
                     send "$env(PASSWD)\r"
                     wait
                     close'
                else
                  service ip6tables restart
                fi
                exit_pass
                   ;;
              *)
                exit_pass
                ;;
        esac

#        exit_pass
    )
    status=$?

    # display the audit log items
    if [[ $status != 0 ]]; then
        echo
        echo augrok output
        echo -------------
        augrok --seek=$log_mark type!=DAEMON_ROTATE
    fi

    return $status
}

######################################################################
# pre-testrun checks/configuration
######################################################################

unset local_if

# check the test profile
[[ -z "$PPROFILE" ]] && die "error: profile not set (PPROFILE)"

# the remote labeled networking host/server
[[ -z "$LBLNET_SVR_IPV4" ]] && \
    die "error: labeled networking test server not specified (LBLNET_SVR_IPV4)"
[[ -z "$LBLNET_SVR_IPV6" ]] && \
    die "error: labeled networking test server not specified (LBLNET_SVR_IPV6)"

# interface/scope
local_if="$LOCAL_DEV"

# the local machine
lblnet_loc4_host="$LOCAL_IPV4"
lblnet_loc6_host="$LOCAL_IPV6"

# the remote machine
lblnet_svr4_host="$LBLNET_SVR_IPV4"
lblnet_svr6_host="$LBLNET_SVR_IPV6"

case $PPROFILE in
    lspp)
	tstsvr_lock_timeout=$tstsvr_lock_timeout_lspp
	;;
    capp)
        tstsvr_lock_timeout=$tstsvr_lock_timeout_capp
        ;;
    *)
        die "error: unknown test profile ($PPROFILE)"
	;;
esac

# wait until remote is available
while ! verify_remote; do
    echo "notice: test server is busy, sleeping for 60s ..."
    sleep 60
done

######################################################################
# test configuration
######################################################################

# It is important to note that prior to running any of the test below the
# system must be configured using the configuration templates in the
# "network/system" directory as directed by the test plan.  Failure to
# configure the system correctly will result in test failures.

##
## NET syscalls
##

# The test cases below are in the following format, with optional elements
# denoted by square brackets ([...]):
#
#  + <_syscall_> \
#    mlsop=<_mlsop_> expres=<_expres_> err=<_err_> \
#    host=<_host_> type=<_type_> op=<_op_> ipv=<_ipv_> port=<_port_> \
#    tnum=<integer> <_test_args_>
#
# Where the arguments are defined as follows:
#
#  _syscall_     : the syscall, not being tested for iptables/ip6tables but the
#                  auditing feature provides extra debug info so it has been
#                  left in
#  _mlsop_       : the MLS label comparison operator for more information see
#                  the comments elsewhere in this file, only 1 value is used
#                  for iptables/ip6tables testing.
#                  value:
#                    eq     : the local test process label equals the remote
#                             process/packet/connection's label
#  _expres_      : indicates that the operation should succeed (success) or
#                  fail (fail) based on the system's security policy
#  _err_         : if the test should fail, it should fail with this error
#                  code/value
#  _host_        : indicates if the test is against a local (local) or
#                  remote (remote) host, the actual remote IP address is
#                  determined from the LBLNET_SVR_IPV4 and LBLNET_SVR_IPV6
#                  environment variables
#  _type_        : the labeling protocol, kept for purposes of compatibility
#                    with the lblnet_tst_server. Only 1 type used:
#                    unlabeled : not a labeling protocol
#  _op_          : the remote test driver command, there are five valid values:
#                    sendrand_tcp : initiate a TCP connection with the test
#                                   machine and send data
#                    sendrand_udp : send UDP traffic to the test machine
#                    recv_tcp     : accept TCP connections from the test
#                                   machine and receive data from established
#                                   connections
#                    recv_udp     : receive UDP traffic from the test machine
#  _ipv_         : the IP version, there are two values: ipv4 and ipv6
#  _port_        : the TCP or UDP port
#  _tnum_        : The tnum identifies the filter setup required for the test
#  _test_args_   : arguments to supply to the test applet/program, these may
#                  be variables which are later expanded inside the run_test()
#                  function


##
## These following test casess test the filtering ability of iptables and
## ip6tables. Not all of the options available are tested, however some of
## commonly used ones are. These tests cases build upon the functions
## provided in the utils/bin directory. These functions provide standard
## networking operations such as obtaining sockets, sending connection
## requests, doing listens and accepts or simply sending datagrams.
## These test case rely on the lblnet_tst_server which resides in the
## utils/network-server directory. There is a README file associated with
## the netfilter tests that explains the configuration required. The
## configuration relies heavily on a profile file that must be sourced
## prior to running these tests. A run.log file is produced and can be
## used to verify test results. The tests are run in the order that
## they appear in below. The tnum value seen in   ssed test values below
## start with the number 1 while the actual number of the test cases as
## used for a parameter to the run.bash script starts with a 0. The tnum is
## is not relative to the test numbering as it cannot be used as an argument
## for running individual test cases in run.bash, but it is associated with the
## function being tested
##
## TESTCASE Test #0 tnum 1
##  Table Rule        No blocking
##  Input             tcp connection request (ipv4) sent to port $tst_port1
##                    over local looback device
##  Expected Result   Connection succeeds.
+ connect \
    mlsop=eq expres=success \
    host=local type=unlabeled op=recv_tcp ipv=ipv4 port=$tst_port1 \
    tnum=1 '$host_remote tcp $port'
## TESTCASE Test #1 tnum 2
##  Table Rule        IPv4 packets received on local loopback device are
##                    dropped and record is sent to audit log
##  Input             tcp connection request (ipv4) sent to port $tst_port1
##                    over local loopback device.
##  Expected Result   Connection fails, audit log has record
+ connect \
    mlsop=eq expres=fail err=ETIMEDOUT \
    host=local type=unlabeled op=recv_tcp ipv=ipv4 port=$tst_port1 \
    tnum=2 '$host_remote tcp $port'
## TESTCASE Test #2 tnum 3
##  Table Rule        no blocking
##  Input             tcp connection request (ipv6) sent to port $tst_port1
##                    over local loopback device.
##  Expected Result   Connection succeeds.
+ connect \
    mlsop=eq expres=success \
    host=local type=unlabeled op=recv_tcp ipv=ipv6 port=$tst_port1 \
    tnum=3 '$host_remote tcp $port'
## TESTCASE Test #3 tnum 4
##  Table Rule        IPv6 packets received on local loopback device are
##                    dropped and record is sent to audit log
##  Input             tcp connection request (ipv6) sent to port $tst_port1
##                    over local loopback device.
##  Expected Result   Connection fails, audit log has record
+ connect \
    mlsop=eq expres=fail err=ETIMEDOUT \
    host=local type=unlabeled op=recv_tcp ipv=ipv6 port=$tst_port1 \
    tnum=4 '$host_remote tcp $port'
## TESTCASE Test #4 tnum 5
##  Table Rule        no blocking
##  Input             tcp connection request (ipv4) sent to port $tst_port1
##                    over local loopback device.
##  Expected Result   Connection succeeds.
+ connect \
    mlsop=eq expres=success \
    host=local type=unlabeled op=recv_tcp ipv=ipv4 port=$tst_port1 \
    tnum=5 '$host_remote tcp $port'
## TESTCASE Test #5 tnum 6
##  Table Rule        tcp traffic (ipv4) received from source port $tst_port1
##                    are rejected.
##  Input             tcp connection request (ipv4) sent to port $tst_port1
##                    over local loopback device.
##  Expected Result   Connection is rejected, audit log has record
+ connect \
    mlsop=eq expres=fail err=ETIMEDOUT \
    host=local type=unlabeled op=recv_tcp ipv=ipv4 port=$tst_port1 \
    tnum=6 '$host_remote tcp $port'
## TESTCASE Test #6 tnum 7
##  Table Rule        no blocking
##  Input             tcp connection request (ipv6) sent to port $tst_port1
##                    over local loopback device.
##  Expected Result   Connection succeeds
+ connect \
    mlsop=eq expres=success \
    host=local type=unlabeled op=recv_tcp ipv=ipv6 port=$tst_port1 \
    tnum=7 '$host_remote tcp $port'
## TESTCASE Test #7 tnum 8
##  Table Rule        tcp (ipv6) packets with source port $tst_port1 are
##                    rejected
##                    on transmission (OUTPUT chain)
##  Input             tcp connection request (ipv6) sent to port $tst_port1
##                    over local loopback device.
##  Expected Result   Connection request responses are rejected, connection
##                    fails, audit log has record.
+ connect \
    mlsop=eq expres=fail err=ETIMEDOUT \
    host=local type=unlabeled op=recv_tcp ipv=ipv6 port=$tst_port1 \
    tnum=8 '$host_remote tcp $port'
## TESTCASE Test #8 tnum 9
##  Table Rule        no blocking
##  Input             tcp connection request (ipv4) sent to port $tst_port1
##                    from netserver on primary network
##  Expected Result   Connection succeeds.
+ accept \
    mlsop=eq expres=success \
    host=remote type=unlabeled op=sendrand_tcp ipv=ipv4 port=$tst_port1 \
    tnum=9 '$ipv $port'
## TESTCASE Test #9 tnum 10
##  Table Rule        Packets sent to tcp port (ipv4) $tst_port1 are rejected
##  Input             tcp connection request sent (ipv4) from netserver to port
##                    $tst_port1 of TOE over primary network
##  Expected Result   Connection rejected, listen times out, audit log has
##                    record
+ accept \
    mlsop=eq expres=fail err=EINTR \
    host=remote type=unlabeled op=sendrand_tcp ipv=ipv4 port=$tst_port1 \
    tnum=10 '$ipv $port'
## TESTCASE Test #10 tnum 11
##  Table Rule        no blocking
##  Input             tcp connection request sent (ipv6) from netserver to port
##                    $tst_port1 of TOE over primary network
##  Expected Result   Connection succeeds
+ accept \
    mlsop=eq expres=success \
    host=remote type=unlabeled op=sendrand_tcp ipv=ipv6 port=$tst_port1 \
    tnum=11 '$ipv $port'
## TESTCASE Test #11 tnum 12
##  Table Rule        Packets sent to tcp port (ipv6) $tst_port1 are rejected
##  Input             tcp connection request sent (ipv4) from netserver to port
##                    $tst_port1 of TOE over primary network
##  Expected Result   Connection rejected, listen times out, audit log has
##                    record.
+ accept \
    mlsop=eq expres=fail err=EINTR \
    host=remote type=unlabeled op=sendrand_tcp ipv=ipv6 port=$tst_port1 \
    tnum=12 '$ipv $port'
## TESTCASE Test #12 tnum 13
##  Table Rule        no blocking
##  Input             udp packets (ipv4) sent over local loopback device
##                    with source port in $srcrange range.
##  Expected Result   packets pass through.
+ sendto \
    mlsop=eq expres=success \
    host=local type=unlabeled op=recv_udp ipv=ipv4 port=$tst_port1 \
    tnum=13 '$host_remote $port'
## TESTCASE Test #13 tnum 14
##  Table Rule        udp packets (ipv4) with source port range $srcrange are
##                    dropped on transmission (OUTPUT chain)
##  Input             udp packets (ipv4) sent over local loopback device
##                    with source port in $srcrange range.
##  Expected Result   udp packets are dropped, audit log has record.
+ sendto \
    mlsop=eq expres=fail err=EPERM \
    host=local type=unlabeled op=recv_udp ipv=ipv4 port=$tst_port1 \
    tnum=14 '$host_remote $port'
## TESTCASE Test #14 tnum 15
##  Table Rule        no blocking
##  Input             udp packets (ipv6) sent over local loopback device
##                    with source port in $srcrange range.
##  Expected Result   packets pass through.
+ sendto \
    mlsop=eq expres=success \
    host=local type=unlabeled op=recv_udp ipv=ipv6 port=$tst_port1 \
    tnum=15 '$host_remote $port'
## TESTCASE Test #15 tnum 16
##  No Table Rule     udp packets (ipv6) with source port range $srcrange are
##                    dropped on transmission (OUTPUT chain)
##  Input             udp packets (ipv6) sent over local loopback device
##                    with source port in $srcrange range.
##  Expected Result   udp packets are dropped, audit log has record.
+ sendto \
    mlsop=eq expres=fail err=EPERM \
    host=local type=unlabeled op=recv_udp ipv=ipv6 port=$tst_port1 \
    tnum=16 '$host_remote $port'
## TESTCASE Test #16 tnum 17
##  Table Rule        no blocking
##  Input             udp packets (ipv4) sent over local loopback device
##                    to destination port $tst_port1.
##  Expected Result   Packets pass through.
+ sendto \
    mlsop=eq expres=success \
    host=local type=unlabeled op=recv_udp ipv=ipv4 port=$tst_port1 \
    tnum=17 '$host_remote $port'
## TESTCASE Test #17 tnum 18
##  Table Rule        udp packets (ipv4) to destination port $tst_port1 are
##                    rejected
##  Input             udp packets (ipv4) sent over local loopback device
##                    to destination port $tst_port1.
##  Expected Result   Packets are rejected, audit log has record.
+ sendto \
    mlsop=eq expres=fail err=EPERM \
    host=local type=unlabeled op=recv_udp ipv=ipv4 port=$tst_port1 \
    tnum=18 '$host_remote $port'
## TESTCASE Test #18 tnum 19
##  Table Rule        no blocking
##  Input             udp packets (ipv6) sent over local loopback device
##                    to destination port $tst_port1.
##  Expected Result   Packets pass through.
+ sendto \
    mlsop=eq expres=success \
    host=local type=unlabeled op=recv_udp ipv=ipv6 port=$tst_port1 \
    tnum=19 '$host_remote $port'
## TESTCASE Test #19 tnum 20
##  Table Rule        udp packets (ipv6) to destination port $tst_port1 are
##                    rejected
##  Input             udp packets (ipv4) sent over local loopback device
##                    to destination port $tst_port1.
##  Expected Result   Packets are rejected, audit log has record.
+ sendto \
    mlsop=eq expres=fail err=EPERM \
    host=local type=unlabeled op=recv_udp ipv=ipv6 port=$tst_port1 \
    tnum=20 '$host_remote $port'
## TESTCASE Test #20 tnum 21
##  Table Rule        no blocking
##  Input             tcp connection request (ipv4) sent over local loopback
##                    device to port $tst_port1
##  Expected Result   Connection succeeds.
+ connect \
    mlsop=eq expres=success \
    host=local type=unlabeled op=recv_tcp ipv=ipv4 port=$tst_port1 \
    tnum=21 '$host_remote tcp $port'
## TESTCASE Test #21 tnum 22
##  Table Rule        Packets (ipv4) sent to local loopback destination address
##                    are dropped
##  Input             tcp connection request (ipv4) sent over local loopback
##                    device to port $tst_port1
##  Expected Result   Connection fails, packets dropped, audit log has record
+ connect \
    mlsop=eq expres=fail err=ETIMEDOUT \
    host=local type=unlabeled op=recv_tcp ipv=ipv4 port=$tst_port1 \
    tnum=22 '$host_remote tcp $port'
## TESTCASE Test #22 tnum 23
##  Table Rule        no blocking
##  Input             tcp connection request (ipv6) sent over local loopback
##                    device to port $tst_port1
##  Expected Result   Connection succeeds.
+ connect \
    mlsop=eq expres=success \
    host=local type=unlabeled op=recv_tcp ipv=ipv6 port=$tst_port1 \
    tnum=23 '$host_remote tcp $port'
## TESTCASE Test #23 tnum 24
##  Table Rule        Packets (ipv6) sent to local loopback destination address
##                    are dropped
##  Input             tcp connection request (ipv6) sent over local loopback
##                    device to port $tst_port1
##  Expected Result   Connection fails, packets dropped, audit log has record
+ connect \
    mlsop=eq expres=fail err=ETIMEDOUT \
    host=local type=unlabeled op=recv_tcp ipv=ipv6 port=$tst_port1 \
    tnum=24 '$host_remote tcp $port'
## TESTCASE Test #24 tnum 25
##  Table Rule        no blocking
##  Input             tcp connection request (ipv4) sent over local loopback
##                    device to port $tst_port1
##  Expected Result   Connection succeeds
+ connect \
    mlsop=eq expres=success \
    host=local type=unlabeled op=recv_tcp ipv=ipv4 port=$tst_port1 \
    tnum=25 '$host_remote tcp $port'
## TESTCASE Test #25 tnum 26
##  Table Rule        Packets sent (ipv4) with local loopback source address
##                    are rejected. (OUTPUT chain)
##  Input             tcp connection request (ipv4) sent over local loopback
##                    device to port $tst_port1
##  Expected Result   Connection rejected, audit log has record.
+ connect \
    mlsop=eq expres=fail err=ETIMEDOUT \
    host=local type=unlabeled op=recv_tcp ipv=ipv4 port=$tst_port1 \
    tnum=26 '$host_remote tcp $port'
## TESTCASE Test #26 tnum 27
##  Table Rule        no blocking
##  Input             tcp connection request (ipv6) sent over local loopback
##                    device to port $tst_port1
##  Expected Result   Connection succeeds.
+ connect \
    mlsop=eq expres=success \
    host=local type=unlabeled op=recv_tcp ipv=ipv6 port=$tst_port1 \
    tnum=27 '$host_remote tcp $port'
## TESTCASE Test #27 tnum 28
##  Table Rule        Packets sent (ipv6) with local loopback source address
##                    are rejected. (OUTPUT chain)
##  Input             tcp connection request (ipv6) sent over local loopback
##                    device to port $tst_port1
##  Expected Result   Connection rejected, audit log has record.
+ connect \
    mlsop=eq expres=fail err=ETIMEDOUT \
    host=local type=unlabeled op=recv_tcp ipv=ipv6 port=$tst_port1 \
    tnum=28 '$host_remote tcp $port'
## TESTCASE Test #28 tnum 29
##  Table Rule        received ping requests (ipv4/icmp) are dropped
##  Input             pings (ipv4/icmp) are sent over local loopback
##                    device.
##  Expected Result   pings are dropped, audit log has record
+ ping \
    mlsop=eq expres=fail err=EPERM \
    host=local type=unlabeled ipv=ipv4 \
    tnum=29 '$host_remote $ipv $host $local_if'
## TESTCASE Test #29 tnum 30
##  Table Rule        received ping requests (ipv4/icmp) are accepted
##                    and logged to audit.
##  Input             pings (ipv4/icmp) are sent over local loopback
##                    device.
##  Expected Result   pings are responded to, audit log has record
+ ping \
    mlsop=eq expres=success \
    host=local type=unlabeled ipv=ipv4 \
    tnum=30 '$host_remote $ipv $host $local_if'
## TESTCASE Test #30 tnum 31
##  Table Rule        received ping requests (ipv6/icmp) are dropped
##  Input             pings (ipv6/icmp) are sent over local loopback
##                    device.
##  Expected Result   pings are dropped, audit log has record
+ ping \
    mlsop=eq expres=fail err=EPERM \
    host=local type=unlabeled ipv=ipv6 \
    tnum=31 '$host_remote $ipv $host $local_if'
## TESTCASE Test #31 tnum 32
##  Table Rule        received ping requests (ipv6/icmp) are accepted
##                    and logged to audit.
##  Input             pings (ipv6/icmp) are sent over local loopback
##                    device.
##  Expected Result   pings are responded to, audit log has record
+ ping \
    mlsop=eq expres=success \
    host=local type=unlabeled ipv=ipv6 \
    tnum=32 '$host_remote $ipv $host $local_if'
## TESTCASE Test #32 tnum 33
##  Table Rule        INPUT chain policy (ipv4) is drop. Packets on ports 22,
##                    4000, and $tst_port2 are accepted. Destination port range
##                    $srcrange is accepted (needed because in loopback)
##  Input             tcp connection request (ipv4) is sent over local
##                    loopback device to port $tst_port1
##  Expected Result   Connection fails, packets dropped, no audit record
##                    because packets dropped due to policy not rule
+ connect \
    mlsop=eq expres=fail err=ETIMEDOUT\
    host=local type=unlabeled op=recv_tcp ipv=ipv4 port=$tst_port1 \
    tnum=33 '$host_remote tcp $port'
## TESTCASE Test #33 tnum 34
##  Table Rule        INPUT chain policy (ipv4) is drop. Packets on ports 22,
##                    4000, and $tst_port2 are accepted. Destination port range
##                    $srcrange is accepted (needed because in loopback)
##  Input             tcp connection request (ipv4) is sent over local
##                    loopback device to port $tst_port2
##  Expected Result   Connection succeeds, audit log has record.
+ connect \
    mlsop=eq expres=success \
    host=local type=unlabeled op=recv_tcp ipv=ipv4 port=$tst_port2 \
    tnum=34 '$host_remote tcp $port'
## TESTCASE Test #34 tnum 35
##  Table Rule        INPUT chain policy (ipv6) is drop. Packets on ports 22,
##                    4000, and $tst_port2 are accepted. Destination port range
##                    $srcrange is accepted (needed because in loopback)
##  Input             tcp connection request (ipv6) is sent over local
##                    loopback device to port $tst_port1
##  Expected Result   Connection fails, packets dropped, no audit record
##                    packets dropped because of policy not rule
+ connect \
    mlsop=eq expres=fail err=ETIMEDOUT \
    host=local type=unlabeled op=recv_tcp ipv=ipv6 port=$tst_port1 \
    tnum=35 '$host_remote tcp $port'
## TESTCASE Test #35 tnum 36
##  Table Rule        INPUT chain policy (ipv6) is drop. Packets on ports 22,
##                    4000, and $tst_port2 are accepted. Destination port range
##                    $srcrange is accepted (needed because in loopback)
##  Input             tcp connection request (ipv6) is sent over local
##                    loopback device to port $tst_port2
##  Expected Result   Connection succeeds, audit log has record.
+ connect \
    mlsop=eq expres=success \
    host=local type=unlabeled op=recv_tcp ipv=ipv6 port=$tst_port2 \
    tnum=36 '$host_remote tcp $port'
## TESTCASE Test #36 tnum 37
##  Table Rule        no blocking
##  Input             tcp connection request (ipv4) is sent over local
##                    loopback device to port $tst_port1
##  Expected Result   Connection succeeds.
+ connect \
    mlsop=eq expres=success \
    host=local type=unlabeled op=recv_tcp ipv=ipv4 port=$tst_port1 \
    tnum=37 '$host_remote tcp $port'
## TESTCASE Test #37 tnum 38
##  Table Rule        received tcp segments (ipv4) with SYN flag set
##                    are rejected
##  Input             tcp connection request (ipv4) is sent over local
##                    loopback device to port $tst_port1
##  Expected Result   Connection is rejected, audit log has record.
+ connect \
    mlsop=eq expres=fail err=ECONNREFUSED \
    host=local type=unlabeled op=recv_tcp ipv=ipv4 port=$tst_port1 \
    tnum=38 '$host_remote tcp $port'
## TESTCASE Test #38 tnum 39
##  Table Rule        no blocking
##  Input             tcp connection request (ipv6) is sent over local
##                    loopback device to port $tst_port1
##  Expected Result   Connection succeeds.
+ connect \
    mlsop=eq expres=success \
    host=local type=unlabeled op=recv_tcp ipv=ipv6 port=$tst_port1 \
    tnum=39 '$host_remote tcp $port'
## TESTCASE Test #39 tnum 40
##  Table Rule        received tcp segments (ipv6) with SYN flag set
##                    are rejected
##  Input             tcp connection request (ipv6) is sent over local
##                    loopback device to port $tst_port1
##  Expected Result   Connection is rejected, audit log has record.
+ connect \
    mlsop=eq expres=fail err=ECONNREFUSED \
    host=local type=unlabeled op=recv_tcp ipv=ipv6 port=$tst_port1 \
    tnum=40 '$host_remote tcp $port'
## TESTCASE Test #40 tnum 41
##  Table Rule        no blocking
##  Input             tcp connection request (ipv4) is sent over local
##                    loopback device to port $tst_port1
##  Expected Result   Connection succeeds.
+ connect \
    mlsop=eq expres=success \
    host=local type=unlabeled op=recv_tcp ipv=ipv4 port=$tst_port1 \
    tnum=41 '$host_remote tcp $port'
## TESTCASE Test #41 tnum 42
##  Table Rule        received tcp segments (ipv4) to destination port
##                    $tst_port1 with ACK flag set are accepted and logged to
##                    /var/log/messages with "ack received ipv4" log prefix
##                    and recorded in audit.log
##  Input             tcp connection request (ipv4) is sent over local
##                    loopback device to port $tst_port1
##  Expected Result   Connection succeeds, messages file has log, audit.log
##                    has record.
+ connect \
    mlsop=eq expres=success \
    host=local type=unlabeled op=recv_tcp ipv=ipv4 port=$tst_port1 \
    tnum=42 '$host_remote tcp $port'
## TESTCASE Test #42 tnum 43
##  Table Rule        no blocking
##  Input             tcp connection request (ipv6) is sent over local
##                    loopback device to port $tst_port1
##  Expected Result   Connection succeeds.
+ connect \
    mlsop=eq expres=success \
    host=local type=unlabeled op=recv_tcp ipv=ipv6 port=$tst_port1 \
    tnum=43 '$host_remote tcp $port'
## TESTCASE Test #43 tnum 44
##  Table Rule        received tcp segments (ipv6) to destination port
##                    $tst_port1 with ACK flag set are accepted and logged to
##                    /var/log/messages with "ack received ipv6" log prefix
##                    and recorded in audit.log
##  Input             tcp connection request (ipv6) is sent over local
##                    loopback device to port $tst_port1
##  Expected Result   Connection succeeds, messages file has log, audit.log
##                    has record.
+ connect \
    mlsop=eq expres=success \
    host=local type=unlabeled op=recv_tcp ipv=ipv6 port=$tst_port1 \
    tnum=44 '$host_remote tcp $port'
## TESTCASE Test #44 tnum 45
##  Table Rule        received tcp segments (ipv6) from dst port $tst_port1
##                    with RST flag set are accepted and logged to
##                    /var/log/messages with "rst received ipv6" log prefix
##                    and recorded in audit.log
##  Input             tcp connection request (ipv6) is sent over local
##                    loopback device to port $tst_port1
##  Expected Result   segments pass through, messages file has log, audit.log
##                    has record.
+ connect \
    mlsop=eq expres=success \
    host=local type=unlabeled ipv=ipv6 port=$tst_port1 \
    tnum=45 '$host_remote tcp $port'
## TESTCASE Test #45 tnum 46
##  Table Rule        received tcp segments (ipv4) from dst port $tst_port1
##                    with RST flag set are accepted and logged to
##                    /var/log/messages with "rst received ipv4" log prefix
##                    and recorded in audit.log
##  Input             tcp connection request (ipv4) is sent over local
##                    loopback device to port $tst_port1
##  Expected Result   segments pass through, messages file has log, audit.log
##                    has record.
+ connect \
    mlsop=eq expres=success \
    host=local type=unlabeled ipv=ipv4 port=$tst_port1 \
    tnum=46 '$host_remote tcp $port'
## TESTCASE Test #46 tnum 47
##  Table Rule        received tcp segments (ipv4) to destination port
##                    $tst_port1 with PSH flag set are accepted and logged to
##                    /var/log/messages with "push received ipv4" log prefix
##                    and recorded in audit.log
##  Input             nc listen is started on TOE on $tst_port1 and nc
##                    connection is started to $tst_port1, data string is sent
##                    this should generate segment with an PSH flag.
##  Expected Result   segments pass through, messages file has log, audit.log
##                    has record
+ connect \
    mlsop=eq expres=success \
    host=local type=unlabeled op=recv_tcp ipv=ipv4 port=$tst_port1 \
    tnum=47 '$host_remote tcp $port'
## TESTCASE Test #47 tnum 48
##  Table Rule        received tcp segments (ipv6) to destination port
##                    $tst_port1 with PSH flag set are accepted and logged to
##                    /var/log/messages with "push received ipv6" log prefix
##                    and recorded in audit.log
##  Input             nc listen (forced ipv6)is started on TOE on $port and nc
##                    connection (forced ipv6) is started to $tst_port1, data
##                    string is sent this should generate segment with a
##                    PSH flag
##  Expected Result   segments pass through, messages file has log, audit.log
##                    has record
+ connect \
    mlsop=eq expres=success \
    host=local type=unlabeled op=recv_tcp ipv=ipv6 port=$tst_port1 \
    tnum=48 '$host_remote tcp $port'
## TESTCASE Test #48 tnum 49
##  Table Rule        received tcp segments (ipv4) from source port $tst_port1
##                    with FIN flag set are accepted and logged to
##                    /var/log/messages with "fin received ipv4" log prefix
##                    and recorded in audit.log
##  Input             tcp connect request is sent over local loopback device
##                    to local lblnet_tst_server.
##  Expected Result   Connection succeeds, messages file has log, audit.log
##                    has record
+ connect \
    mlsop=eq expres=success \
    host=local type=unlabeled op=recv_tcp ipv=ipv4 port=$tst_port1 \
    tnum=49 '$host_remote tcp $port'
## TESTCASE Test #49 tnum 50
##  Table Rule        received tcp segments (ipv6) from source port $tst_port1
##                    with FIN flag set are accepted and logged to
##                    /var/log/messages with "fin received ipv6" log prefix
##                    and recorded in audit.log
##  Input             tcp connect request is sent over local loopback device
##                    to local lblnet_tst_server.
##  Expected Result   Connection succeeds, messages file has log, audit.log
##                    has record
+ connect \
    mlsop=eq expres=success \
    host=local type=unlabeled op=recv_tcp ipv=ipv6 port=$tst_port1 \
    tnum=50 '$host_remote tcp $port'
## TESTCASE Test #50 tnum 51
##  Table Rule        received tcp segments (ipv4) to destination port
##                    $tst_port1 with URG flag set are accepted and logged to
##                    /var/log/messages with "urgent received ipv4" log prefix
##                    and recorded in audit.log
##  Input             tcp connection (ipv4) is established and data sent
##                    flag th MSG_OOB set.
##  Expected Result   Connection succeeds, messages file has log, audit.log
##                    has record
+ send \
    mlsop=eq expres=success \
    host=local type=unlabeled op=recv_tcp ipv=ipv4 port=$tst_port1 \
    tnum=51 '$host_remote tcp $port $tnum'
## TESTCASE Test #51 tnum 52
##  Table Rule        received tcp segments (ipv6) to destination port
##                    $tst_port1 with URG flag set are accepted and logged to
##                    /var/log/messages with "urgent received ipv6" log prefix
##                    and recorded in audit.log
##  Input             tcp connection (ipv4) is established and data sent
##                    flag th MSG_OOB set.
##  Expected Result   Connection succeeds, messages file has log, audit.log
##                    has record
+ send \
    mlsop=eq expres=success \
    host=local type=unlabeled op=recv_tcp ipv=ipv6 port=$tst_port1 \
    tnum=52 '$host_remote tcp $port $tnum'
## TESTCASE Test #52 tnum 53
##  Table Rule        tcp segments (ipv4) received on port $tst_port1  that
##                    start a new connection are accepted, log with prefix
##                    "NEW state ipv4" is written in /var/log/messages, and
##                    acceptance is recorded in audit.log
##  Input             tcp connect request (ipv4) is sent over local loopback
##                    device
##  Expected Result   Connection succeeds, messages file has log, audit.log
##                    has record
+ connect \
    mlsop=eq expres=success \
    host=local type=unlabeled op=recv_tcp ipv=ipv4 port=$tst_port1 \
    tnum=53 '$host_remote tcp $port'
## TESTCASE Test #53 tnum 54
##  Table Rule        tcp segments (ipv4) starting a new connection to port
##                    $tst_port1, but related to an existing connection are
##                    rejected, log with RELATED state ipv4" is written to
##                    /var/log/messages and rejection is recorded in audit.log
##  Input             connection request (ipv4) is sent over local loopback
##                    device, second related request follows.
##  Expected Result   Connection fails, second request rejected, messages
##                    file has log, audit.log has record
+ connect \
    mlsop=eq expres=fail err=ECONNREFUSED \
    host=local type=unlabeled op=recv_tcp ipv=ipv4 port=$tst_port1 \
    tnum=54 '$host_remote tcp $port'
## TESTCASE Test #54 tnum 55
##  Table Rule        tcp segments (ipv6) received on port $tst_port1
##                    that start a new connection are accepted, log with
##                    prefix "NEW state ipv6" is written in /var/log/messages,
##                    and acceptance is recorded in audit.log
##  Input             tcp connect request (ipv6) is sent over local loopback
##                    device
##  Expected Result   Connection succeeds, messages file has log, audit.log
##                    has record
+ connect \
    mlsop=eq expres=success \
    host=local type=unlabeled op=recv_tcp ipv=ipv6 port=$tst_port1 \
    tnum=55 '$host_remote tcp $port'
## TESTCASE Test #55 tnum 56
##  Table Rule        tcp segments (ipv6) starting a new connection to port
##                    $tst_port1 but related to an existing connection are
##                    rejected, log with prefix "RELATED state ipv6" is
##                    written to /var/log/messages, and rejection is
##                    recorded in audit.log
##  Input             connection request (ipv6) is sent over local loopback
##                    device to $tst_port1, second related request follows.
##  Expected Result   Connection fails, second request rejected, messages
##                    file has log, audit.log has record
+ connect \
    mlsop=eq expres=fail err=ECONNREFUSED \
    host=local type=unlabeled op=recv_tcp ipv=ipv6 port=$tst_port1 \
    tnum=56 '$host_remote tcp $port'
## TESTCASE Test #56 tnum 57
##  Table Rule        tcp segments (ipv4) sent over existing connection to
##                    port $tst_port1 are accepted, log with prefix
##                    "ESTABLISHED state ipv4" is written to /var/log/messages
##                    and acceptance is recorded in audit.log
##  Input             tcp connect request (ipv4) is sent over local loopack
##                    device to $tst_port1, other packets follow.
##  Expected Result   Connection succeeds, messages file has log, audit.log
##                    has record
+ connect \
    mlsop=eq expres=success \
    host=local type=unlabeled op=recv_tcp ipv=ipv4 port=$tst_port1 \
    tnum=57 '$host_remote tcp $port'
## TESTCASE Test #57 tnum 58
##  Table Rule        tcp segments (ipv6) sent over existing connection to
##                    port $tst_port1 are accepted, log with prefix
##                    "ESTABLISHED state ipv6" is written to /var/log/messages
##                    and acceptance is recorded in audit.log
##  Input             tcp connect request (ipv6) is sent over local loopack
##                    device to port $tst_port1, other packets follow.
##  Expected Result   Connection succeeds, messages file has log, audit.log
##                    has record
+ connect \
    mlsop=eq expres=success \
    host=local type=unlabeled op=recv_tcp ipv=ipv6 port=$tst_port1 \
    tnum=58 '$host_remote tcp $port'
## TESTCASE Test #58 tnum 59
##  Table Rule        no blocking
##  Input             tcp connect request (ipv4) sent from remote
##                    lblnet_tst_server to TOE port $tst_port1 over primary
##                    device.
##  Expected Result   connection succeeds.
+ accept \
    mlsop=eq expres=success \
    host=remote type=unlabeled op=sendrand_tcp ipv=ipv4 port=$tst_port1 \
    tnum=59 '$ipv $port'
## TESTCASE Test #59 tnum 60
##  Table Rule        Drop received packets (ipv4) on primary device.
##  Input             tcp connect request (ipv4) sent from remote
##                    lblnet_tst_server to TOE port $tst_port1 over primary
##                    device.
##  Expected Result   connection fails, listen times out.
+ accept \
    mlsop=eq expres=fail err=EINTR \
    host=remote type=unlabeled op=sendrand_tcp ipv=ipv4 port=$tst_port1 \
    tnum=60 '$ipv $port'
## TESTCASE Test #60 tnum 61
##  Table Rule        no blocking
##  Input             tcp connect request (ipv6) sent from remote
##                    lblnet_tst_server to TOE port $tst_port1 over primary
##                    device.
##  Expected Result   Connection succeeds
+ accept \
    mlsop=eq expres=success \
    host=remote type=unlabeled op=sendrand_tcp ipv=ipv6 port=$tst_port1 \
    tnum=61 '$ipv $port'
## TESTCASE Test #61 tnum 62
##  Table Rule        Drop received packets (ipv6) on primary device.
##  Input             tcp connect request (ipv4) sent from remote
##                    lblnet_tst_server to TOE port $tst_port1 over primary
##                    device.
##  Expected Result   connection fails, listen times out.
+ accept \
    mlsop=eq expres=fail err=EINTR \
    host=remote type=unlabeled op=sendrand_tcp ipv=ipv6 port=$tst_port1 \
    tnum=62 '$ipv $port'
## TESTCASE Test #62 tnum 63
##  No Table Rule     This test insures a normal user does not have
##                    permision to modify the iptables
##  Input             testpermip4.bash script adds a regular user and then
##                    su to the user and attempts to add a ebtables rule
##  Expected Result   Permission is denied and rule is not added
+ testpermip4.bash
    mlsop=eq expres=success \
    host=local tnum=63
## TESTCASE Test #63 tnum 64
##  No Table Rule     This test insures a normal user does not have
##                    permision to modify the ip6tables
##  Input             testpermip6.bash script adds a regular user and then
##                    su to the user and attempts to add a ebtables rule
##  Expected Result   Permission is denied and rule is not added
+ testpermip6.bash
    mlsop=eq expres=success \
    host=local tnum=64
