#!/bin/bash
# =============================================================================
# (c) Copyright Hewlett-Packard Development Company, L.P., 2005, 2006, 2007
#
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of version 2 the GNU General Public License as
#   published by the Free Software Foundation.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
# =============================================================================

######################################################################
# global variables
######################################################################

tstsvr_lock_timeout_lspp=3000           # in seconds (50m)
tstsvr_lock_timeout_capp=120            # in seconds (2m)
tstsvr_lock_timeout=0
tstsvr_lock_held=0
tst_port1=4100				# port for unlabeled traffic
tst_port2=4200				# port for netlabel traffic
tst_port3=4300				# port for labeled ipsec traffic

cmd_nc=""                               # netcat command line

######################################################################
# helper functions
######################################################################

#
# get_test_domain - Get the SELinux domain for the test applet
#
# INPUT
# $1 : the labeling type
# $2 : the host type
#
# OUTPUT
# Writes the SELinux domain to stdout
#
# DESCRIPTION
# This function determines the correct SELinux domain to use for the test
# applet based on the given labeling type.
#
function get_test_domain {
    declare type_arg=$1 host_arg=$2

    case $PPROFILE-$host_arg in
	lspp-*|capp-remote)
            case $type_arg in
		netlabel)
		    echo "lspp_test_netlabel_t"
		    ;;
		ipsec)
		    echo "lspp_test_ipsec_t"
		    ;;
		unlabeled)
		    echo "lspp_test_generic_t"
		    ;;
		*)
		    exit_fail "invalid test argument"
	            ;;
	    esac
	    ;;
	capp-local)
	    case $type_arg in
	        *)
		    echo "unconfined_t"
		    ;;
	    esac
	    ;;
    esac
}

#
# get_label_subj - Get the subject's sensitivity label for the test run
#
# INPUT
# $1 : the MLS "op"
#
# OUPUT
# Writes the subject's untranslated sensivity label to stdout
#
# DESCRIPTION
# This function determines the subject's sensitivity label for the test run
# based on the MLS "op".  The MLS "op" specifies if the subject is to be equal
# to (eq), incomparable to (incomp), dominate (dom), or be dominated by (domby)
# the object.  These MLS "op" definitions assume the Bell-LaPadula based MLS
# constraints in use by the SELinux MLS policy derived from the SELinux
# Reference Policy.
#
function get_label_subj {
    declare mlsop_arg=$1

    case $PPROFILE in
	lspp)
            case $mlsop_arg in
		eq)
		    echo "SystemLow"
		    ;;
		dom)
		    echo "NetHigh"
		    ;;
		domby)
		    echo "NetS1"
		    ;;
		incomp)
		    echo "NetIncomp1"
		    ;;
		*)
		    exit_fail "invalid test argument"
		    ;;
	    esac
	    ;;
	capp)
            case $mlsop_arg in
		*)
		    # in targeted policy (the likely policy for CAPP) the s0
		    # sensitivity label is translated into a NULL string so we
		    # have to use the untranslated sensitivity label
		    echo "s0"
		    ;;
	    esac
	    ;;
    esac
}

#
# get_label_obj - Get the object's sensitivity label for the test run
#
# INPUT
# $1 : the MLS "op"
#
# OUPUT
# Writes the object's untranslated sensivity label to stdout
#
# DESCRIPTION
# This function determines the objects's sensitivity label for the test run
# based on the MLS "op".  The MLS "op" specifies if the subject is to be equal
# to (eq), incomparable to (incomp), dominate (dom), or be dominated by (domby)
# the object.  These MLS "op" definitions assume the Bell-LaPadula based MLS
# constraints in use by the SELinux MLS policy derived from the SELinux
# Reference Policy.
#
function get_label_obj {
    declare mlsop_arg=$1

    case $PPROFILE in
	lspp)
            case $mlsop_arg in
		eq)
		    echo "SystemLow"
		    ;;
		dom)
		    echo "NetS1"
		    ;;
		domby)
		    echo "NetHigh"
		    ;;
		incomp)
		    echo "NetIncomp2"
		    ;;
		*)
		    exit_fail "invalid test argument"
		    ;;
	    esac
	    ;;
	capp)
            case $mlsop_arg in
		*)
		    # in targeted policy (the likely policy for CAPP) the s0
		    # sensitivity label is translated into a NULL string so we
		    # have to use the untranslated sensitivity label
		    echo "s0"
		    ;;
	    esac
	    ;;
    esac
}

#
# get_host_local - Get the IP address to use as the local address for the test
#
# INPUT
# $1 : the IP version
# $2 : the host type
#
# OUTPUT
# Writes the IP address to stdout
#
# DESCRIPTION
# This function determines the correct local address to use for the test run
# based on an IP version string, "ipv4" or "ipv6", and the host type, "local"
# or "remote".  While the "local" host types resolve to the IPv4 or IPv6
# localhost address the "remote" host types resolve to IP addresses specified
# in environment variables which are queried at the start of the test run.
#
function get_host_local {
    declare ipv_arg=$1 host_arg=$2

    case $ipv_arg in
	ipv4)
	    case $host_arg in
		local)
		    echo "127.0.0.1"
		    ;;
		remote)
		    echo "$lblnet_loc4_host"
		    ;;
		*)
		    exit_fail "invalid test argument"
		    ;;
	    esac
	    ;;
	ipv6)
	    case $host_arg in
		local)
		    echo "::1"
		    ;;
		remote)
		    echo "$lblnet_loc6_host"
		    ;;
		*)
		    exit_fail "invalid test argument"
		    ;;
	    esac
	    ;;
	*)
	    exit_fail "invalid test argument"
	    ;;
	esac
}

#
# get_host_remote - Get the IP address to use as the remote address
#
# INPUT
# $1 : the IP version
# $2 : the host type
#
# OUTPUT
# Writes the IP address to stdout
#
# DESCRIPTION
# This function determines the correct remote address to use for the test
# run based on an IP version string, "ipv4" or "ipv6", and the host type,
# "local" or "remote".  While the "local" host types resolve to the IPv4 or
# IPv6 localhost address the "remote" host types resolve to IP addresses
# specified in environment variables which are queried at the start of the
# test run.
#
function get_host_remote {
    declare ipv_arg=$1 host_arg=$2

    case $ipv_arg in
	ipv4)
	    case $host_arg in
		local)
		    echo "127.0.0.1"
		    ;;
		remote)
		    echo "$lblnet_svr4_host"
		    ;;
		*)
		    exit_fail "invalid test argument"
		    ;;
	    esac
	    ;;
	ipv6)
	    case $host_arg in
		local)
		    echo "::1"
		    ;;
		remote)
		    echo "$lblnet_svr6_host"
		    ;;
		*)
		    exit_fail "invalid test argument"
		    ;;
	    esac
	    ;;
	*)
	    exit_fail "invalid test argument"
	    ;;
	esac
}

#
# tstsvr_lock - Lock the remote test server
#
# INPUT
# none
#
# OUTPUT
# Returns true if the test server was able to be locked, false otherwise
#
# DESCRIPTION
# This function attempts to lock the remote test server with the timeout value
# specified in the global variable $tstsvr_lock_timeout.  If the function is
# able to lock the remote test server then it returns true and sets the global
# variable $tstsvr_lock_held to 1 for use in the tstsvr_unlock() function.  If
# for any reason the function is not able to lock the remote test server then
# the function returns false and the value in $tstsvr_lock_held is unchanged.
# This function assumes the remote node is running a test driver similar to the
# one found in "utils/network-server/lblnet_tst_server.c".
#
function tstsvr_lock {
    declare rc
    declare str="lock:set,$tstsvr_lock_timeout;"

    rc="$($cmd_nc $lblnet_svr6_host 4000 <<< $str)"
    if [[ $rc == 0 ]]; then
	tstsvr_lock_held=1
	return 0
    fi

    return 1
}

#
# tstsvr_unlock - Unlock the remote test server
#
# INPUT
# none
#
# OUTPUT
# none
#
# DESCRIPTION
# This function attempts to unlock the remote test server if it was locked
# previously during this test run.  The function checks the $tstsvr_lock_held
# global variable and if the value is 1, set by the tstsvr_lock() function,
# then the function sends an unlock command to the remote test server.  If the
# $tstsvr_lock_held variable is not set to 1 then this function does nothing.
# This function assumes the remote node is running a test driver similar to the
# one found in "utils/network-server/lblnet_tst_server.c".
#
function tstsvr_unlock {
    declare str="lock:release;"

    if [[ $tstsvr_lock_held == 1 ]]; then
	nc -w 3 $lblnet_svr6_host 4000 <<< $str
    fi
}

#
# verify_netlabel - Verify that NetLabel is properly configured on the system
#
# INPUT
# none
#
# OUTPUT
# Returns true if NetLabel is configured properly, false otherwise
#
# DESCRIPTION
# This function performs some simple checks to verify that the local kernel's
# NetLabel subsystem is configured correctly for the test run.  If the function
# determines the kernel is configured correctly it returns true, otherwise it
# returns false.
#
function verify_netlabel {
    declare iter

    for iter in $(netlabelctl map list); do
	[[ "$(sed 's/domain://;s/,.*//;s/\"//g' <<< $iter)" == \
	    "lspp_test_netlabel_t" ]] && return 0
    done

    return 1
}

#
# verify_ipsec - Verify that IPsec is properly configured on the system
#
# INPUT
# none
#
# OUTPUT
# Returns true if IPsec is configured properly, false otherwise
#
# DESCRIPTION
# This function performs some simple checks to verify that the local system's
# IPsec subsystem is configured correctly for the test run.  If the function
# determines the system is configured correctly it returns true, otherwise it
# returns false.
#
function verify_ipsec {
    ps -C pluto &> /dev/null && \
	ip xfrm policy list | grep -q "$lblnet_svr4_host" && \
	ip xfrm policy list | grep -q "$lblnet_svr6_host"
    return $?
}

#
# verify_remote - Verify that the remote test server is available for use
#
# INPUT
# none
#
# OUTPUT
# Returns true if the remote test server is available, false otherwise
#
# DESCRIPTION
# This function checks to see if the remote test server is available for use
# and is able to be locked for this test run in which case it returns true.
# If the test server is offline, or in use by another host and unable to be
# locked then this function returns false.
#
function verify_remote {
    tstsvr_lock
    return $?
}

######################################################################
# defaults
######################################################################

#
# setup_default - Setup the remote test driver
#
# INPUT
# none
#
# OUTPUT
# none
#
# DESCRIPTION
# All of the network tests in this file need to either send data to a remote
# node or receive data from a remote node; this function does the required
# setup to initialize the remote node based on the individual test case.  This
# function works for both "local" (localhost) and "remote" (non-localhost)
# host types using both IPv4 and IPv6.  This function determines the setup
# needed by the test using the "op", "host", "type", "mlsop", "ipv", and 
# "port" named arguments as given on the test command line.  On error the
# function calls exit_error() which marks the test case as resulting in an
# error.  This function assumes the remote node is running a test driver
# similar to the one found in "utils/network-server/lblnet_tst_server.c".
#
function setup_default {
set -x
    declare rc=1
    declare str
    declare remote_obj local_host
    declare loop_cnt

    # generate the host command string
    remote_obj="$(get_label_obj $mlsop)"
    str="sockcon:full,system_u:system_r:$(get_test_domain $type $host):$remote_obj;"
    str+="detach;"
    case $op in
	sendrand_tcp)
            local_host="$(get_host_local $ipv $host)"
            str+="sleep:5;"
            str+="sendrand:$local_host,tcp,$port,1;"
	    ;;
	sendrand_udp)
	    local_host="$(get_host_local $ipv $host)"
            if [[ $type == ipsec ]]; then
                # Trigger the creation of SAs. Only needed for udp.
                str+="sleep:2;"
                str+="sendrand:$local_host,udp,$port,1;"
                # Send data for the test.
                str+="sleep:3;"
                str+="sendrand:$local_host,udp,$port,1;"
            else
                str+="sleep:5;"
                str+="sendrand:$local_host,udp,$port,1;"
            fi
	    ;;
	recv_tcp)
            str+="recv:$ipv,tcp,$port,0;"
	    ;;
	recv_udp)
            str+="recv:$ipv,udp,$port,1;"
	    ;;
	*)
	    exit_fail "invalid test argument"
	    ;;
    esac

    # setup the remote test server (try more than once)
    for ((loop_cnt=0; loop_cnt<=2; loop_cnt++)); do
	case $host in
	    remote)
	        rc="$(runcon -t $test_domain -l SystemLow -- $cmd_nc $lblnet_svr6_host 4000 <<< $str)"
		;;
	    local)
	        # use the same port as the remote IPv4 setting
		rc="$(runcon -t $test_domain -l SystemLow -- $cmd_nc ::1 4000 <<< $str)"
	        ;;
	    *)
	        exit_fail "invalid test argument"
		;;
	esac
	if [[ $rc != 0 ]]; then
	    echo "notice: failed to setup remote test server, retrying"
	    sleep 10
	else
	    break
	fi
    done

    # verify the setup
    if [[ $rc != 0 ]]; then
	exit_error "could not setup remote test server"
    fi
}

#
# augrok_default - Check for a syscall/socketcall audit record
#
# INPUT
# none
#
# OUTPUT
# Returns true if the syscall/socketcall audit record is found, false otherwise
#
# DESCRIPTION
# This function checks for a syscall or socketcall audit record which matches
# the expected result of the test case.  The heavy lifting of sorting through
# the audit log is handled by augrok, this function is only concerned with
# generating the correct augrok arguments.  The augrok command line is built
# up through the use of variables created by the run_test() function and other
# test harness functions based on the individual test case.
#
function augrok_default {
    declare expres_audit
    declare params
    declare sec

    # convert the test result expression into something usable by audit
    if [[ "$expres" == "success" ]]; then
	expres_audit="yes"
    else
	expres_audit="no"
    fi

    case $(uname -m)-$MODE in
	x86_64-64|ia64-64)
            params="--seek=$log_mark -m1 type==SYSCALL syscall=$syscall \
		success=$expres_audit exit=$exitval \
		pid=$pid auid=$(</proc/self/loginuid) \
		uid=$uid euid=$euid suid=$suid fsuid=$fsuid \
		gid=$gid egid=$egid sgid=$sgid fsgid=$fsgid \
		"$@""
            ;;
	x86_64-32)
	    # socket calls are multiplexed onto the socketcall() syscall
            if [[ "$syscall" == "recvmmsg" ]]; then
                params="--seek=$log_mark -m1 type==SYSCALL \
		    syscall=337 \
		    success=$expres_audit exit=$exitval \
		    pid=$pid auid=$(</proc/self/loginuid) \
		    uid=$uid euid=$euid suid=$suid fsuid=$fsuid \
		    gid=$gid egid=$egid sgid=$sgid fsgid=$fsgid \
		    "$@""
            else
                params="--seek=$log_mark -m1 type==SYSCALL \
		    syscall=socketcall a0=$(get_sockcall_num_hex $syscall) \
		    success=$expres_audit exit=$exitval \
		    pid=$pid auid=$(</proc/self/loginuid) \
		    uid=$uid euid=$euid suid=$suid fsuid=$fsuid \
		    gid=$gid egid=$egid sgid=$sgid fsgid=$fsgid \
		    "$@""
            fi
	    ;;
        ppc64-32)
            params="--seek=$log_mark -m1 type==SYSCALL \
                syscall=socketcall a0=$(get_sockcall_num_hex $syscall) \
                success=$expres_audit exit=$exitval \
                pid=$pid auid=$(</proc/self/loginuid) \
                uid=$uid euid=$euid suid=$suid fsuid=$fsuid \
                gid=$gid egid=$egid sgid=$sgid fsgid=$fsgid \
                "$@""
            ;;
        s390x-32)
            params="--seek=$log_mark -m1 type==SYSCALL \
                syscall=socketcall a0=$(get_sockcall_num_hex $syscall) \
                success=$expres_audit exit=$exitval \
                pid=$pid auid=$(</proc/self/loginuid) \
                uid=$uid euid=$euid suid=$suid fsuid=$fsuid \
                gid=$gid egid=$egid sgid=$sgid fsgid=$fsgid \
                "$@""
            ;;
	*)
	    # socket calls are multiplexed onto the socketcall() syscall
            params="--seek=$log_mark -m1 type==SOCKETCALL \
		syscall=socketcall a0=$(get_sockcall_num_hex $syscall) \
		success=$expres_audit exit=$exitval \
		pid=$pid auid=$(</proc/self/loginuid) \
		uid=$uid euid=$euid suid=$suid fsuid=$fsuid \
		gid=$gid egid=$egid sgid=$sgid fsgid=$fsgid \
		"$@""
	    ;;
    esac

    # we do this multiple times on failure to give the audit records time to
    # appear in the log (recent distros can lag in recording audit records)
    sec=0
    augrok $params
    while [[ $? != 0 && $sec -le 10 ]]; do
	sec=$(expr $sec + 5)
	echo "retrying the audit record search after a pause (${sec}s)"
	sleep 5
	augrok $params
    done
}

#
# auwatch_default - Add a audit watch for the desired syscall/socketcall
#
# INPUT
# none
#
# OUTPUT
# Returns true if the syscall/socketcall watch was created, false otherwise
#
# DESCRIPTION
# This function adds a syscall or socketcall audit watch so that the desired
# syscall or socketcall accesses are recorded by the audit subsystem.  The
# variables used below in the auditctl command line are created by the
# run_test() function and other test harness functions based on the individual
# test case.
#
function auwatch_default {
    declare sockcall_num
    declare syscall_name
    case $(uname -m)-$MODE in
	x86_64-64|ia64-64)
             syscall_name=$syscall
             if [[ "$syscall" == "accept4" ]]; then
	         syscall="288"
             fi
	     auditctl -a exit,always ${MODE:+-F arch=b$MODE} -S $syscall || \
		 exit_error
	     prepend_cleanup "auditctl -d exit,always ${MODE:+-F arch=b$MODE} \
                             -S $syscall"
             syscall=$syscall_name
            ;;
        *)
	     # socket calls are multiplexed onto the socketcall() syscall
             if [[ "$syscall" == "recvmmsg" ]]; then
                 syscall_name=$syscall
	         syscall="337"
	         auditctl -a exit,always ${MODE:+-F arch=b$MODE} -S $syscall || \
		     exit_error
	         prepend_cleanup "auditctl -d exit,always ${MODE:+-F arch=b$MODE} \
                             -S $syscall"
                 syscall=$syscall_name
             else
	         sockcall_num=$(get_sockcall_num $syscall)
	         auditctl -a exit,always ${MODE:+-F arch=b$MODE} \
		     -S socketcall -F a0=$sockcall_num || exit_error
	         prepend_cleanup "auditctl -d exit,always ${MODE:+-F arch=b$MODE} \
                                 -S socketcall -F a0=$sockcall_num"
             fi
	     ;;
    esac
}

######################################################################
# run.bash overrides
######################################################################

# Rename the original run.bash + function to run+ and create our own + function
# that generates a tag for the test based on the named parameters.

#
# + - Generate a unique tag for each test case and run the default "+" function
#
# INPUT
# $@ : test command line
#
# OUTPUT
# none
#
# DESCRIPTION
# This function acts as a wrapper for the original "+" function which is
# responsibile for running each test case shown at the bottom of this file.
# This wrapper function is necessary to automatically generate a unique tag for
# each test case based on it's named arguments.  This tag is then used as an
# additional named argument for the default "+" function.
#
eval "function run+ $(type + | sed '1,2d')"
function + {
    declare test=$1 tag # make sure it's not inherited from caller
    shift
    eval "$(parse_named "$@")" || exit_error

    if [[ -z $tag ]]; then
        # extract the named args that identify a unique testcase
        run+ $test \
	    tag="${test}__${host}_${type}_${ipv}_${expres}_subj_${mlsop}_obj" \
	    "$@"
    else
        # use tag supplied in run.conf
        run+ $test "$@"
    fi
}

#
# show_test - Display the test case details
#
# INPUT
# $@ : test command line
#
# OUTPUT
# Writes the test case details to stdout
#
# DESCRIPTION
# This function reads in the entire test case command line and depending on
# the verbosity of the test harness either the entire command line is dumped
# to stdout or just the tag named variable as generated by the +() function
# defined in this file.  All output is handled by the fmt_test() function
# which is defined as by the test harness.  This function was overloaded
# because of the special handling for the tag named variable.
#
function show_test {
    if ! $opt_verbose; then
	declare tag # make sure it's not inherited from caller
	eval "$(parse_named "$@")" || exit_error
	[[ -n $tag ]] && set -- "$tag"
    fi
    fmt_test "[$TESTNUM]" "$@"
}

#
# network_cleanup - Release the lock on the remote test server
#
# INPUT
# none
#
# OUTPUT
# none
#
# DESCRIPTION
# This function tries to unlock the remote test server by calling the
# tstsvr_unlock() function.
#
function network_cleanup {
    ip xfrm state flush
    nc -w 3 $lblnet_svr6_host 4000 <<< "ipsec:flush;"
    tstsvr_unlock
}
prepend_cleanup 'network_cleanup'

######################################################################
# local overrides
######################################################################

#
# augrok_default_inbound_rej - Check for denied incoming connections
#
# INPUT
# none
#
# OUTPUT
# Returns true if both the syscall/socketcall audit record and connection
# denial audit records are present in the audit log
#
# DESCRIPTION
# This function calls the augrok_default() function to check if the correct
# syscall/socket audit record is present; if it is then it checks to see if
# SELinux has issued any AVC denial messages due to rejecting an incoming
# connection based on the security policy, if both audit records are found the
# test returns true.  If either audit record is missing then the function
# returns false.
#
function augrok_default_inbound_rej {
    augrok_default && \
	augrok --seek=$log_mark -m1 type==AVC \
	 extra_text="avc: denied { recv } for" dest=$port
}

#
# augrok_syscall - Check for a syscall audit record
#
# INPUT
# none
#
# OUTPUT
# Returns true if the syscall audit record is found, false otherwise
#
# DESCRIPTION
# This function checks for a syscall audit record which matches the expected
# result of the test case.  The heavy lifting of sorting through the audit log
# is handled by augrok, this function is only concerned with generating the
# correct augrok arguments.  The augrok command line is built up through the
# use of variables created by the run_test() function and other test harness
# functions based on the individual test case.
#
function augrok_syscall {
    declare expres_audit

    # convert the test result expression into something usable by audit
    if [[ "$expres" == "success" ]]; then
	expres_audit="yes"
    else
	expres_audit="no"
    fi

    augrok --seek=$log_mark -m1 type==SYSCALL syscall=$syscall \
	success=$expres_audit exit=$exitval \
	pid=$pid auid=$(</proc/self/loginuid) \
	uid=$uid euid=$euid suid=$suid fsuid=$fsuid \
	gid=$gid egid=$egid sgid=$sgid fsgid=$fsgid \
	"$@"
}

#
# augrok_syscall_inbound_rej - Check for denied incoming connections
#
# INPUT
# none
#
# OUTPUT
# Returns true if both the syscall audit record and connection denial audit
# records are present in the audit log
#
# DESCRIPTION
# This function calls the augrok_syscall() function to check if the correct
# syscall audit record is present; if it is then it checks to see if SELinux
# has issued any AVC denial messages due to rejecting an incoming connection
# based on the security policy, if both audit records are found the test
# returns true.  If either audit record is missing then the function returns
# false.
#
function augrok_syscall_inbound_rej {
    augrok_syscall && \
	augrok --seek=$log_mark -m1 type==AVC \
	 extra_text="avc: denied { recv } for" dest=$port
}

#
# auwatch_syscall - Add a audit watch for the desired syscall
#
# INPUT
# none
#
# OUTPUT
# Returns true if the syscall watch was created, false otherwise
#
# DESCRIPTION
# This function adds a syscall audit watch so that the desired syscall
# accesses are recorded by the audit subsystem.  The variables used below in
# the auditctl command line are created by the run_test() function and other
# test harness functions based on the individual test case.
#
function auwatch_syscall {
    auditctl -a exit,always ${MODE:+-F arch=b$MODE} -S $syscall || exit_error
    prepend_cleanup "auditctl -d exit,always ${MODE:+-F arch=b$MODE} \
                    -S $syscall"
}

######################################################################
# run_test
######################################################################

#
# run_test - Execute an individual test case
#
# INPUT
# $@ : test command line
#
# OUTPUT
# Returns true on test success, other error values on test failure 
#
# DESCRIPTION
# This function is responsibile for executing all aspects of an individual
# test case including the following: setup, audit configuration and rotation,
# test case execution, test case verification, and audit verification.  Most of
# these tasks are handled by other helper function defined either in this file
# or in the test harness, however, they are called from inside this function
# based on the individual test case's requirements.  In the case where a test
# is run and it returns true and the audit verification is successful then this
# function returns true and the test case can be considered to have passed.
# However, if either the test case returns non-true, the audit trail is not
# correct, or an error occurs elsewhere then this function calls either the
# exit_fail() or exit_error() functions to signify a test case failure.
#
function run_test { 
    declare syscall=$1 tst_name=$1
    declare x name value status log_mark
    declare test_domain label_subj label_obj host_local host_remote
    shift
    eval "$(parse_named "$@")" || exit_error

    source network_functions.bash || exit_error

    # get the derived variables
    #  NOTE: the $test_domain variable is always using the "local" version of
    #        the test domain because the value is always only used on the
    #        local machine (see below)
    test_domain=$(get_test_domain $type local)
    label_subj=$(get_label_subj $mlsop)
    label_obj=$(get_label_obj $mlsop)
    host_local=$(get_host_local $ipv $host)
    host_remote=$(get_host_remote $ipv $host)

    # prepare cleanup and run the setup callback
    # (which has access to the named params) or run the default setup
    append_cleanup "tstsvr_cleanup $host_remote"
    if [[ -n $setupfunc ]]; then
        $setupfunc
    else
        setup_default
    fi

    # force the audit log to rotate
    rotate_audit_logs || exit_error

    # add an audit watch rule
    if [[ -n $auwatchfunc ]]; then
	$auwatchfunc || exit_error "unable to add an audit watch"
    else
	auwatch_default || exit_error "unable to add an audit watch"
    fi

    # mark the log for augrok later
    log_mark=$(stat -c %s $audit_log)

    # run this in a subshell so that exit_* doesn't abort early
    (
        declare testres exitval pid
	declare tst_args=( $(eval echo \"${unnamed[*]}\") )
        set -x

        # run the test itself
	read testres exitval pid <<< \
	    "$(runcon -u system_u -r system_r -t $test_domain -l $(get_label_subj $mlsop) -- \
               do_$tst_name "${tst_args[@]}" 2>&1 1>/dev/null)"

        [[ -z $testres || -z $exitval || -z $pid ]] && exit_error
        check_result $expres $testres $exitval $err

	# check for the audit records
        if [[ -n $augrokfunc ]]; then
            $augrokfunc || exit_fail "missing audit record"
        else
            augrok_default || exit_fail "missing audit record"
        fi

        exit_pass
    )
    status=$?

    # display the audit log items
    if [[ $status != 0 ]]; then
        echo
        echo augrok output
        echo -------------
        augrok --seek=$log_mark type!=DAEMON_ROTATE
    fi

    return $status
}

######################################################################
# pre-testrun checks/configuration
######################################################################

# check the test profile
[[ -z "$PPROFILE" ]] && die "error: profile not set (PPROFILE)"

# the remote labeled networking host/server
[[ -z "$LBLNET_SVR_IPV4" ]] && \
    die "error: labeled networking test server not specified (LBLNET_SVR_IPV4)"
[[ -z "$LBLNET_SVR_IPV6" ]] && \
    die "error: labeled networking test server not specified (LBLNET_SVR_IPV6)"

# the local machine
lblnet_loc4_host="$LOCAL_IPV4"
lblnet_loc6_host="$LOCAL_IPV6"

# the remote machine
lblnet_svr4_host="$LBLNET_SVR_IPV4"
lblnet_svr6_host="$LBLNET_SVR_IPV6"

case $PPROFILE in
    lspp)
        # verify that NetLabel and IPsec are configured
        verify_netlabel || warn "error: NetLabel not configured"
	verify_ipsec || warn "error: IPsec not configured"
	tstsvr_lock_timeout=$tstsvr_lock_timeout_lspp

	# attempt to establish ISAKMP SAs with the remote test server
        # racoonctl establish-sa isakmp inet6 $lblnet_loc6_host $lblnet_svr6_host
        # racoonctl establish-sa isakmp inet $lblnet_loc4_host $lblnet_svr4_host
	;;
    capp)
        tstsvr_lock_timeout=$tstsvr_lock_timeout_capp
        ;;
    *)
        die "error: unknown test profile ($PPROFILE)"
	;;
esac

# determine the netcat variant
if which nc6 >& /dev/null; then
	cmd_nc="nc6 --idle-timeout=1 -w 3 "
elif which nc >& /dev/null; then
	cmd_nc="nc -w 3 "
else
	die "error: netcat not installed"
fi

# wait until remote is available
while ! verify_remote; do
    echo "notice: test server is busy, sleeping for 60s ..."
    sleep 60
done

######################################################################
# test configuration
######################################################################

# It is important to note that prior to running any of the test below the
# system must be configured using the configuration templates in the
# "network/system" directory as directed by the test plan.  Failure to
# configure the system correctly will result in test failures.

##
## NET syscalls
##

# The test cases below are in the following format, with optional elements
# denoted by square brackets ([...]):
#
#  + <_syscall_> \
#    mlsop=<_mlsop_> expres=<_expres_> err=<_err_> \
#    [ auwatchfunc=<_auwatchfunc_> ] [ augrokfunc=<_augrokfunc_> ] \
#    host=<_host_> type=<_type_> op=<_op_> ipv=<_ipv_> port=<_port_> \
#    <_test_args_>
#
# Where the arguments are defined as follows:
#
#  _syscall_     : the syscall being tested
#  _mlsop_       : the MLS label comparison operator for more information see
#                  the comments elsewhere in this file, there are four valid
#                  values:
#                    eq     : the local test process label equals the remote
#                             process/packet/connection's label
#                    incomp : the local test process label is incomparable to
#                             the remote process/packet/connection's label
#                    dom    : the local test process label dominates the
#                             remote process/packet/connection's label
#                    domby  : the local test process label is dominated by the
#                             remote process/packet/connection's label
#  _expres_      : indicates that the operation should succeed (success) or
#                  fail (fail) based on the system's security policy
#  _err_         : if the test should fail, it should fail with this error
#                  code/value
#  _auwatchfunc_ : custom function for setting audit watches
#  _augrokfunc_  : custom function for validating the audit records
#  _host_        : indicates if the test is against a local (local) or
#                  remote (remote) host, the actual remote IP address is
#                  determined from the LBLNET_SVR_IPV4 and LBLNET_SVR_IPV6
#                  environment variables
#  _type_        : the labeling protocol to test, there are three valid values:
#                    unlabeled : not a labeling protocol, used as a sanity
#                                check
#                    netlabel  : the NetLabel explicit packet labeling
#                                mechanism, uses CIPSO
#                    ipsec     : the labeled IPsec implicit packet labeling
#                                mechanism
#  _op_          : the remote test driver command, there are four valid values:
#                    sendrand_tcp : initiate a TCP connection with the test
#                                   machine and send data
#                    sendrand_udp : send UDP traffic to the test machine
#                    recv_tcp     : accept TCP connections from the test
#                                   machine and receive data from established
#                                   connections
#                    recv_udp     : receive UDP traffic from the test machine
#  _ipv_         : the IP version, there are two values: ipv4 and ipv6
#  _port_        : the TCP or UDP port
#  _test_args_   : arguments to supply to the test applet/program, these may
#                  be variables which are later expanded inside the run_test()
#                  function

## SYSCALL:     accept()
## PURPOSE:
## Verify that incoming connections are only allowed when the sensitivity
## label of the incoming connection/packet dominates (is greater than or equal
## to) the receiving process.
## These test cases make use of a remote test driver to initiate a connection
## from the remote node to the host under test, see the setup_default()
## function above for details on configuring the remote test driver.  In
## addition to sanity checks using unlabled networking the test cases below
## test NetLabel and labeled IPsec connections where the receiving process
## is equal to (mlsop=eq), is incomparable to (mlsop=incomp),
## dominates (mlsop=dom), and is dominated by (mlsop=domby) the remote test
## driver and the resulting connection attempt.  The test procedure is as
## follows:
##  1. Configure the test driver to initiate a new connection at a
##     specific sensitivity label after a delay
##  2. Configure the audit subsystem to watch for the syscall record
##  3. Execute the test case on the local system and verify the result
##  4. Check the audit log for the correct syscall result and in the case of
##     failure check for SELinux generated audit records indicating that a
##     connection request was denied
## TESTCASE:    local unlabeled IPv4, sanity check
+ accept \
    mlsop=eq expres=success \
    host=local type=unlabeled op=sendrand_tcp ipv=ipv4 port=$tst_port1 \
    '$ipv $port'
## TESTCASE:    local unlabeled IPv6, sanity check
+ accept \
    mlsop=eq expres=success \
    host=local type=unlabeled op=sendrand_tcp ipv=ipv6 port=$tst_port1 \
    '$ipv $port'
## TESTCASE:    remote unlabeled IPv4, sanity check
+ accept \
    mlsop=eq expres=success \
    host=remote type=unlabeled op=sendrand_tcp ipv=ipv4 port=$tst_port1 \
    '$ipv $port'
## TESTCASE:    remote unlabeled IPv6, sanity check
+ accept \
    mlsop=eq expres=success \
    host=remote type=unlabeled op=sendrand_tcp ipv=ipv6 port=$tst_port1 \
    '$ipv $port'
if [[ $PPROFILE == lspp ]]; then
## TESTCASE:    local NetLabel IPv4, mac success (eq)
    + accept \
	mlsop=eq expres=success \
	host=local type=netlabel op=sendrand_tcp ipv=ipv4 port=$tst_port2 \
	'$ipv $port'
## TESTCASE:    local NetLabel IPv4, mac failure (incomp)
    + accept \
	mlsop=incomp expres=fail err=EINTR \
	augrokfunc=augrok_default_inbound_rej \
	host=local type=netlabel op=sendrand_tcp ipv=ipv4 port=$tst_port2 \
	'$ipv $port'
## TESTCASE:    local NetLabel IPv4, mac success (dom)
    + accept \
	mlsop=dom expres=success \
	augrokfunc=augrok_default \
	host=local type=netlabel op=sendrand_tcp ipv=ipv4 port=$tst_port2 \
	'$ipv $port'
## TESTCASE:    local NetLabel IPv4, mac failure (domby)
    + accept \
	mlsop=domby expres=fail err=EINTR \
	augrokfunc=augrok_default_inbound_rej \
	host=local type=netlabel op=sendrand_tcp ipv=ipv4 port=$tst_port2 \
	'$ipv $port'
## TESTCASE:    remote NetLabel IPv4, mac success (eq)
    + accept \
	mlsop=eq expres=success \
	host=remote type=netlabel op=sendrand_tcp ipv=ipv4 port=$tst_port2 \
	'$ipv $port'
## TESTCASE:    remote NetLabel IPv4, mac failure (incomp)
    + accept \
	mlsop=incomp expres=fail err=EINTR \
	augrokfunc=augrok_default_inbound_rej \
	host=remote type=netlabel op=sendrand_tcp ipv=ipv4 port=$tst_port2 \
	'$ipv $port'
## TESTCASE:    remote NetLabel IPv4, mac success (dom)
    + accept \
	mlsop=dom expres=success \
	augrokfunc=augrok_default \
	host=remote type=netlabel op=sendrand_tcp ipv=ipv4 port=$tst_port2 \
	'$ipv $port'
## TESTCASE:    remote NetLabel IPv4, mac failure (domby)
    + accept \
	mlsop=domby expres=fail err=EINTR \
	augrokfunc=augrok_default_inbound_rej \
	host=remote type=netlabel op=sendrand_tcp ipv=ipv4 port=$tst_port2 \
	'$ipv $port'
## TESTCASE:    local IPsec IPv4, mac success (eq)
    + accept \
	mlsop=eq expres=success \
	host=local type=ipsec op=sendrand_tcp ipv=ipv4 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    local IPsec IPv4, mac failure (incomp)
    + accept \
	mlsop=incomp expres=fail err=EINTR \
	augrokfunc=augrok_default_inbound_rej \
	host=local type=ipsec op=sendrand_tcp ipv=ipv4 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    local IPsec IPv4, mac success (dom)
    + accept \
	mlsop=dom expres=success \
	augrokfunc=augrok_default \
	host=local type=ipsec op=sendrand_tcp ipv=ipv4 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    local IPsec IPv4, mac failure (domby)
    + accept \
	mlsop=domby expres=fail err=EINTR \
	augrokfunc=augrok_default_inbound_rej \
	host=local type=ipsec op=sendrand_tcp ipv=ipv4 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    remote IPsec IPv4, mac success (eq)
    + accept \
	mlsop=eq expres=success \
	host=remote type=ipsec op=sendrand_tcp ipv=ipv4 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    remote IPsec IPv4, mac failure (incomp)
    + accept \
	mlsop=incomp expres=fail err=EINTR \
	augrokfunc=augrok_default_inbound_rej \
	host=remote type=ipsec op=sendrand_tcp ipv=ipv4 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    remote IPsec IPv4, mac success (dom)
    + accept \
	mlsop=dom expres=success \
	augrokfunc=augrok_default \
	host=remote type=ipsec op=sendrand_tcp ipv=ipv4 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    remote IPsec IPv4, mac failure (domby)
    + accept \
	mlsop=domby expres=fail err=EINTR \
	augrokfunc=augrok_default_inbound_rej \
	host=remote type=ipsec op=sendrand_tcp ipv=ipv4 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    local IPsec IPv6, mac success (eq)
    + accept \
	mlsop=eq expres=success \
	host=local type=ipsec op=sendrand_tcp ipv=ipv6 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    local IPsec IPv6, mac failure (incomp)
    + accept \
	mlsop=incomp expres=fail err=EINTR \
	augrokfunc=augrok_default_inbound_rej \
	host=local type=ipsec op=sendrand_tcp ipv=ipv6 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    local IPsec IPv6, mac success (dom)
    + accept \
	mlsop=dom expres=success \
	augrokfunc=augrok_default \
	host=local type=ipsec op=sendrand_tcp ipv=ipv6 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    local IPsec IPv6, mac failure (domby)
    + accept \
	mlsop=domby expres=fail err=EINTR \
	augrokfunc=augrok_default_inbound_rej \
	host=local type=ipsec op=sendrand_tcp ipv=ipv6 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    remote IPsec IPv6, mac success (eq)
    + accept \
	mlsop=eq expres=success \
	host=remote type=ipsec op=sendrand_tcp ipv=ipv6 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    remote IPsec IPv6, mac failure (incomp)
    + accept \
	mlsop=incomp expres=fail err=EINTR \
	augrokfunc=augrok_default_inbound_rej \
	host=remote type=ipsec op=sendrand_tcp ipv=ipv6 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    remote IPsec IPv6, mac success (dom)
    + accept \
	mlsop=dom expres=success \
	augrokfunc=augrok_default \
	host=remote type=ipsec op=sendrand_tcp ipv=ipv6 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    remote IPsec IPv6, mac failure (domby)
    + accept \
	mlsop=domby expres=fail err=EINTR \
	augrokfunc=augrok_default_inbound_rej \
	host=remote type=ipsec op=sendrand_tcp ipv=ipv6 port=$tst_port3 \
	'$ipv $port'
fi

## SYSCALL:     accept4()
## PURPOSE:
## Verify that incoming connections are only allowed when the sensitivity
## label of the incoming connection/packet dominates (is greater than or equal
## to) the receiving process.
## These test cases make use of a remote test driver to initiate a connection
## from the remote node to the host under test, see the setup_default()
## function above for details on configuring the remote test driver.  In
## addition to sanity checks using unlabled networking the test cases below
## test NetLabel and labeled IPsec connections where the receiving process
## is equal to (mlsop=eq), is incomparable to (mlsop=incomp),
## dominates (mlsop=dom), and is dominated by (mlsop=domby) the remote test
## driver and the resulting connection attempt.  The test procedure is as
## follows:
##  1. Configure the test driver to initiate a new connection at a
##     specific sensitivity label after a delay
##  2. Configure the audit subsystem to watch for the syscall record
##  3. Execute the test case on the local system and verify the result
##  4. Check the audit log for the correct syscall result and in the case of
##     failure check for SELinux generated audit records indicating that a
##     connection request was denied
if [[ $HOSTTYPE == x86_64 ]]; then
## TESTCASE:    local unlabeled IPv4, sanity check
    + accept4 \
        mlsop=eq expres=success \
        host=local type=unlabeled op=sendrand_tcp ipv=ipv4 port=$tst_port1 \
        '$ipv $port'
## TESTCASE:    local unlabeled IPv6, sanity check
    + accept4 \
        mlsop=eq expres=success \
        host=local type=unlabeled op=sendrand_tcp ipv=ipv6 port=$tst_port1 \
        '$ipv $port'
## TESTCASE:    remote unlabeled IPv4, sanity check
    + accept4 \
        mlsop=eq expres=success \
        host=remote type=unlabeled op=sendrand_tcp ipv=ipv4 port=$tst_port1 \
        '$ipv $port'
## TESTCASE:    remote unlabeled IPv6, sanity check
    + accept4 \
        mlsop=eq expres=success \
        host=remote type=unlabeled op=sendrand_tcp ipv=ipv6 port=$tst_port1 \
        '$ipv $port'
    if [[ $PPROFILE == lspp ]]; then
## TESTCASE:    local NetLabel IPv4, mac success (eq)
        + accept4 \
	    mlsop=eq expres=success \
	    host=local type=netlabel op=sendrand_tcp ipv=ipv4 port=$tst_port2 \
	    '$ipv $port'
## TESTCASE:    local NetLabel IPv4, mac failure (incomp)
        + accept4 \
	    mlsop=incomp expres=fail err=EINTR \
	    augrokfunc=augrok_default_inbound_rej \
	    host=local type=netlabel op=sendrand_tcp ipv=ipv4 port=$tst_port2 \
	    '$ipv $port'
## TESTCASE:    local NetLabel IPv4, mac success (dom)
        + accept4 \
	    mlsop=dom expres=success \
	    augrokfunc=augrok_default \
	    host=local type=netlabel op=sendrand_tcp ipv=ipv4 port=$tst_port2 \
	    '$ipv $port'
## TESTCASE:    local NetLabel IPv4, mac failure (domby)
        + accept4 \
	    mlsop=domby expres=fail err=EINTR \
	    augrokfunc=augrok_default_inbound_rej \
	    host=local type=netlabel op=sendrand_tcp ipv=ipv4 port=$tst_port2 \
	    '$ipv $port'
## TESTCASE:    remote NetLabel IPv4, mac success (eq)
        + accept4 \
	    mlsop=eq expres=success \
	    host=remote type=netlabel op=sendrand_tcp ipv=ipv4 port=$tst_port2 \
	    '$ipv $port'
## TESTCASE:    remote NetLabel IPv4, mac failure (incomp)
        + accept4 \
	    mlsop=incomp expres=fail err=EINTR \
	    augrokfunc=augrok_default_inbound_rej \
	    host=remote type=netlabel op=sendrand_tcp ipv=ipv4 port=$tst_port2 \
	    '$ipv $port'
## TESTCASE:    remote NetLabel IPv4, mac success (dom)
        + accept4 \
	    mlsop=dom expres=success \
	    augrokfunc=augrok_default \
	    host=remote type=netlabel op=sendrand_tcp ipv=ipv4 port=$tst_port2 \
	    '$ipv $port'
## TESTCASE:    remote NetLabel IPv4, mac failure (domby)
        + accept4 \
	    mlsop=domby expres=fail err=EINTR \
	    augrokfunc=augrok_default_inbound_rej \
	    host=remote type=netlabel op=sendrand_tcp ipv=ipv4 port=$tst_port2 \
	    '$ipv $port'
## TESTCASE:    local IPsec IPv4, mac success (eq)
        + accept4 \
	    mlsop=eq expres=success \
	    host=local type=ipsec op=sendrand_tcp ipv=ipv4 port=$tst_port3 \
	    '$ipv $port'
## TESTCASE:    local IPsec IPv4, mac failure (incomp)
        + accept4 \
	    mlsop=incomp expres=fail err=EINTR \
	    augrokfunc=augrok_default_inbound_rej \
	    host=local type=ipsec op=sendrand_tcp ipv=ipv4 port=$tst_port3 \
	    '$ipv $port'
## TESTCASE:    local IPsec IPv4, mac success (dom)
        + accept4 \
	    mlsop=dom expres=success \
	    augrokfunc=augrok_default \
	    host=local type=ipsec op=sendrand_tcp ipv=ipv4 port=$tst_port3 \
	    '$ipv $port'
## TESTCASE:    local IPsec IPv4, mac failure (domby)
        + accept4 \
	    mlsop=domby expres=fail err=EINTR \
	    augrokfunc=augrok_default_inbound_rej \
	    host=local type=ipsec op=sendrand_tcp ipv=ipv4 port=$tst_port3 \
	    '$ipv $port'
## TESTCASE:    remote IPsec IPv4, mac success (eq)
        + accept4 \
	    mlsop=eq expres=success \
	    host=remote type=ipsec op=sendrand_tcp ipv=ipv4 port=$tst_port3 \
	    '$ipv $port'
## TESTCASE:    remote IPsec IPv4, mac failure (incomp)
        + accept4 \
	    mlsop=incomp expres=fail err=EINTR \
	    augrokfunc=augrok_default_inbound_rej \
	    host=remote type=ipsec op=sendrand_tcp ipv=ipv4 port=$tst_port3 \
	    '$ipv $port'
## TESTCASE:    remote IPsec IPv4, mac success (dom)
        + accept4 \
	    mlsop=dom expres=success \
	    augrokfunc=augrok_default \
	    host=remote type=ipsec op=sendrand_tcp ipv=ipv4 port=$tst_port3 \
	    '$ipv $port'
## TESTCASE:    remote IPsec IPv4, mac failure (domby)
        + accept4 \
	    mlsop=domby expres=fail err=EINTR \
	    augrokfunc=augrok_default_inbound_rej \
	    host=remote type=ipsec op=sendrand_tcp ipv=ipv4 port=$tst_port3 \
	    '$ipv $port'
## TESTCASE:    local IPsec IPv6, mac success (eq)
        + accept4 \
	    mlsop=eq expres=success \
	    host=local type=ipsec op=sendrand_tcp ipv=ipv6 port=$tst_port3 \
	    '$ipv $port'
## TESTCASE:    local IPsec IPv6, mac failure (incomp)
        + accept4 \
	    mlsop=incomp expres=fail err=EINTR \
	    augrokfunc=augrok_default_inbound_rej \
	    host=local type=ipsec op=sendrand_tcp ipv=ipv6 port=$tst_port3 \
	    '$ipv $port'
## TESTCASE:    local IPsec IPv6, mac success (dom)
        + accept4 \
	    mlsop=dom expres=success \
	    augrokfunc=augrok_default \
	    host=local type=ipsec op=sendrand_tcp ipv=ipv6 port=$tst_port3 \
	    '$ipv $port'
## TESTCASE:    local IPsec IPv6, mac failure (domby)
        + accept4 \
	    mlsop=domby expres=fail err=EINTR \
	    augrokfunc=augrok_default_inbound_rej \
	    host=local type=ipsec op=sendrand_tcp ipv=ipv6 port=$tst_port3 \
	    '$ipv $port'
## TESTCASE:    remote IPsec IPv6, mac success (eq)
        + accept4 \
	    mlsop=eq expres=success \
	    host=remote type=ipsec op=sendrand_tcp ipv=ipv6 port=$tst_port3 \
	    '$ipv $port'
## TESTCASE:    remote IPsec IPv6, mac failure (incomp)
        + accept4 \
	    mlsop=incomp expres=fail err=EINTR \
	    augrokfunc=augrok_default_inbound_rej \
	    host=remote type=ipsec op=sendrand_tcp ipv=ipv6 port=$tst_port3 \
	    '$ipv $port'
## TESTCASE:    remote IPsec IPv6, mac success (dom)
        + accept4 \
	    mlsop=dom expres=success \
	    augrokfunc=augrok_default \
	    host=remote type=ipsec op=sendrand_tcp ipv=ipv6 port=$tst_port3 \
	    '$ipv $port'
## TESTCASE:    remote IPsec IPv6, mac failure (domby)
        + accept4 \
	    mlsop=domby expres=fail err=EINTR \
	    augrokfunc=augrok_default_inbound_rej \
	    host=remote type=ipsec op=sendrand_tcp ipv=ipv6 port=$tst_port3 \
	    '$ipv $port'
    fi
fi

## SYSCALL:     connect()
## PURPOSE:
## Verify that outgoing connections are only allowed when the sensitivity label
## of the outgoing connection/packet dominates the receiving process.  These
## test cases make use of a remote test driver to accept new connections from
## the host under test, see the setup_default() function above for details on
## configuring the remote test driver.  In addition to sanity checks using
## unlabeled networking the test cases below test NetLabel and labeled IPsec
## connections where the sending process is equal to (mlsop=eq), is
## incomparable to (mlsop=incomp), dominates (mlsop=dom), and is dominated 
## by (mlsop=domby) the remote test driver waiting for a connection request.
## The test procedure is as follows:
##  1. Configure the test driver to accept new connections at a specific
##     sensitivity label
##  2. Configure the audit subsystem to watch for the syscall record
##  3. Execute the test case on the local system and verify the result
##  4. Check the audit log for the correct syscall result
## TESTCASE:    local unlabeled IPv4, sanity check
+ connect \
    mlsop=eq expres=success \
    host=local type=unlabeled op=recv_tcp ipv=ipv4 port=$tst_port1 \
    '$host_remote tcp $port'
## TESTCASE:    local unlabeled IPv6, sanity check
+ connect \
    mlsop=eq expres=success \
    host=local type=unlabeled op=recv_tcp ipv=ipv6 port=$tst_port1 \
    '$host_remote tcp $port'
## TESTCASE:    remote unlabeled IPv4, sanity check
+ connect \
    mlsop=eq expres=success \
    host=remote type=unlabeled op=recv_tcp ipv=ipv4 port=$tst_port1 \
    '$host_remote tcp $port'
## TESTCASE:    remote unlabeled IPv6, sanity check
+ connect \
    mlsop=eq expres=success \
    host=remote type=unlabeled op=recv_tcp ipv=ipv6 port=$tst_port1 \
    '$host_remote tcp $port'
if [[ $PPROFILE == lspp ]]; then
## TESTCASE:    local NetLabel IPv4, mac success (eq)
    + connect \
	mlsop=eq expres=success \
	host=local type=netlabel op=recv_tcp ipv=ipv4 port=$tst_port2 \
	'$host_remote tcp $port'
## TESTCASE:    local NetLabel IPv4, mac failure (incomp)
    + connect \
	mlsop=incomp expres=fail err=EHOSTUNREACH \
	host=local type=netlabel op=recv_tcp ipv=ipv4 port=$tst_port2 \
	'$host_remote tcp $port'
## TESTCASE:    local NetLabel IPv4, mac failure (dom)
    + connect \
	mlsop=dom expres=fail err=EHOSTUNREACH \
	host=local type=netlabel op=recv_tcp ipv=ipv4 port=$tst_port2 \
	'$host_remote tcp $port'
## TESTCASE:    local NetLabel IPv4, mac success (domby)
    + connect \
	mlsop=domby expres=success \
	host=local type=netlabel op=recv_tcp ipv=ipv4 port=$tst_port2 \
	'$host_remote tcp $port'
## TESTCASE:    remote NetLabel IPv4, mac success (eq)
    + connect \
	mlsop=eq expres=success \
	host=remote type=netlabel op=recv_tcp ipv=ipv4 port=$tst_port2 \
	'$host_remote tcp $port'
## TESTCASE:    remote NetLabel IPv4, mac failure (incomp)
    + connect \
	mlsop=incomp expres=fail err=EHOSTUNREACH \
	host=remote type=netlabel op=recv_tcp ipv=ipv4 port=$tst_port2 \
	'$host_remote tcp $port'
## TESTCASE:    remote NetLabel IPv4, mac failure (dom)
    + connect \
	mlsop=dom expres=fail err=EHOSTUNREACH \
	host=remote type=netlabel op=recv_tcp ipv=ipv4 port=$tst_port2 \
	'$host_remote tcp $port'
## TESTCASE:    remote NetLabel IPv4, mac success (domby)
    + connect \
	mlsop=domby expres=success \
	host=remote type=netlabel op=recv_tcp ipv=ipv4 port=$tst_port2 \
	'$host_remote tcp $port'
## TESTCASE:    local IPsec IPv4, mac success (eq)
    + connect \
	mlsop=eq expres=success \
	host=local type=ipsec op=recv_tcp ipv=ipv4 port=$tst_port3 \
	'$host_remote tcp $port'
## TESTCASE:    local IPsec IPv4, mac failure (incomp)
    + connect \
	mlsop=incomp expres=fail err=ETIMEDOUT \
	host=local type=ipsec op=recv_tcp ipv=ipv4 port=$tst_port3 \
	'$host_remote tcp $port'
## TESTCASE:    local IPsec IPv4, mac failure (dom)
    + connect \
	mlsop=dom expres=fail err=ETIMEDOUT \
	host=local type=ipsec op=recv_tcp ipv=ipv4 port=$tst_port3 \
	'$host_remote tcp $port'
## TESTCASE:    local IPsec IPv4, mac success (domby)
    + connect \
	mlsop=domby expres=success \
	host=local type=ipsec op=recv_tcp ipv=ipv4 port=$tst_port3 \
	'$host_remote tcp $port'
## TESTCASE:    remote IPsec IPv4, mac success (eq)
    + connect \
	mlsop=eq expres=success \
	host=remote type=ipsec op=recv_tcp ipv=ipv4 port=$tst_port3 \
	'$host_remote tcp $port'
## TESTCASE:    remote IPsec IPv4, mac failure (incomp)
    + connect \
	mlsop=incomp expres=fail err=ETIMEDOUT \
	host=remote type=ipsec op=recv_tcp ipv=ipv4 port=$tst_port3 \
	'$host_remote tcp $port'
## TESTCASE:    remote IPsec IPv4, mac failure (dom)
    + connect \
	mlsop=dom expres=fail err=ETIMEDOUT \
	host=remote type=ipsec op=recv_tcp ipv=ipv4 port=$tst_port3 \
	'$host_remote tcp $port'
## TESTCASE:    remote IPsec IPv4, mac success (domby)
    + connect \
	mlsop=domby expres=success \
	host=remote type=ipsec op=recv_tcp ipv=ipv4 port=$tst_port3 \
	'$host_remote tcp $port'
## TESTCASE:    local IPsec IPv6, mac success (eq)
    + connect \
	mlsop=eq expres=success \
	host=local type=ipsec op=recv_tcp ipv=ipv6 port=$tst_port3 \
	'$host_remote tcp $port'
## TESTCASE:    local IPsec IPv6, mac failure (incomp)
    + connect \
	mlsop=incomp expres=fail err=ETIMEDOUT \
	host=local type=ipsec op=recv_tcp ipv=ipv6 port=$tst_port3 \
	'$host_remote tcp $port'
## TESTCASE:    local IPsec IPv6, mac failure (dom)
    + connect \
	mlsop=dom expres=fail err=ETIMEDOUT \
	host=local type=ipsec op=recv_tcp ipv=ipv6 port=$tst_port3 \
	'$host_remote tcp $port'
## TESTCASE:    local IPsec IPv6, mac success (domby)
    + connect \
	mlsop=domby expres=success \
	host=local type=ipsec op=recv_tcp ipv=ipv6 port=$tst_port3 \
	'$host_remote tcp $port'
## TESTCASE:    remote IPsec IPv6, mac success (eq)
    + connect \
	mlsop=eq expres=success \
	host=remote type=ipsec op=recv_tcp ipv=ipv6 port=$tst_port3 \
	'$host_remote tcp $port'
## TESTCASE:    remote IPsec IPv6, mac failure (incomp)
    + connect \
	mlsop=incomp expres=fail err=ETIMEDOUT \
	host=remote type=ipsec op=recv_tcp ipv=ipv6 port=$tst_port3 \
	'$host_remote tcp $port'
## TESTCASE:    remote IPsec IPv6, mac failure (dom)
    + connect \
	mlsop=dom expres=fail err=ETIMEDOUT \
	host=remote type=ipsec op=recv_tcp ipv=ipv6 port=$tst_port3 \
	'$host_remote tcp $port'
## TESTCASE:    remote IPsec IPv6, mac success (domby)
    + connect \
	mlsop=domby expres=success \
	host=remote type=ipsec op=recv_tcp ipv=ipv6 port=$tst_port3 \
	'$host_remote tcp $port'
fi

## SYSCALL:     recvfrom()
## PURPOSE:
## Verify that incoming traffic is only allowed when the sensitivity label of
## the incoming packet dominates (is greater than or equal to) to the receiving
## process.  These test cases
## make use of a remote test driver to generate traffic from the remote node
## to the host under test, see the setup_default() function above for details
## on configuring the remote test driver.  In addition to sanity checks using
## unlabled networking the test cases below test NetLabel and labeled IPsec
## labeled packets where the receiving process is equal to (mlsop=eq), is
## incomparable to (mlsop=incomp), dominates (mlsop=dom), and is dominated by
## (mlsop=domby) the remote test driver and the resulting network traffic.
## The test procedure is as follows:
##  1. Configure the test driver to generate traffic at a specific sensitivity
##     label after a delay
##  2. Configure the audit subsystem to watch for the syscall record
##  3. Execute the test case on the local system and verify the result
##  4. Check the audit log for the correct syscall result and in the case of
##     failure check for SELinux generated audit records indicating that
##     incoming traffic was rejected
## TESTCASE:    local unlabeled IPv4, sanity check
+ recvfrom \
    mlsop=eq expres=success \
    host=local type=unlabeled op=sendrand_udp ipv=ipv4 port=$tst_port1 \
    '$ipv $port'
## TESTCASE:    local unlabeled IPv6, sanity check
+ recvfrom \
    mlsop=eq expres=success \
    host=local type=unlabeled op=sendrand_udp ipv=ipv6 port=$tst_port1 \
    '$ipv $port'
## TESTCASE:    remote unlabeled IPv4, sanity check
+ recvfrom \
    mlsop=eq expres=success \
    host=remote type=unlabeled op=sendrand_udp ipv=ipv4 port=$tst_port1 \
    '$ipv $port'
## TESTCASE:    remote unlabeled IPv6, sanity check
+ recvfrom \
    mlsop=eq expres=success \
    host=remote type=unlabeled op=sendrand_udp ipv=ipv6 port=$tst_port1 \
    '$ipv $port'
if [[ $PPROFILE == lspp ]]; then
## TESTCASE:    local NetLabel IPv4, mac success (eq)
    + recvfrom \
	mlsop=eq expres=success \
	host=local type=netlabel op=sendrand_udp ipv=ipv4 port=$tst_port2 \
	'$ipv $port'
## TESTCASE:    local NetLabel IPv4, mac failure (incomp)
    + recvfrom \
	mlsop=incomp expres=fail err=EINTR \
	augrokfunc=augrok_default_inbound_rej \
	host=local type=netlabel op=sendrand_udp ipv=ipv4 port=$tst_port2 \
	'$ipv $port'
## TESTCASE:    local NetLabel IPv4, mac success (dom)
    + recvfrom \
	mlsop=dom expres=success  \
	augrokfunc=augrok_default \
	host=local type=netlabel op=sendrand_udp ipv=ipv4 port=$tst_port2 \
	'$ipv $port'
## TESTCASE:    local NetLabel IPv4, mac failure (domby)
    + recvfrom \
	mlsop=domby expres=fail err=EINTR \
	augrokfunc=augrok_default_inbound_rej \
	host=local type=netlabel op=sendrand_udp ipv=ipv4 port=$tst_port2 \
	'$ipv $port'
## TESTCASE:    remote NetLabel IPv4, mac success (eq)
    + recvfrom \
	mlsop=eq expres=success \
	host=remote type=netlabel op=sendrand_udp ipv=ipv4 port=$tst_port2 \
	'$ipv $port'
## TESTCASE:    remote NetLabel IPv4, mac failure (incomp)
    + recvfrom \
	mlsop=incomp expres=fail err=EINTR \
	augrokfunc=augrok_default_inbound_rej \
	host=remote type=netlabel op=sendrand_udp ipv=ipv4 port=$tst_port2 \
	'$ipv $port'
## TESTCASE:    remote NetLabel IPv4, mac success (dom)
    + recvfrom \
	mlsop=dom expres=success \
	augrokfunc=augrok_default \
	host=remote type=netlabel op=sendrand_udp ipv=ipv4 port=$tst_port2 \
	'$ipv $port'
## TESTCASE:    remote NetLabel IPv4, mac failure (domby)
    + recvfrom \
	mlsop=domby expres=fail err=EINTR \
	augrokfunc=augrok_default_inbound_rej \
	host=remote type=netlabel op=sendrand_udp ipv=ipv4 port=$tst_port2 \
	'$ipv $port'
## TESTCASE:    local IPsec IPv4, mac success (eq)
    + recvfrom \
	mlsop=eq expres=success \
	host=local type=ipsec op=sendrand_udp ipv=ipv4 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    local IPsec IPv4, mac failure (incomp)
    + recvfrom \
	mlsop=incomp expres=fail err=EINTR \
	augrokfunc=augrok_default_inbound_rej \
	host=local type=ipsec op=sendrand_udp ipv=ipv4 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    local IPsec IPv4, mac success (dom)
    + recvfrom \
	mlsop=dom expres=success \
	augrokfunc=augrok_default \
	host=local type=ipsec op=sendrand_udp ipv=ipv4 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    local IPsec IPv4, mac failure (domby)
    + recvfrom \
	mlsop=domby expres=fail err=EINTR \
	host=local type=ipsec op=sendrand_udp ipv=ipv4 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    remote IPsec IPv4, mac success (eq)
    + recvfrom \
	mlsop=eq expres=success \
	host=remote type=ipsec op=sendrand_udp ipv=ipv4 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    remote IPsec IPv4, mac failure (incomp)
    + recvfrom \
	mlsop=incomp expres=fail err=EINTR \
	augrokfunc=augrok_default_inbound_rej \
	host=remote type=ipsec op=sendrand_udp ipv=ipv4 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    remote IPsec IPv4, mac success (dom)
    + recvfrom \
	mlsop=dom expres=success \
	augrokfunc=augrok_default \
	host=remote type=ipsec op=sendrand_udp ipv=ipv4 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    remote IPsec IPv4, mac failure (domby)
    + recvfrom \
	mlsop=domby expres=fail err=EINTR \
	host=remote type=ipsec op=sendrand_udp ipv=ipv4 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    local IPsec IPv6, mac success (eq)
    + recvfrom \
	mlsop=eq expres=success \
	host=local type=ipsec op=sendrand_udp ipv=ipv6 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    local IPsec IPv6, mac failure (incomp)
    + recvfrom \
	mlsop=incomp expres=fail err=EINTR \
	augrokfunc=augrok_default_inbound_rej \
	host=local type=ipsec op=sendrand_udp ipv=ipv6 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    local IPsec IPv6, mac success (dom)
    + recvfrom \
	mlsop=dom expres=success \
	augrokfunc=augrok_default \
	host=local type=ipsec op=sendrand_udp ipv=ipv6 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    local IPsec IPv6, mac failure (domby)
    + recvfrom \
	mlsop=domby expres=fail err=EINTR \
	host=local type=ipsec op=sendrand_udp ipv=ipv6 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    remote IPsec IPv6, mac success (eq)
    + recvfrom \
	mlsop=eq expres=success \
	host=remote type=ipsec op=sendrand_udp ipv=ipv6 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    remote IPsec IPv6, mac failure (incomp)
    + recvfrom \
	mlsop=incomp expres=fail err=EINTR \
	augrokfunc=augrok_default_inbound_rej \
	host=remote type=ipsec op=sendrand_udp ipv=ipv6 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    remote IPsec IPv6, mac success (dom)
    + recvfrom \
	mlsop=dom expres=success \
	augrokfunc=augrok_default \
	host=remote type=ipsec op=sendrand_udp ipv=ipv6 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    remote IPsec IPv6, mac failure (domby)
    + recvfrom \
	mlsop=domby expres=fail err=EINTR \
	host=remote type=ipsec op=sendrand_udp ipv=ipv6 port=$tst_port3 \
	'$ipv $port'
fi

## SYSCALL:     recvmsg()
## PURPOSE:
## Verify that incoming traffic is only allowed when the sensitivity label of
## the incoming packet dominates (is greater than or equal to) the receiving
## process.  These test cases
## make use of a remote test driver to generate traffic from the remote node
## to the host under test, see the setup_default() function above for details
## on configuring the remote test driver.  In addition to sanity checks using
## unlabled networking the test cases below test NetLabel and labeled IPsec
## labeled packets where the receiving process is equal to (mlsop=eq), is
## incomparable to (mlsop=incomp), dominates (mlsop=dom), and is dominated by
## (mlsop=domby) the remote test driver and the resulting network traffic.
## The test procedure is as follows:
##  1. Configure the test driver to generate traffic at a specific sensitivity
##     label after a delay
##  2. Configure the audit subsystem to watch for the syscall record
##  3. Execute the test case on the local system and verify the result
##  4. Check the audit log for the correct syscall result and in the case of
##     failure check for SELinux generated audit records indicating that
##     incoming traffic was rejected
## TESTCASE:    local unlabeled IPv4, sanity check
+ recvmsg \
    mlsop=eq expres=success \
    host=local type=unlabeled op=sendrand_udp ipv=ipv4 port=$tst_port1 \
    '$ipv $port'
## TESTCASE:    local unlabeled IPv6, sanity check
+ recvmsg \
    mlsop=eq expres=success \
    host=local type=unlabeled op=sendrand_udp ipv=ipv6 port=$tst_port1 \
    '$ipv $port'
## TESTCASE:    remote unlabeled IPv4, sanity check
+ recvmsg \
    mlsop=eq expres=success \
    host=remote type=unlabeled op=sendrand_udp ipv=ipv4 port=$tst_port1 \
    '$ipv $port'
## TESTCASE:    remote unlabeled IPv6, sanity check
+ recvmsg \
    mlsop=eq expres=success \
    host=remote type=unlabeled op=sendrand_udp ipv=ipv6 port=$tst_port1 \
    '$ipv $port'
if [[ $PPROFILE == lspp ]]; then
## TESTCASE:    local NetLabel IPv4, mac success (eq)
    + recvmsg \
	mlsop=eq expres=success \
	host=local type=netlabel op=sendrand_udp ipv=ipv4 port=$tst_port2 \
	'$ipv $port'
## TESTCASE:    local NetLabel IPv4, mac failure (incomp)
    + recvmsg \
	mlsop=incomp expres=fail err=EINTR \
	augrokfunc=augrok_default_inbound_rej \
	host=local type=netlabel op=sendrand_udp ipv=ipv4 port=$tst_port2 \
	'$ipv $port'
## TESTCASE:    local NetLabel IPv4, mac success (dom)
    + recvmsg \
	mlsop=dom expres=success \
	augrokfunc=augrok_default \
	host=local type=netlabel op=sendrand_udp ipv=ipv4 port=$tst_port2 \
	'$ipv $port'
## TESTCASE:    local NetLabel IPv4, mac failure (domby)
    + recvmsg \
	mlsop=domby expres=fail err=EINTR \
	augrokfunc=augrok_default_inbound_rej \
	host=local type=netlabel op=sendrand_udp ipv=ipv4 port=$tst_port2 \
	'$ipv $port'
## TESTCASE:    remote NetLabel IPv4, mac success (eq)
    + recvmsg \
	mlsop=eq expres=success \
	host=remote type=netlabel op=sendrand_udp ipv=ipv4 port=$tst_port2 \
	'$ipv $port'
## TESTCASE:    remote NetLabel IPv4, mac failure (incomp)
    + recvmsg \
	mlsop=incomp expres=fail err=EINTR \
	augrokfunc=augrok_default_inbound_rej \
	host=remote type=netlabel op=sendrand_udp ipv=ipv4 port=$tst_port2 \
	'$ipv $port'
## TESTCASE:    remote NetLabel IPv4, mac success (dom)
    + recvmsg \
	mlsop=dom expres=success \
	augrokfunc=augrok_default \
	host=remote type=netlabel op=sendrand_udp ipv=ipv4 port=$tst_port2 \
	'$ipv $port'
## TESTCASE:    remote NetLabel IPv4, mac failure (domby)
    + recvmsg \
	mlsop=domby expres=fail err=EINTR \
	augrokfunc=augrok_default_inbound_rej \
	host=remote type=netlabel op=sendrand_udp ipv=ipv4 port=$tst_port2 \
	'$ipv $port'
## TESTCASE:    local IPsec IPv4, mac success (eq)
    + recvmsg \
	mlsop=eq expres=success \
	host=local type=ipsec op=sendrand_udp ipv=ipv4 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    local IPsec IPv4, mac failure (incomp)
    + recvmsg \
	mlsop=incomp expres=fail err=EINTR \
	augrokfunc=augrok_default_inbound_rej \
	host=local type=ipsec op=sendrand_udp ipv=ipv4 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    local IPsec IPv4, mac success (dom)
    + recvmsg \
	mlsop=dom expres=success err=EINTR \
	augrokfunc=augrok_default \
	host=local type=ipsec op=sendrand_udp ipv=ipv4 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    local IPsec IPv4, mac failure (domby)
    + recvmsg \
	mlsop=domby expres=fail err=EINTR \
	host=local type=ipsec op=sendrand_udp ipv=ipv4 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    remote IPsec IPv4, mac success (eq)
    + recvmsg \
	mlsop=eq expres=success \
	host=remote type=ipsec op=sendrand_udp ipv=ipv4 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    remote IPsec IPv4, mac failure (incomp)
    + recvmsg \
	mlsop=incomp expres=fail err=EINTR \
	augrokfunc=augrok_default_inbound_rej \
	host=remote type=ipsec op=sendrand_udp ipv=ipv4 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    remote IPsec IPv4, mac success (dom)
    + recvmsg \
	mlsop=dom expres=success \
	augrokfunc=augrok_default \
	host=remote type=ipsec op=sendrand_udp ipv=ipv4 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    remote IPsec IPv4, mac failure (domby)
    + recvmsg \
	mlsop=domby expres=fail err=EINTR \
	host=remote type=ipsec op=sendrand_udp ipv=ipv4 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    local IPsec IPv6, mac success (eq)
    + recvmsg \
	mlsop=eq expres=success \
	host=local type=ipsec op=sendrand_udp ipv=ipv6 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    local IPsec IPv6, mac failure (incomp)
    + recvmsg \
	mlsop=incomp expres=fail err=EINTR \
	augrokfunc=augrok_default_inbound_rej \
	host=local type=ipsec op=sendrand_udp ipv=ipv6 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    local IPsec IPv6, mac success (dom)
    + recvmsg \
	mlsop=dom expres=success \
	augrokfunc=augrok_default \
	host=local type=ipsec op=sendrand_udp ipv=ipv6 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    local IPsec IPv6, mac failure (domby)
    + recvmsg \
	mlsop=domby expres=fail err=EINTR \
	host=local type=ipsec op=sendrand_udp ipv=ipv6 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    remote IPsec IPv6, mac success (eq)
    + recvmsg \
	mlsop=eq expres=success \
	host=remote type=ipsec op=sendrand_udp ipv=ipv6 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    remote IPsec IPv6, mac failure (incomp)
    + recvmsg \
	mlsop=incomp expres=fail err=EINTR \
	augrokfunc=augrok_default_inbound_rej \
	host=remote type=ipsec op=sendrand_udp ipv=ipv6 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    remote IPsec IPv6, mac success (dom)
    + recvmsg \
	mlsop=dom expres=success \
	augrokfunc=augrok_default \
	host=remote type=ipsec op=sendrand_udp ipv=ipv6 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    remote IPsec IPv6, mac failure (domby)
    + recvmsg \
	mlsop=domby expres=fail err=EINTR \
	host=remote type=ipsec op=sendrand_udp ipv=ipv6 port=$tst_port3 \
	'$ipv $port'
fi

## SYSCALL:     recvmmsg()
## PURPOSE:
## Verify that incoming traffic is only allowed when the sensitivity label of
## the incoming packet dominates (is greater than or equal to) the receiving
## process.  These test cases
## make use of a remote test driver to generate traffic from the remote node
## to the host under test, see the setup_default() function above for details
## on configuring the remote test driver.  In addition to sanity checks using
## unlabled networking the test cases below test NetLabel and labeled IPsec
## labeled packets where the receiving process is equal to (mlsop=eq), is
## incomparable to (mlsop=incomp), dominates (mlsop=dom), and is dominated by
## (mlsop=domby) the remote test driver and the resulting network traffic.
## The test procedure is as follows:
##  1. Configure the test driver to generate traffic at a specific sensitivity
##     label after a delay
##  2. Configure the audit subsystem to watch for the syscall record
##  3. Execute the test case on the local system and verify the result
##  4. Check the audit log for the correct syscall result and in the case of
##     failure check for SELinux generated audit records indicating that
##     incoming traffic was rejected
if [[ $HOSTTYPE == x86_64 ]]; then
## TESTCASE:    local unlabeled IPv4, sanity check
    + recvmmsg \
        mlsop=eq expres=success \
        host=local type=unlabeled op=sendrand_udp ipv=ipv4 port=$tst_port1 \
        '$ipv $port'
## TESTCASE:    local unlabeled IPv6, sanity check
    + recvmmsg \
        mlsop=eq expres=success \
        host=local type=unlabeled op=sendrand_udp ipv=ipv6 port=$tst_port1 \
        '$ipv $port'
## TESTCASE:    remote unlabeled IPv4, sanity check
    + recvmmsg \
        mlsop=eq expres=success \
        host=remote type=unlabeled op=sendrand_udp ipv=ipv4 port=$tst_port1 \
        '$ipv $port'
## TESTCASE:    remote unlabeled IPv6, sanity check
    + recvmmsg \
        mlsop=eq expres=success \
        host=remote type=unlabeled op=sendrand_udp ipv=ipv6 port=$tst_port1 \
        '$ipv $port'
    if [[ $PPROFILE == lspp ]]; then
## TESTCASE:    local NetLabel IPv4, mac success (eq)
        + recvmmsg \
	    mlsop=eq expres=success \
	    host=local type=netlabel op=sendrand_udp ipv=ipv4 port=$tst_port2 \
	    '$ipv $port'
## TESTCASE:    local NetLabel IPv4, mac failure (incomp)
        + recvmmsg \
	    mlsop=incomp expres=fail err=EINTR \
	    augrokfunc=augrok_default_inbound_rej \
	    host=local type=netlabel op=sendrand_udp ipv=ipv4 port=$tst_port2 \
	    '$ipv $port'
## TESTCASE:    local NetLabel IPv4, mac success (dom)
        + recvmmsg \
	    mlsop=dom expres=success \
	    augrokfunc=augrok_default \
	    host=local type=netlabel op=sendrand_udp ipv=ipv4 port=$tst_port2 \
	    '$ipv $port'
## TESTCASE:    local NetLabel IPv4, mac failure (domby)
        + recvmmsg \
	    mlsop=domby expres=fail err=EINTR \
	    augrokfunc=augrok_default_inbound_rej \
	    host=local type=netlabel op=sendrand_udp ipv=ipv4 port=$tst_port2 \
	    '$ipv $port'
## TESTCASE:    remote NetLabel IPv4, mac success (eq)
        + recvmmsg \
	    mlsop=eq expres=success \
	    host=remote type=netlabel op=sendrand_udp ipv=ipv4 port=$tst_port2 \
	    '$ipv $port'
## TESTCASE:    remote NetLabel IPv4, mac failure (incomp)
        + recvmmsg \
	    mlsop=incomp expres=fail err=EINTR \
	    augrokfunc=augrok_default_inbound_rej \
	    host=remote type=netlabel op=sendrand_udp ipv=ipv4 port=$tst_port2 \
	    '$ipv $port'
## TESTCASE:    remote NetLabel IPv4, mac success (dom)
        + recvmmsg \
	    mlsop=dom expres=success \
	    augrokfunc=augrok_default \
	    host=remote type=netlabel op=sendrand_udp ipv=ipv4 port=$tst_port2 \
	    '$ipv $port'
## TESTCASE:    remote NetLabel IPv4, mac failure (domby)
        + recvmmsg \
	    mlsop=domby expres=fail err=EINTR \
	    augrokfunc=augrok_default_inbound_rej \
	    host=remote type=netlabel op=sendrand_udp ipv=ipv4 port=$tst_port2 \
	    '$ipv $port'
## TESTCASE:    local IPsec IPv4, mac success (eq)
        + recvmmsg \
	    mlsop=eq expres=success \
	    host=local type=ipsec op=sendrand_udp ipv=ipv4 port=$tst_port3 \
	    '$ipv $port'
## TESTCASE:    local IPsec IPv4, mac failure (incomp)
        + recvmmsg \
	    mlsop=incomp expres=fail err=EINTR \
	    augrokfunc=augrok_default_inbound_rej \
	    host=local type=ipsec op=sendrand_udp ipv=ipv4 port=$tst_port3 \
	    '$ipv $port'
## TESTCASE:    local IPsec IPv4, mac success (dom)
        + recvmmsg \
	    mlsop=dom expres=success err=EINTR \
	    augrokfunc=augrok_default \
	    host=local type=ipsec op=sendrand_udp ipv=ipv4 port=$tst_port3 \
	    '$ipv $port'
## TESTCASE:    local IPsec IPv4, mac failure (domby)
        + recvmmsg \
	    mlsop=domby expres=fail err=EINTR \
	    host=local type=ipsec op=sendrand_udp ipv=ipv4 port=$tst_port3 \
	    '$ipv $port'
## TESTCASE:    remote IPsec IPv4, mac success (eq)
        + recvmmsg \
	    mlsop=eq expres=success \
	    host=remote type=ipsec op=sendrand_udp ipv=ipv4 port=$tst_port3 \
	    '$ipv $port'
## TESTCASE:    remote IPsec IPv4, mac failure (incomp)
        + recvmmsg \
	    mlsop=incomp expres=fail err=EINTR \
	    augrokfunc=augrok_default_inbound_rej \
	    host=remote type=ipsec op=sendrand_udp ipv=ipv4 port=$tst_port3 \
	    '$ipv $port'
## TESTCASE:    remote IPsec IPv4, mac success (dom)
        + recvmmsg \
	    mlsop=dom expres=success \
	    augrokfunc=augrok_default \
	    host=remote type=ipsec op=sendrand_udp ipv=ipv4 port=$tst_port3 \
	    '$ipv $port'
## TESTCASE:    remote IPsec IPv4, mac failure (domby)
        + recvmmsg \
	    mlsop=domby expres=fail err=EINTR \
	    host=remote type=ipsec op=sendrand_udp ipv=ipv4 port=$tst_port3 \
	    '$ipv $port'
## TESTCASE:    local IPsec IPv6, mac success (eq)
        + recvmmsg \
	    mlsop=eq expres=success \
	    host=local type=ipsec op=sendrand_udp ipv=ipv6 port=$tst_port3 \
	    '$ipv $port'
## TESTCASE:    local IPsec IPv6, mac failure (incomp)
        + recvmmsg \
	    mlsop=incomp expres=fail err=EINTR \
	    augrokfunc=augrok_default_inbound_rej \
	    host=local type=ipsec op=sendrand_udp ipv=ipv6 port=$tst_port3 \
	    '$ipv $port'
## TESTCASE:    local IPsec IPv6, mac success (dom)
        + recvmmsg \
	    mlsop=dom expres=success \
	    augrokfunc=augrok_default \
	    host=local type=ipsec op=sendrand_udp ipv=ipv6 port=$tst_port3 \
	    '$ipv $port'
## TESTCASE:    local IPsec IPv6, mac failure (domby)
        + recvmmsg \
	    mlsop=domby expres=fail err=EINTR \
	    host=local type=ipsec op=sendrand_udp ipv=ipv6 port=$tst_port3 \
	    '$ipv $port'
## TESTCASE:    remote IPsec IPv6, mac success (eq)
        + recvmmsg \
	    mlsop=eq expres=success \
	    host=remote type=ipsec op=sendrand_udp ipv=ipv6 port=$tst_port3 \
	    '$ipv $port'
## TESTCASE:    remote IPsec IPv6, mac failure (incomp)
        + recvmmsg \
	    mlsop=incomp expres=fail err=EINTR \
	    augrokfunc=augrok_default_inbound_rej \
	    host=remote type=ipsec op=sendrand_udp ipv=ipv6 port=$tst_port3 \
	    '$ipv $port'
## TESTCASE:    remote IPsec IPv6, mac success (dom)
        + recvmmsg \
	    mlsop=dom expres=success \
	    augrokfunc=augrok_default \
	    host=remote type=ipsec op=sendrand_udp ipv=ipv6 port=$tst_port3 \
	    '$ipv $port'
## TESTCASE:    remote IPsec IPv6, mac failure (domby)
        + recvmmsg \
	    mlsop=domby expres=fail err=EINTR \
	    host=remote type=ipsec op=sendrand_udp ipv=ipv6 port=$tst_port3 \
	    '$ipv $port'
    fi
fi

## SYSCALL:     sendmsg()
## PURPOSE:
## Verify that outgoing traffic is only allowed when the sensitivity label
## of the sending process is equal to the sensitivity label on the IPsec SA
## to process/transform the traffic/packet.  These test cases make use of a
## remote test driver to receive traffic from the host under test, see the
## setup_default() function above for details on configuring the remote test
## driver.  In addition to sanity checks using unlabeled networking the test
## cases below test labeled IPsec connections where the sending process is
## equal to (mlsop=eq), is incomparable to (mlsop=incomp),
## dominates (mlsop=dom), and is dominated by (mlsop=domby) the IPsec SA.
## The test procedure is as follows:
##  1. Configure the test driver to accept new connections at a specific
##     sensitivity label
##  2. Configure the audit subsystem to watch for the syscall record
##  3. Execute the test case on the local system and verify the result
##  4. Check the audit log for the correct syscall result
## TESTCASE:    local unlabeled IPv4, sanity check
+ sendmsg \
    mlsop=eq expres=success \
    host=local type=unlabeled op=recv_udp ipv=ipv4 port=$tst_port1 \
    '$host_remote $port'
## TESTCASE:    local unlabeled IPv6, sanity check
+ sendmsg \
    mlsop=eq expres=success \
    host=local type=unlabeled op=recv_udp ipv=ipv6 port=$tst_port1 \
    '$host_remote $port'
## TESTCASE:    remote unlabeled IPv4, sanity check
+ sendmsg \
    mlsop=eq expres=success \
    host=remote type=unlabeled op=recv_udp ipv=ipv4 port=$tst_port1 \
    '$host_remote $port'
## TESTCASE:    remote unlabeled IPv6, sanity check
+ sendmsg \
    mlsop=eq expres=success \
    host=remote type=unlabeled op=recv_udp ipv=ipv6 port=$tst_port1 \
    '$host_remote $port'

## SYSCALL:     sendto()
## PURPOSE:
## Verify that outgoing traffic is only allowed when the sensitivity label
## of the sending process is equal to the sensitivity label on the IPsec SA
## to process/transform the traffic/packet.  These test cases make use of a
## remote test driver to receive traffic from the host under test, see the
## setup_default() function above for details on configuring the remote test
## driver.  In addition to sanity checks using unlabeled networking the test
## cases below test labeled IPsec connections where the sending process is
## equal to (mlsop=eq), is incomparable to (mlsop=incomp),
## dominates (mlsop=dom), and is dominated by (mlsop=domby) the IPsec SA.
## The test procedure is as follows:
##  1. Configure the test driver to accept new connections at a specific
##     sensitivity label
##  2. Configure the audit subsystem to watch for the syscall record
##  3. Execute the test case on the local system and verify the result
##  4. Check the audit log for the correct syscall result
## TESTCASE:    local unlabeled IPv4, sanity check
+ sendto \
    mlsop=eq expres=success \
    host=local type=unlabeled op=recv_udp ipv=ipv4 port=$tst_port1 \
    '$host_remote $port'
## TESTCASE:    local unlabeled IPv6, sanity check
+ sendto \
    mlsop=eq expres=success \
    host=local type=unlabeled op=recv_udp ipv=ipv6 port=$tst_port1 \
    '$host_remote $port'
## TESTCASE:    remote unlabeled IPv4, sanity check
+ sendto \
    mlsop=eq expres=success \
    host=remote type=unlabeled op=recv_udp ipv=ipv4 port=$tst_port1 \
    '$host_remote $port'
## TESTCASE:    remote unlabeled IPv6, sanity check
+ sendto \
    mlsop=eq expres=success \
    host=remote type=unlabeled op=recv_udp ipv=ipv6 port=$tst_port1 \
    '$host_remote $port'

## SYSCALL:     read()
## PURPOSE:
## Verify that incoming traffic is only allowed when the sensitivity label of
## the incoming packet dominates (is greater than or equal to) the receiving
## process.  These test cases
## make use of a remote test driver to generate traffic from the remote node
## to the host under test, see the setup_default() function above for details
## on configuring the remote test driver.  In addition to sanity checks using
## unlabled networking the test cases below test NetLabel and labeled IPsec
## labeled packets where the receiving process is equal to (mlsop=eq), is
## incomparable to (mlsop=incomp), dominates (mlsop=dom), and is dominated by
## (mlsop=domby) the remote test driver and the resulting network traffic.
## The test procedure is as follows:
##  1. Configure the test driver to generate traffic at a specific sensitivity
##     label after a delay
##  2. Configure the audit subsystem to watch for the syscall record
##  3. Execute the test case on the local system and verify the result
##  4. Check the audit log for the correct syscall result and in the case of
##     failure check for SELinux generated audit records indicating that
##     incoming traffic was rejected
## TESTCASE:    local unlabeled IPv4, sanity check
+ read \
    mlsop=eq expres=success \
    auwatchfunc=auwatch_syscall augrokfunc=augrok_syscall \
    host=local type=unlabeled op=sendrand_udp ipv=ipv4 port=$tst_port1 \
    '$ipv $port'
## TESTCASE:    local unlabeled IPv6, sanity check
+ read \
    mlsop=eq expres=success \
    auwatchfunc=auwatch_syscall augrokfunc=augrok_syscall \
    host=local type=unlabeled op=sendrand_udp ipv=ipv6 port=$tst_port1 \
    '$ipv $port'
## TESTCASE:    remote unlabeled IPv4, sanity check
+ read \
    mlsop=eq expres=success \
    auwatchfunc=auwatch_syscall augrokfunc=augrok_syscall \
    host=remote type=unlabeled op=sendrand_udp ipv=ipv4 port=$tst_port1 \
    '$ipv $port'
## TESTCASE:    remote unlabeled IPv6, sanity check
+ read \
    mlsop=eq expres=success \
    auwatchfunc=auwatch_syscall augrokfunc=augrok_syscall \
    host=remote type=unlabeled op=sendrand_udp ipv=ipv6 port=$tst_port1 \
    '$ipv $port'
if [[ $PPROFILE == lspp ]]; then
## TESTCASE:    local NetLabel IPv4, mac success (eq)
    + read \
	mlsop=eq expres=success \
	auwatchfunc=auwatch_syscall augrokfunc=augrok_syscall \
	host=local type=netlabel op=sendrand_udp ipv=ipv4 port=$tst_port2 \
	'$ipv $port'
## TESTCASE:    local NetLabel IPv4, mac failure (incomp)
    + read \
	mlsop=incomp expres=fail err=EINTR \
	auwatchfunc=auwatch_syscall augrokfunc=augrok_syscall_inbound_rej \
	host=local type=netlabel op=sendrand_udp ipv=ipv4 port=$tst_port2 \
	'$ipv $port'
## TESTCASE:    local NetLabel IPv4, mac success (dom)
    + read \
	mlsop=dom expres=success \
	auwatchfunc=auwatch_syscall augrokfunc=augrok_syscall \
	host=local type=netlabel op=sendrand_udp ipv=ipv4 port=$tst_port2 \
	'$ipv $port'
## TESTCASE:    local NetLabel IPv4, mac failure (domby)
    + read \
	mlsop=domby expres=fail err=EINTR \
	auwatchfunc=auwatch_syscall augrokfunc=augrok_syscall_inbound_rej \
	host=local type=netlabel op=sendrand_udp ipv=ipv4 port=$tst_port2 \
	'$ipv $port'
## TESTCASE:    remote NetLabel IPv4, mac success (eq)
    + read \
	mlsop=eq expres=success \
	auwatchfunc=auwatch_syscall augrokfunc=augrok_syscall \
	host=remote type=netlabel op=sendrand_udp ipv=ipv4 port=$tst_port2 \
	'$ipv $port'
## TESTCASE:    remote NetLabel IPv4, mac failure (incomp)
    + read \
	mlsop=incomp expres=fail err=EINTR \
	auwatchfunc=auwatch_syscall augrokfunc=augrok_syscall_inbound_rej \
	host=remote type=netlabel op=sendrand_udp ipv=ipv4 port=$tst_port2 \
	'$ipv $port'
## TESTCASE:    remote NetLabel IPv4, mac success (dom)
    + read \
	mlsop=dom expres=success \
	auwatchfunc=auwatch_syscall augrokfunc=augrok_syscall \
	host=remote type=netlabel op=sendrand_udp ipv=ipv4 port=$tst_port2 \
	'$ipv $port'
## TESTCASE:    remote NetLabel IPv4, mac failure (domby)
    + read \
	mlsop=domby expres=fail err=EINTR \
	auwatchfunc=auwatch_syscall augrokfunc=augrok_syscall_inbound_rej \
	host=remote type=netlabel op=sendrand_udp ipv=ipv4 port=$tst_port2 \
	'$ipv $port'
## TESTCASE:    local IPsec IPv4, mac success (eq)
    + read \
	mlsop=eq expres=success \
	auwatchfunc=auwatch_syscall augrokfunc=augrok_syscall \
	host=local type=ipsec op=sendrand_udp ipv=ipv4 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    local IPsec IPv4, mac failure (incomp)
    + read \
	mlsop=incomp expres=fail err=EINTR \
	auwatchfunc=auwatch_syscall augrokfunc=augrok_syscall_inbound_rej \
	host=local type=ipsec op=sendrand_udp ipv=ipv4 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    local IPsec IPv4, mac success (dom)
    + read \
	mlsop=dom expres=success \
	auwatchfunc=auwatch_syscall augrokfunc=augrok_syscall \
	host=local type=ipsec op=sendrand_udp ipv=ipv4 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    local IPsec IPv4, mac failure (domby)
    + read \
	mlsop=domby expres=fail err=EINTR \
	auwatchfunc=auwatch_syscall augrokfunc=augrok_syscall \
	host=local type=ipsec op=sendrand_udp ipv=ipv4 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    remote IPsec IPv4, mac success (eq)
    + read \
	mlsop=eq expres=success \
	auwatchfunc=auwatch_syscall augrokfunc=augrok_syscall \
	host=remote type=ipsec op=sendrand_udp ipv=ipv4 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    remote IPsec IPv4, mac failure (incomp)
    + read \
	mlsop=incomp expres=fail err=EINTR \
	auwatchfunc=auwatch_syscall augrokfunc=augrok_syscall_inbound_rej \
	host=remote type=ipsec op=sendrand_udp ipv=ipv4 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    remote IPsec IPv4, mac success (dom)
    + read \
	mlsop=dom expres=success \
	auwatchfunc=auwatch_syscall augrokfunc=augrok_syscall \
	host=remote type=ipsec op=sendrand_udp ipv=ipv4 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    remote IPsec IPv4, mac failure (domby)
    + read \
	mlsop=domby expres=fail err=EINTR \
	auwatchfunc=auwatch_syscall augrokfunc=augrok_syscall \
	host=remote type=ipsec op=sendrand_udp ipv=ipv4 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    local IPsec IPv6, mac success (eq)
    + read \
	mlsop=eq expres=success \
	auwatchfunc=auwatch_syscall augrokfunc=augrok_syscall \
	host=local type=ipsec op=sendrand_udp ipv=ipv6 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    local IPsec IPv6, mac failure (incomp)
    + read \
	mlsop=incomp expres=fail err=EINTR \
	auwatchfunc=auwatch_syscall augrokfunc=augrok_syscall_inbound_rej \
	host=local type=ipsec op=sendrand_udp ipv=ipv6 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    local IPsec IPv6, mac success (dom)
    + read \
	mlsop=dom expres=success \
	auwatchfunc=auwatch_syscall augrokfunc=augrok_syscall \
	host=local type=ipsec op=sendrand_udp ipv=ipv6 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    local IPsec IPv6, mac failure (domby)
    + read \
	mlsop=domby expres=fail err=EINTR \
	auwatchfunc=auwatch_syscall augrokfunc=augrok_syscall \
	host=local type=ipsec op=sendrand_udp ipv=ipv6 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    remote IPsec IPv6, mac success (eq)
    + read \
	mlsop=eq expres=success \
	auwatchfunc=auwatch_syscall augrokfunc=augrok_syscall \
	host=remote type=ipsec op=sendrand_udp ipv=ipv6 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    remote IPsec IPv6, mac failure (incomp)
    + read \
	mlsop=incomp expres=fail err=EINTR \
	auwatchfunc=auwatch_syscall augrokfunc=augrok_syscall_inbound_rej \
	host=remote type=ipsec op=sendrand_udp ipv=ipv6 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    remote IPsec IPv6, mac success (dom)
    + read \
	mlsop=dom expres=success err=EINTR \
	auwatchfunc=auwatch_syscall augrokfunc=augrok_syscall \
	host=remote type=ipsec op=sendrand_udp ipv=ipv6 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    remote IPsec IPv6, mac failure (domby)
    + read \
	mlsop=domby expres=fail err=EINTR \
	auwatchfunc=auwatch_syscall augrokfunc=augrok_syscall \
	host=remote type=ipsec op=sendrand_udp ipv=ipv6 port=$tst_port3 \
	'$ipv $port'
fi
