#!/bin/bash
# =============================================================================
# (c) Copyright Hewlett-Packard Development Company, L.P., 2005, 2006, 2007
#
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of version 2 the GNU General Public License as
#   published by the Free Software Foundation.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
# =============================================================================

######################################################################
# global variables
######################################################################

tst_port1=4100				# port for unlabeled traffic
tst_port2=4200				# port for netlabel traffic
tst_port3=4300				# port for labeled ipsec traffic

######################################################################
# helper functions
######################################################################

#
# get_test_domain - Get the SELinux domain for the test applet
#
# INPUT
# $1 : the labeling type
# $2 : the host type
#
# OUTPUT
# Writes the SELinux domain to stdout
#
# DESCRIPTION
# This function determines the correct SELinux domain to use for the test
# applet based on the given labeling type.
#
function get_test_domain {
    declare type_arg=$1 host_arg=$2

    case $PPROFILE-$host_arg in
	lspp-*|capp-remote)
            case $type_arg in
		netlabel)
		    echo "lspp_test_netlabel_t"
		    ;;
		ipsec)
		    echo "lspp_test_ipsec_t"
		    ;;
		unlabeled)
		    echo "lspp_test_generic_t"
		    ;;
		*)
		    exit_fail "invalid test argument"
	            ;;
	    esac
	    ;;
	capp-local)
	    case $type_arg in
	        *)
		    echo "unconfined_t"
		    ;;
	    esac
	    ;;
    esac
}

#
# get_label_subj - Get the subject's sensitivity label for the test run
#
# INPUT
# $1 : the MLS "op"
#
# OUPUT
# Writes the subject's untranslated sensivity label to stdout
#
# DESCRIPTION
# This function determines the subject's sensitivity label for the test run
# based on the MLS "op".  The MLS "op" specifies if the subject is to be equal
# to (eq), incomparable to (incomp), dominate (dom), or be dominated by (domby)
# the object.  These MLS "op" definitions assume the Bell-LaPadula based MLS
# constraints in use by the SELinux MLS policy derived from the SELinux
# Reference Policy.
#
function get_label_subj {
    declare mlsop_arg=$1

    case $PPROFILE in
	lspp)
            case $mlsop_arg in
		eq)
		    echo "SystemLow"
		    ;;
		dom)
		    echo "NetHigh"
		    ;;
		domby)
		    echo "NetS1"
		    ;;
		incomp)
		    echo "NetIncomp1"
		    ;;
		*)
		    exit_fail "invalid test argument"
		    ;;
	    esac
	    ;;
	capp)
            case $mlsop_arg in
		*)
		    # in targeted policy (the likely policy for CAPP) the s0
		    # sensitivity label is translated into a NULL string so we
		    # have to use the untranslated sensitivity label
		    echo "s0"
		    ;;
	    esac
	    ;;
    esac
}

#
# get_label_obj - Get the object's sensitivity label for the test run
#
# INPUT
# $1 : the MLS "op"
#
# OUPUT
# Writes the object's untranslated sensivity label to stdout
#
# DESCRIPTION
# This function determines the objects's sensitivity label for the test run
# based on the MLS "op".  The MLS "op" specifies if the subject is to be equal
# to (eq), incomparable to (incomp), dominate (dom), or be dominated by (domby)
# the object.  These MLS "op" definitions assume the Bell-LaPadula based MLS
# constraints in use by the SELinux MLS policy derived from the SELinux
# Reference Policy.
#
function get_label_obj {
    declare mlsop_arg=$1

    case $PPROFILE in
	lspp)
            case $mlsop_arg in
		eq)
		    echo "SystemLow"
		    ;;
		dom)
		    echo "NetS1"
		    ;;
		domby)
		    echo "NetHigh"
		    ;;
		incomp)
		    echo "NetIncomp2"
		    ;;
		*)
		    exit_fail "invalid test argument"
		    ;;
	    esac
	    ;;
	capp)
            case $mlsop_arg in
		*)
		    # in targeted policy (the likely policy for CAPP) the s0
		    # sensitivity label is translated into a NULL string so we
		    # have to use the untranslated sensitivity label
		    echo "s0"
		    ;;
	    esac
	    ;;
    esac
}

#
# verify_netlabel - Verify that NetLabel is properly configured on the system
#
# INPUT
# none
#
# OUTPUT
# Returns true if NetLabel is configured properly, false otherwise
#
# DESCRIPTION
# This function performs some simple checks to verify that the local kernel's
# NetLabel subsystem is configured correctly for the test run.  If the function
# determines the kernel is configured correctly it returns true, otherwise it
# returns false.
#
function verify_netlabel {
    declare iter

    for iter in $(netlabelctl map list); do
	[[ "$(sed 's/domain://;s/,.*//;s/\"//g' <<< $iter)" == \
	    "lspp_test_netlabel_t" ]] && return 0
    done

    return 1
}

#
# verify_ipsec - Verify that IPsec is properly configured on the system
#
# INPUT
# none
#
# OUTPUT
# Returns true if IPsec is configured properly, false otherwise
#
# DESCRIPTION
# This function performs some simple checks to verify that the local system's
# IPsec subsystem is configured correctly for the test run.  If the function
# determines the system is configured correctly it returns true, otherwise it
# returns false.
#
function verify_ipsec {
    local addr= i=
    ps -C pluto &> /dev/null || return 1
    for addr in "$ipsec_ipv4_remote" "$ipsec_ipv6_remote"; do
        for ((i=0;i<10;i++)); do
            ip xfrm policy list | grep -q "$addr" && break
            sleep 0.5
        done
        [ "$i" -lt 10 ] || return 1
    done
    return 0
}

######################################################################
# defaults
######################################################################

#
# setup_default - Setup the remote test driver
#
# INPUT
# none
#
# OUTPUT
# none
#
# DESCRIPTION
# All of the network tests in this file need to either send data to a remote
# node or receive data from a remote node; this function does the required
# setup to initialize the remote node based on the individual test case.  This
# function works for both "local" (localhost) and "remote" (non-localhost)
# host types using both IPv4 and IPv6.  This function determines the setup
# needed by the test using the "op", "host", "type", "mlsop", "ipv", and
# "port" named arguments as given on the test command line.  On error the
# function calls exit_error() which marks the test case as resulting in an
# error.
#
function setup_default {
    declare cmd_str remote_obj ipf s

    ipf="${ipv:+-${ipv#ipv}}"  # ipv flag, -4 or -6 or empty

    s=$(send_ns $ipf -S "$host") || exit_error
    append_cleanup "send_ns $ipf -s \"$s\" -K \"$host\""

    remote_obj="$(get_label_obj $mlsop)"
    cmd_str="lock;"
    cmd_str+="setsockcreatecon,system_u:system_r:$(get_test_domain $type $host):$remote_obj;"
    send_ns -t 600 $ipf -s "$s" "$host" "$cmd_str" || exit_error
    check_ns $ipf -s "$s" "$host" -- '0 .*' || exit_error

    case $op in
        sendrand_tcp)
            send_ns $ipf -s "$s" "$host" "sendx,tcp,$port" || exit_error ;;
        sendrand_udp)
            send_ns $ipf -s "$s" "$host" "sendx,udp,$port" || exit_error ;;
        recv_tcp)
            port=$(send_ns $ipf -s "$s" "$host" "recvx,tcp") || exit_error ;;
        recv_udp)
            port=$(send_ns $ipf -s "$s" "$host" "recvx,udp") || exit_error ;;
        *)
            exit_fail "invalid test argument: $op" ;;
    esac
}

#
# augrok_default - Check for a syscall/socketcall audit record
#
# INPUT
# none
#
# OUTPUT
# Returns true if the syscall/socketcall audit record is found, false otherwise
#
# DESCRIPTION
# This function checks for a syscall or socketcall audit record which matches
# the expected result of the test case.  The heavy lifting of sorting through
# the audit log is handled by augrok, this function is only concerned with
# generating the correct augrok arguments.  The augrok command line is built
# up through the use of variables created by the run_test() function and other
# test harness functions based on the individual test case.
#
function augrok_default {
    declare expres_audit
    declare params
    declare i

    # convert the test result expression into something usable by audit
    if [[ "$expres" == "success" ]]; then
	expres_audit="yes"
    else
	expres_audit="no"
    fi

    # we do this multiple times on failure to give the audit records time to
    # appear in the log (recent distros can lag in recording audit records)
    for (( i=0; i<2; i++ )); do
        # use actual socketcall op name ("accept", "bind", ..) as a0
        if [[ "$syscall" == "socketcall" ]]; then
            augrok --seek=$log_mark -m1 type==SYSCALL syscall=$syscall \
                a0=$(get_sockcall_num_hex "$socketcall_op") \
                success=$expres_audit exit=$exitval \
                pid=$pid auid=$(</proc/self/loginuid) \
                uid=$uid euid=$euid suid=$suid fsuid=$fsuid \
                gid=$gid egid=$egid sgid=$sgid fsgid=$fsgid \
                "$@"
            [ $? -eq 0 ] && return 0
        else
            augrok --seek=$log_mark -m1 type==SYSCALL syscall=$syscall \
                success=$expres_audit exit=$exitval \
                pid=$pid auid=$(</proc/self/loginuid) \
                uid=$uid euid=$euid suid=$suid fsuid=$fsuid \
                gid=$gid egid=$egid sgid=$sgid fsgid=$fsgid \
                "$@"
            [ $? -eq 0 ] && return 0
        fi
        sleep 5
    done
    return 1
}

#
# auwatch_default - Add a audit watch for the desired syscall/socketcall
#
# INPUT
# none
#
# OUTPUT
# Returns true if the syscall/socketcall watch was created, false otherwise
#
# DESCRIPTION
# This function adds a syscall or socketcall audit watch so that the desired
# syscall or socketcall accesses are recorded by the audit subsystem.  The
# variables used below in the auditctl command line are created by the
# run_test() function and other test harness functions based on the individual
# test case.
#
function auwatch_default {
    declare opnum

    # use actual socketcall op name ("accept", "bind", ..) as a0
    if [[ "$syscall" == "socketcall" ]]; then
        opnum=$(get_sockcall_num "$socketcall_op")
        auditctl -a exit,always ${MODE:+-F arch=b$MODE} \
            -S $syscall -F a0=$opnum || exit_error
        prepend_cleanup "auditctl -d exit,always ${MODE:+-F arch=b$MODE} \
            -S $syscall -F a0=$opnum"
    else
        auditctl -a exit,always ${MODE:+-F arch=b$MODE} \
            -S $syscall || exit_error
        prepend_cleanup "auditctl -d exit,always ${MODE:+-F arch=b$MODE} \
            -S $syscall"
    fi
}

######################################################################
# run.bash overrides
######################################################################

# Rename the original run.bash + function to run+ and create our own + function
# that generates a tag for the test based on the named parameters.

#
# + - Generate a unique tag for each test case and run the default "+" function
#
# INPUT
# $@ : test command line
#
# OUTPUT
# none
#
# DESCRIPTION
# This function acts as a wrapper for the original "+" function which is
# responsibile for running each test case shown at the bottom of this file.
# This wrapper function is necessary to automatically generate a unique tag for
# each test case based on it's named arguments.  This tag is then used as an
# additional named argument for the default "+" function.
#
eval "function run+ $(type + | sed '1,2d')"
function + {
    declare test=$1 tag # make sure it's not inherited from caller
    shift
    eval "$(parse_named "$@")" || exit_error

    if sc_is_relevant "$test"; then
        if [[ -z $tag ]]; then
            # extract the named args that identify a unique testcase
            run+ "$test" \
                tag="${test}__${host}_${type}_${ipv}_${expres}_subj_${mlsop}_obj" \
                "$@"
        else
            # use tag supplied in run.conf
            run+ "$test" "$@"
        fi
    fi

    # if $test (syscall) has a socketcall counterpart, add it for testing
    if sc_is_relevant "socketcall" && is_socketcall_op "$test"; then
        if [[ -z $tag ]]; then
            run+ socketcall \
                tag="socketcall_${test}__${host}_${type}_${ipv}_${expres}_subj_${mlsop}_obj" \
                "$test" "$@"
        else
            run+ socketcall "$test" "$@"
        fi
    fi
}

#
# show_test - Display the test case details
#
# INPUT
# $@ : test command line
#
# OUTPUT
# Writes the test case details to stdout
#
# DESCRIPTION
# This function reads in the entire test case command line and depending on
# the verbosity of the test harness either the entire command line is dumped
# to stdout or just the tag named variable as generated by the +() function
# defined in this file.  All output is handled by the fmt_test() function
# which is defined as by the test harness.  This function was overloaded
# because of the special handling for the tag named variable.
#
function show_test {
    if ! $opt_verbose; then
	declare tag # make sure it's not inherited from caller
	eval "$(parse_named "$@")" || exit_error
	[[ -n $tag ]] && set -- "$tag"
    fi
    fmt_test "[$TESTNUM]" "$@"
}


######################################################################
# local overrides
######################################################################

#
# augrok_default_inbound_rej - Check for denied incoming connections
#
# INPUT
# none
#
# OUTPUT
# Returns true if both the syscall/socketcall audit record and connection
# denial audit records are present in the audit log
#
# DESCRIPTION
# This function calls the augrok_default() function to check if the correct
# syscall/socket audit record is present; if it is then it checks to see if
# SELinux has issued any AVC denial messages due to rejecting an incoming
# connection based on the security policy, if both audit records are found the
# test returns true.  If either audit record is missing then the function
# returns false.
#
function augrok_default_inbound_rej {
    augrok_default && \
	augrok --seek=$log_mark -m1 type==AVC \
	 extra_text="avc: denied { recv } for" dest=$port
}

#
# augrok_syscall - Check for a syscall audit record
#
# INPUT
# none
#
# OUTPUT
# Returns true if the syscall audit record is found, false otherwise
#
# DESCRIPTION
# This function checks for a syscall audit record which matches the expected
# result of the test case.  The heavy lifting of sorting through the audit log
# is handled by augrok, this function is only concerned with generating the
# correct augrok arguments.  The augrok command line is built up through the
# use of variables created by the run_test() function and other test harness
# functions based on the individual test case.
#
function augrok_syscall {
    declare expres_audit

    # convert the test result expression into something usable by audit
    if [[ "$expres" == "success" ]]; then
	expres_audit="yes"
    else
	expres_audit="no"
    fi

    augrok --seek=$log_mark -m1 type==SYSCALL syscall=$syscall \
	success=$expres_audit exit=$exitval \
	pid=$pid auid=$(</proc/self/loginuid) \
	uid=$uid euid=$euid suid=$suid fsuid=$fsuid \
	gid=$gid egid=$egid sgid=$sgid fsgid=$fsgid \
	"$@"
}

#
# augrok_syscall_inbound_rej - Check for denied incoming connections
#
# INPUT
# none
#
# OUTPUT
# Returns true if both the syscall audit record and connection denial audit
# records are present in the audit log
#
# DESCRIPTION
# This function calls the augrok_syscall() function to check if the correct
# syscall audit record is present; if it is then it checks to see if SELinux
# has issued any AVC denial messages due to rejecting an incoming connection
# based on the security policy, if both audit records are found the test
# returns true.  If either audit record is missing then the function returns
# false.
#
function augrok_syscall_inbound_rej {
    augrok_syscall && \
	augrok --seek=$log_mark -m1 type==AVC \
	 extra_text="avc: denied { recv } for" dest=$port
}

#
# auwatch_syscall - Add a audit watch for the desired syscall
#
# INPUT
# none
#
# OUTPUT
# Returns true if the syscall watch was created, false otherwise
#
# DESCRIPTION
# This function adds a syscall audit watch so that the desired syscall
# accesses are recorded by the audit subsystem.  The variables used below in
# the auditctl command line are created by the run_test() function and other
# test harness functions based on the individual test case.
#
function auwatch_syscall {
    auditctl -a exit,always ${MODE:+-F arch=b$MODE} -S $syscall || exit_error
    prepend_cleanup "auditctl -d exit,always ${MODE:+-F arch=b$MODE} \
                    -S $syscall"
}

######################################################################
# run_test
######################################################################

#
# run_test - Execute an individual test case
#
# INPUT
# $@ : test command line
#
# OUTPUT
# Returns true on test success, other error values on test failure
#
# DESCRIPTION
# This function is responsibile for executing all aspects of an individual
# test case including the following: setup, audit configuration and rotation,
# test case execution, test case verification, and audit verification.  Most of
# these tasks are handled by other helper function defined either in this file
# or in the test harness, however, they are called from inside this function
# based on the individual test case's requirements.  In the case where a test
# is run and it returns true and the audit verification is successful then this
# function returns true and the test case can be considered to have passed.
# However, if either the test case returns non-true, the audit trail is not
# correct, or an error occurs elsewhere then this function calls either the
# exit_fail() or exit_error() functions to signify a test case failure.
#
function run_test {
    declare syscall=$1 tst_name=$1
    declare x name value status log_mark
    declare test_domain label_subj label_obj host_remote
    declare socketcall_op
    shift
    eval "$(parse_named "$@")" || exit_error

    source network_functions.bash || exit_error

    # get the derived variables
    #  NOTE: the $test_domain variable is always using the "local" version of
    #        the test domain because the value is always only used on the
    #        local machine (see below)
    test_domain=$(get_test_domain $type local)
    label_subj=$(get_label_subj $mlsop)
    label_obj=$(get_label_obj $mlsop)
    host_remote=$(host_ns ${ipv:+-${ipv#ipv}} $host)

    # run the setup callback
    # (which has access to the named params) or run the default setup
    if [[ -n $setupfunc ]]; then
        $setupfunc
    else
        setup_default
    fi

    # force the audit log to rotate
    rotate_audit_logs || exit_error

    # extract socketcall op ('accept', 'bind', ...) from cmdline
    [[ "$syscall" == socketcall ]] && socketcall_op=${unnamed[0]}

    # add an audit watch rule
    if [[ -n $auwatchfunc ]]; then
	$auwatchfunc || exit_error "unable to add an audit watch"
    else
	auwatch_default || exit_error "unable to add an audit watch"
    fi

    # mark the log for augrok later
    log_mark=$(stat -c %s $audit_log)
    # run this in a subshell so that exit_* doesn't abort early
    (
        declare testres exitval pid
	declare tst_args=( $(eval echo \"${unnamed[*]}\") )
        set -x

        # run the test itself
	read testres exitval pid <<< \
	    "$(runcon -u system_u -r system_r -t $test_domain -l $(get_label_subj $mlsop) -- \
               do_$tst_name "${tst_args[@]}" 2>&1 1>/dev/null)"

        [[ -z $testres || -z $exitval || -z $pid ]] && exit_error
        check_result $expres $testres $exitval $err

	# check for the audit records
        if [[ -n $augrokfunc ]]; then
            $augrokfunc || exit_fail "missing audit record"
        else
            augrok_default || exit_fail "missing audit record"
        fi

        exit_pass
    )
    status=$?

    return $status
}

######################################################################
# pre-testrun checks/configuration
######################################################################

gen_ipsec_conn()
{
    local ipv="$1" l4proto="$2" local_addr= remote_addr=
    eval local_addr="\$ipsec_${ipv}_local"
    eval remote_addr="\$ipsec_${ipv}_remote"
    cat <<EOF
conn network-${ipv}-${l4proto}
	auto=route
	rekey=no
	authby=secret
	type=transport
	left=$local_addr
	right=$remote_addr
	ike=3des-sha1
	phase2=ah
	phase2alg=sha1
	labeled_ipsec=yes
	policy_label=system_u:object_r:ipsec_spd_t:s0-s15:c0.c1023
	leftprotoport=$l4proto/4300
	rightprotoport=$l4proto
EOF
    [ "$ipv" = "ipv6" ] && echo '	connaddrfamily=ipv6'
    echo
}
gen_ipsec_conf()
{
    ipsec_std_header
    gen_ipsec_conn ipv4 tcp
    gen_ipsec_conn ipv4 udp
    gen_ipsec_conn ipv6 tcp
    gen_ipsec_conn ipv6 udp
}
gen_ipsec_secrets()
{
    echo ': PSK "secret"'
}
setup_ipsec_local()
{
    prepend_cleanup 'ipsec_local_cleanup; restart_service ipsec'
    gen_ipsec_conf | ipsec_local_conf
    gen_ipsec_secrets | ipsec_local_secrets
    restart_service ipsec
}
setup_ipsec_remote()
{
    # create session
    local s=$(send_ns -S remote) || exit_error
    # don't prepend_cleanup session kill here, bucket run takes
    # a long time (could kill someone else) and we -E the session anyway
    send_ns -t 600 -s "$s" remote 'lock' || exit_error

    # transfer configs
    prepend_cleanup 'send_ns -r 0 remote "exec,ipsec,cleanup"'
    gen_ipsec_conf | send_ns -i -s "$s" remote 'exec,ipsec,conf' || exit_error
    gen_ipsec_secrets | send_ns -i -s "$s" remote 'exec,ipsec,secrets' || exit_error
    check_ns -s "$s" remote -- '0 .*' || exit_error

    # lock the server, reload rules, unlock (degrade to shared)
    send_ns -t 600 -s "$s" remote 'lock,ex;exec,ipsec,reload;unlock' || exit_error
    check_ns -s "$s" remote -- '0 .*' || exit_error

    # all done
    send_ns -s "$s" -E remote
}

startup_hook()
{
    source tp_ipsec_functions.bash || exit_error

    # addresses to be used for ipsec configuration
    ipsec_ipv4_local="$(ipsec_addr_local 4)" || exit_error
    ipsec_ipv6_local="$(ipsec_addr_local 6)" || exit_error
    ipsec_ipv4_remote="$(ipsec_addr_remote 4)" || exit_error
    ipsec_ipv6_remote="$(ipsec_addr_remote 6)" || exit_error

    setup_ipsec_local
    setup_ipsec_remote

    case "$PPROFILE" in
        lspp)
            # verify that NetLabel and IPsec are configured
            verify_netlabel || warn "error: NetLabel not configured"
            verify_ipsec || warn "error: IPsec not configured"

            # attempt to establish ISAKMP SAs with the remote test server
            # racoonctl establish-sa isakmp inet6 $lblnet_loc6_host $lblnet_svr6_host
            # racoonctl establish-sa isakmp inet $lblnet_loc4_host $lblnet_svr4_host
            ;;
        capp)
            ;;
        *)
            die "error: unknown test profile ($PPROFILE)"
            ;;
    esac
}

######################################################################
# test configuration
######################################################################

##
## NET syscalls
##

# The test cases below are in the following format, with optional elements
# denoted by square brackets ([...]):
#
#  + <_syscall_> \
#    mlsop=<_mlsop_> expres=<_expres_> err=<_err_> \
#    [ auwatchfunc=<_auwatchfunc_> ] [ augrokfunc=<_augrokfunc_> ] \
#    host=<_host_> type=<_type_> op=<_op_> ipv=<_ipv_> port=<_port_> \
#    <_test_args_>
#
# Where the arguments are defined as follows:
#
#  _syscall_     : the syscall being tested
#  _mlsop_       : the MLS label comparison operator for more information see
#                  the comments elsewhere in this file, there are four valid
#                  values:
#                    eq     : the local test process label equals the remote
#                             process/packet/connection's label
#                    incomp : the local test process label is incomparable to
#                             the remote process/packet/connection's label
#                    dom    : the local test process label dominates the
#                             remote process/packet/connection's label
#                    domby  : the local test process label is dominated by the
#                             remote process/packet/connection's label
#  _expres_      : indicates that the operation should succeed (success) or
#                  fail (fail) based on the system's security policy
#  _err_         : if the test should fail, it should fail with this error
#                  code/value
#  _auwatchfunc_ : custom function for setting audit watches
#  _augrokfunc_  : custom function for validating the audit records
#  _host_        : indicates if the test is against a local (local) or
#                  remote (remote) host, the actual remote IP address is
#                  determined from the LBLNET_SVR_IPV4 and LBLNET_SVR_IPV6
#                  environment variables
#  _type_        : the labeling protocol to test, there are three valid values:
#                    unlabeled : not a labeling protocol, used as a sanity
#                                check
#                    netlabel  : the NetLabel explicit packet labeling
#                                mechanism, uses CIPSO
#                    ipsec     : the labeled IPsec implicit packet labeling
#                                mechanism
#  _op_          : the remote test driver command, there are four valid values:
#                    sendrand_tcp : initiate a TCP connection with the test
#                                   machine and send data
#                    sendrand_udp : send UDP traffic to the test machine
#                    recv_tcp     : accept TCP connections from the test
#                                   machine and receive data from established
#                                   connections
#                    recv_udp     : receive UDP traffic from the test machine
#  _ipv_         : the IP version, there are two values: ipv4 and ipv6
#  _port_        : the TCP or UDP port
#  _test_args_   : arguments to supply to the test applet/program, these may
#                  be variables which are later expanded inside the run_test()
#                  function

## SYSCALL:     accept()
## PURPOSE:
## Verify that incoming connections are only allowed when the sensitivity
## label of the incoming connection/packet dominates (is greater than or equal
## to) the receiving process.
## These test cases make use of a remote test driver to initiate a connection
## from the remote node to the host under test, see the setup_default()
## function above for details on configuring the remote test driver.  In
## addition to sanity checks using unlabled networking the test cases below
## test NetLabel and labeled IPsec connections where the receiving process
## is equal to (mlsop=eq), is incomparable to (mlsop=incomp),
## dominates (mlsop=dom), and is dominated by (mlsop=domby) the remote test
## driver and the resulting connection attempt.  The test procedure is as
## follows:
##  1. Configure the test driver to initiate a new connection at a
##     specific sensitivity label after a delay
##  2. Configure the audit subsystem to watch for the syscall record
##  3. Execute the test case on the local system and verify the result
##  4. Check the audit log for the correct syscall result and in the case of
##     failure check for SELinux generated audit records indicating that a
##     connection request was denied
## TESTCASE:    local unlabeled IPv4, sanity check
+ accept \
    mlsop=eq expres=success \
    host=local type=unlabeled op=sendrand_tcp ipv=ipv4 port=$tst_port1 \
    '$ipv $port'
## TESTCASE:    local unlabeled IPv6, sanity check
+ accept \
    mlsop=eq expres=success \
    host=local type=unlabeled op=sendrand_tcp ipv=ipv6 port=$tst_port1 \
    '$ipv $port'
## TESTCASE:    remote unlabeled IPv4, sanity check
+ accept \
    mlsop=eq expres=success \
    host=remote type=unlabeled op=sendrand_tcp ipv=ipv4 port=$tst_port1 \
    '$ipv $port'
## TESTCASE:    remote unlabeled IPv6, sanity check
+ accept \
    mlsop=eq expres=success \
    host=remote type=unlabeled op=sendrand_tcp ipv=ipv6 port=$tst_port1 \
    '$ipv $port'
if [[ $PPROFILE == lspp ]]; then
## TESTCASE:    local NetLabel IPv4, mac success (eq)
    + accept \
	mlsop=eq expres=success \
	host=local type=netlabel op=sendrand_tcp ipv=ipv4 port=$tst_port2 \
	'$ipv $port'
## TESTCASE:    local NetLabel IPv4, mac failure (incomp)
    + accept \
	mlsop=incomp expres=fail err=EINTR \
	augrokfunc=augrok_default_inbound_rej \
	host=local type=netlabel op=sendrand_tcp ipv=ipv4 port=$tst_port2 \
	'$ipv $port'
## TESTCASE:    local NetLabel IPv4, mac success (dom)
    + accept \
	mlsop=dom expres=success \
	augrokfunc=augrok_default \
	host=local type=netlabel op=sendrand_tcp ipv=ipv4 port=$tst_port2 \
	'$ipv $port'
## TESTCASE:    local NetLabel IPv4, mac failure (domby)
    + accept \
	mlsop=domby expres=fail err=EINTR \
	augrokfunc=augrok_default_inbound_rej \
	host=local type=netlabel op=sendrand_tcp ipv=ipv4 port=$tst_port2 \
	'$ipv $port'
## TESTCASE:    remote NetLabel IPv4, mac success (eq)
    + accept \
	mlsop=eq expres=success \
	host=remote type=netlabel op=sendrand_tcp ipv=ipv4 port=$tst_port2 \
	'$ipv $port'
## TESTCASE:    remote NetLabel IPv4, mac failure (incomp)
    + accept \
	mlsop=incomp expres=fail err=EINTR \
	augrokfunc=augrok_default_inbound_rej \
	host=remote type=netlabel op=sendrand_tcp ipv=ipv4 port=$tst_port2 \
	'$ipv $port'
## TESTCASE:    remote NetLabel IPv4, mac success (dom)
    + accept \
	mlsop=dom expres=success \
	augrokfunc=augrok_default \
	host=remote type=netlabel op=sendrand_tcp ipv=ipv4 port=$tst_port2 \
	'$ipv $port'
## TESTCASE:    remote NetLabel IPv4, mac failure (domby)
    + accept \
	mlsop=domby expres=fail err=EINTR \
	augrokfunc=augrok_default_inbound_rej \
	host=remote type=netlabel op=sendrand_tcp ipv=ipv4 port=$tst_port2 \
	'$ipv $port'
# ## TESTCASE:    local IPsec IPv4, mac success (eq)
#     + accept \
# 	mlsop=eq expres=success \
# 	host=local type=ipsec op=sendrand_tcp ipv=ipv4 port=$tst_port3 \
# 	'$ipv $port'
# ## TESTCASE:    local IPsec IPv4, mac failure (incomp)
#     + accept \
# 	mlsop=incomp expres=fail err=EINTR \
# 	augrokfunc=augrok_default_inbound_rej \
# 	host=local type=ipsec op=sendrand_tcp ipv=ipv4 port=$tst_port3 \
# 	'$ipv $port'
# ## TESTCASE:    local IPsec IPv4, mac success (dom)
#     + accept \
# 	mlsop=dom expres=success \
# 	augrokfunc=augrok_default \
# 	host=local type=ipsec op=sendrand_tcp ipv=ipv4 port=$tst_port3 \
# 	'$ipv $port'
# ## TESTCASE:    local IPsec IPv4, mac failure (domby)
#     + accept \
# 	mlsop=domby expres=fail err=EINTR \
# 	augrokfunc=augrok_default_inbound_rej \
# 	host=local type=ipsec op=sendrand_tcp ipv=ipv4 port=$tst_port3 \
# 	'$ipv $port'
## TESTCASE:    remote IPsec IPv4, mac success (eq)
    + accept \
	mlsop=eq expres=success \
	host=remote type=ipsec op=sendrand_tcp ipv=ipv4 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    remote IPsec IPv4, mac failure (incomp)
    + accept \
	mlsop=incomp expres=fail err=EINTR \
	augrokfunc=augrok_default_inbound_rej \
	host=remote type=ipsec op=sendrand_tcp ipv=ipv4 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    remote IPsec IPv4, mac success (dom)
    + accept \
	mlsop=dom expres=success \
	augrokfunc=augrok_default \
	host=remote type=ipsec op=sendrand_tcp ipv=ipv4 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    remote IPsec IPv4, mac failure (domby)
    + accept \
	mlsop=domby expres=fail err=EINTR \
	augrokfunc=augrok_default_inbound_rej \
	host=remote type=ipsec op=sendrand_tcp ipv=ipv4 port=$tst_port3 \
	'$ipv $port'
# ## TESTCASE:    local IPsec IPv6, mac success (eq)
#     + accept \
# 	mlsop=eq expres=success \
# 	host=local type=ipsec op=sendrand_tcp ipv=ipv6 port=$tst_port3 \
# 	'$ipv $port'
# ## TESTCASE:    local IPsec IPv6, mac failure (incomp)
#     + accept \
# 	mlsop=incomp expres=fail err=EINTR \
# 	augrokfunc=augrok_default_inbound_rej \
# 	host=local type=ipsec op=sendrand_tcp ipv=ipv6 port=$tst_port3 \
# 	'$ipv $port'
# ## TESTCASE:    local IPsec IPv6, mac success (dom)
#     + accept \
# 	mlsop=dom expres=success \
# 	augrokfunc=augrok_default \
# 	host=local type=ipsec op=sendrand_tcp ipv=ipv6 port=$tst_port3 \
# 	'$ipv $port'
# ## TESTCASE:    local IPsec IPv6, mac failure (domby)
#     + accept \
# 	mlsop=domby expres=fail err=EINTR \
# 	augrokfunc=augrok_default_inbound_rej \
# 	host=local type=ipsec op=sendrand_tcp ipv=ipv6 port=$tst_port3 \
# 	'$ipv $port'
## TESTCASE:    remote IPsec IPv6, mac success (eq)
    + accept \
	mlsop=eq expres=success \
	host=remote type=ipsec op=sendrand_tcp ipv=ipv6 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    remote IPsec IPv6, mac failure (incomp)
    + accept \
	mlsop=incomp expres=fail err=EINTR \
	augrokfunc=augrok_default_inbound_rej \
	host=remote type=ipsec op=sendrand_tcp ipv=ipv6 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    remote IPsec IPv6, mac success (dom)
    + accept \
	mlsop=dom expres=success \
	augrokfunc=augrok_default \
	host=remote type=ipsec op=sendrand_tcp ipv=ipv6 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    remote IPsec IPv6, mac failure (domby)
    + accept \
	mlsop=domby expres=fail err=EINTR \
	augrokfunc=augrok_default_inbound_rej \
	host=remote type=ipsec op=sendrand_tcp ipv=ipv6 port=$tst_port3 \
	'$ipv $port'
fi

## SYSCALL:     accept4()
## PURPOSE:
## Verify that incoming connections are only allowed when the sensitivity
## label of the incoming connection/packet dominates (is greater than or equal
## to) the receiving process.
## These test cases make use of a remote test driver to initiate a connection
## from the remote node to the host under test, see the setup_default()
## function above for details on configuring the remote test driver.  In
## addition to sanity checks using unlabled networking the test cases below
## test NetLabel and labeled IPsec connections where the receiving process
## is equal to (mlsop=eq), is incomparable to (mlsop=incomp),
## dominates (mlsop=dom), and is dominated by (mlsop=domby) the remote test
## driver and the resulting connection attempt.  The test procedure is as
## follows:
##  1. Configure the test driver to initiate a new connection at a
##     specific sensitivity label after a delay
##  2. Configure the audit subsystem to watch for the syscall record
##  3. Execute the test case on the local system and verify the result
##  4. Check the audit log for the correct syscall result and in the case of
##     failure check for SELinux generated audit records indicating that a
##     connection request was denied
if [[ $HOSTTYPE == x86_64 ]]; then
## TESTCASE:    local unlabeled IPv4, sanity check
    + accept4 \
        mlsop=eq expres=success \
        host=local type=unlabeled op=sendrand_tcp ipv=ipv4 port=$tst_port1 \
        '$ipv $port'
## TESTCASE:    local unlabeled IPv6, sanity check
    + accept4 \
        mlsop=eq expres=success \
        host=local type=unlabeled op=sendrand_tcp ipv=ipv6 port=$tst_port1 \
        '$ipv $port'
## TESTCASE:    remote unlabeled IPv4, sanity check
    + accept4 \
        mlsop=eq expres=success \
        host=remote type=unlabeled op=sendrand_tcp ipv=ipv4 port=$tst_port1 \
        '$ipv $port'
## TESTCASE:    remote unlabeled IPv6, sanity check
    + accept4 \
        mlsop=eq expres=success \
        host=remote type=unlabeled op=sendrand_tcp ipv=ipv6 port=$tst_port1 \
        '$ipv $port'
    if [[ $PPROFILE == lspp ]]; then
## TESTCASE:    local NetLabel IPv4, mac success (eq)
        + accept4 \
	    mlsop=eq expres=success \
	    host=local type=netlabel op=sendrand_tcp ipv=ipv4 port=$tst_port2 \
	    '$ipv $port'
## TESTCASE:    local NetLabel IPv4, mac failure (incomp)
        + accept4 \
	    mlsop=incomp expres=fail err=EINTR \
	    augrokfunc=augrok_default_inbound_rej \
	    host=local type=netlabel op=sendrand_tcp ipv=ipv4 port=$tst_port2 \
	    '$ipv $port'
## TESTCASE:    local NetLabel IPv4, mac success (dom)
        + accept4 \
	    mlsop=dom expres=success \
	    augrokfunc=augrok_default \
	    host=local type=netlabel op=sendrand_tcp ipv=ipv4 port=$tst_port2 \
	    '$ipv $port'
## TESTCASE:    local NetLabel IPv4, mac failure (domby)
        + accept4 \
	    mlsop=domby expres=fail err=EINTR \
	    augrokfunc=augrok_default_inbound_rej \
	    host=local type=netlabel op=sendrand_tcp ipv=ipv4 port=$tst_port2 \
	    '$ipv $port'
## TESTCASE:    remote NetLabel IPv4, mac success (eq)
        + accept4 \
	    mlsop=eq expres=success \
	    host=remote type=netlabel op=sendrand_tcp ipv=ipv4 port=$tst_port2 \
	    '$ipv $port'
## TESTCASE:    remote NetLabel IPv4, mac failure (incomp)
        + accept4 \
	    mlsop=incomp expres=fail err=EINTR \
	    augrokfunc=augrok_default_inbound_rej \
	    host=remote type=netlabel op=sendrand_tcp ipv=ipv4 port=$tst_port2 \
	    '$ipv $port'
## TESTCASE:    remote NetLabel IPv4, mac success (dom)
        + accept4 \
	    mlsop=dom expres=success \
	    augrokfunc=augrok_default \
	    host=remote type=netlabel op=sendrand_tcp ipv=ipv4 port=$tst_port2 \
	    '$ipv $port'
## TESTCASE:    remote NetLabel IPv4, mac failure (domby)
        + accept4 \
	    mlsop=domby expres=fail err=EINTR \
	    augrokfunc=augrok_default_inbound_rej \
	    host=remote type=netlabel op=sendrand_tcp ipv=ipv4 port=$tst_port2 \
	    '$ipv $port'
# ## TESTCASE:    local IPsec IPv4, mac success (eq)
#         + accept4 \
# 	    mlsop=eq expres=success \
# 	    host=local type=ipsec op=sendrand_tcp ipv=ipv4 port=$tst_port3 \
# 	    '$ipv $port'
# ## TESTCASE:    local IPsec IPv4, mac failure (incomp)
#         + accept4 \
# 	    mlsop=incomp expres=fail err=EINTR \
# 	    augrokfunc=augrok_default_inbound_rej \
# 	    host=local type=ipsec op=sendrand_tcp ipv=ipv4 port=$tst_port3 \
# 	    '$ipv $port'
# ## TESTCASE:    local IPsec IPv4, mac success (dom)
#         + accept4 \
# 	    mlsop=dom expres=success \
# 	    augrokfunc=augrok_default \
# 	    host=local type=ipsec op=sendrand_tcp ipv=ipv4 port=$tst_port3 \
# 	    '$ipv $port'
# ## TESTCASE:    local IPsec IPv4, mac failure (domby)
#         + accept4 \
# 	    mlsop=domby expres=fail err=EINTR \
# 	    augrokfunc=augrok_default_inbound_rej \
# 	    host=local type=ipsec op=sendrand_tcp ipv=ipv4 port=$tst_port3 \
# 	    '$ipv $port'
## TESTCASE:    remote IPsec IPv4, mac success (eq)
        + accept4 \
	    mlsop=eq expres=success \
	    host=remote type=ipsec op=sendrand_tcp ipv=ipv4 port=$tst_port3 \
	    '$ipv $port'
## TESTCASE:    remote IPsec IPv4, mac failure (incomp)
        + accept4 \
	    mlsop=incomp expres=fail err=EINTR \
	    augrokfunc=augrok_default_inbound_rej \
	    host=remote type=ipsec op=sendrand_tcp ipv=ipv4 port=$tst_port3 \
	    '$ipv $port'
## TESTCASE:    remote IPsec IPv4, mac success (dom)
        + accept4 \
	    mlsop=dom expres=success \
	    augrokfunc=augrok_default \
	    host=remote type=ipsec op=sendrand_tcp ipv=ipv4 port=$tst_port3 \
	    '$ipv $port'
## TESTCASE:    remote IPsec IPv4, mac failure (domby)
        + accept4 \
	    mlsop=domby expres=fail err=EINTR \
	    augrokfunc=augrok_default_inbound_rej \
	    host=remote type=ipsec op=sendrand_tcp ipv=ipv4 port=$tst_port3 \
	    '$ipv $port'
# ## TESTCASE:    local IPsec IPv6, mac success (eq)
#         + accept4 \
# 	    mlsop=eq expres=success \
# 	    host=local type=ipsec op=sendrand_tcp ipv=ipv6 port=$tst_port3 \
# 	    '$ipv $port'
# ## TESTCASE:    local IPsec IPv6, mac failure (incomp)
#         + accept4 \
# 	    mlsop=incomp expres=fail err=EINTR \
# 	    augrokfunc=augrok_default_inbound_rej \
# 	    host=local type=ipsec op=sendrand_tcp ipv=ipv6 port=$tst_port3 \
# 	    '$ipv $port'
# ## TESTCASE:    local IPsec IPv6, mac success (dom)
#         + accept4 \
# 	    mlsop=dom expres=success \
# 	    augrokfunc=augrok_default \
# 	    host=local type=ipsec op=sendrand_tcp ipv=ipv6 port=$tst_port3 \
# 	    '$ipv $port'
# ## TESTCASE:    local IPsec IPv6, mac failure (domby)
#         + accept4 \
# 	    mlsop=domby expres=fail err=EINTR \
# 	    augrokfunc=augrok_default_inbound_rej \
# 	    host=local type=ipsec op=sendrand_tcp ipv=ipv6 port=$tst_port3 \
# 	    '$ipv $port'
## TESTCASE:    remote IPsec IPv6, mac success (eq)
        + accept4 \
	    mlsop=eq expres=success \
	    host=remote type=ipsec op=sendrand_tcp ipv=ipv6 port=$tst_port3 \
	    '$ipv $port'
## TESTCASE:    remote IPsec IPv6, mac failure (incomp)
        + accept4 \
	    mlsop=incomp expres=fail err=EINTR \
	    augrokfunc=augrok_default_inbound_rej \
	    host=remote type=ipsec op=sendrand_tcp ipv=ipv6 port=$tst_port3 \
	    '$ipv $port'
## TESTCASE:    remote IPsec IPv6, mac success (dom)
        + accept4 \
	    mlsop=dom expres=success \
	    augrokfunc=augrok_default \
	    host=remote type=ipsec op=sendrand_tcp ipv=ipv6 port=$tst_port3 \
	    '$ipv $port'
## TESTCASE:    remote IPsec IPv6, mac failure (domby)
        + accept4 \
	    mlsop=domby expres=fail err=EINTR \
	    augrokfunc=augrok_default_inbound_rej \
	    host=remote type=ipsec op=sendrand_tcp ipv=ipv6 port=$tst_port3 \
	    '$ipv $port'
    fi
fi

## SYSCALL:     connect()
## PURPOSE:
## Verify that outgoing connections are only allowed when the sensitivity label
## of the outgoing connection/packet dominates the receiving process.  These
## test cases make use of a remote test driver to accept new connections from
## the host under test, see the setup_default() function above for details on
## configuring the remote test driver.  In addition to sanity checks using
## unlabeled networking the test cases below test NetLabel and labeled IPsec
## connections where the sending process is equal to (mlsop=eq), is
## incomparable to (mlsop=incomp), dominates (mlsop=dom), and is dominated 
## by (mlsop=domby) the remote test driver waiting for a connection request.
## The test procedure is as follows:
##  1. Configure the test driver to accept new connections at a specific
##     sensitivity label
##  2. Configure the audit subsystem to watch for the syscall record
##  3. Execute the test case on the local system and verify the result
##  4. Check the audit log for the correct syscall result
## TESTCASE:    local unlabeled IPv4, sanity check
+ connect \
    mlsop=eq expres=success \
    host=local type=unlabeled op=recv_tcp ipv=ipv4 srcport=$tst_port1 \
    '$host_remote tcp $port:$srcport'
## TESTCASE:    local unlabeled IPv6, sanity check
+ connect \
    mlsop=eq expres=success \
    host=local type=unlabeled op=recv_tcp ipv=ipv6 srcport=$tst_port1 \
    '$host_remote tcp $port:$srcport'
## TESTCASE:    remote unlabeled IPv4, sanity check
+ connect \
    mlsop=eq expres=success \
    host=remote type=unlabeled op=recv_tcp ipv=ipv4 srcport=$tst_port1 \
    '$host_remote tcp $port:$srcport'
## TESTCASE:    remote unlabeled IPv6, sanity check
+ connect \
    mlsop=eq expres=success \
    host=remote type=unlabeled op=recv_tcp ipv=ipv6 srcport=$tst_port1 \
    '$host_remote tcp $port:$srcport'
if [[ $PPROFILE == lspp ]]; then
## TESTCASE:    local NetLabel IPv4, mac success (eq)
    + connect \
	mlsop=eq expres=success \
	host=local type=netlabel op=recv_tcp ipv=ipv4 srcport=$tst_port2 \
	'$host_remote tcp $port:$srcport'
## TESTCASE:    local NetLabel IPv4, mac failure (incomp)
    + connect \
	mlsop=incomp expres=fail err=EHOSTUNREACH \
	host=local type=netlabel op=recv_tcp ipv=ipv4 srcport=$tst_port2 \
	'$host_remote tcp $port:$srcport'
## TESTCASE:    local NetLabel IPv4, mac failure (dom)
    + connect \
	mlsop=dom expres=fail err=EHOSTUNREACH \
	host=local type=netlabel op=recv_tcp ipv=ipv4 srcport=$tst_port2 \
	'$host_remote tcp $port:$srcport'
## TESTCASE:    local NetLabel IPv4, mac success (domby)
    + connect \
	mlsop=domby expres=success \
	host=local type=netlabel op=recv_tcp ipv=ipv4 srcport=$tst_port2 \
	'$host_remote tcp $port:$srcport'
## TESTCASE:    remote NetLabel IPv4, mac success (eq)
    + connect \
	mlsop=eq expres=success \
	host=remote type=netlabel op=recv_tcp ipv=ipv4 srcport=$tst_port2 \
	'$host_remote tcp $port:$srcport'
## TESTCASE:    remote NetLabel IPv4, mac failure (incomp)
    + connect \
	mlsop=incomp expres=fail err=EHOSTUNREACH \
	host=remote type=netlabel op=recv_tcp ipv=ipv4 srcport=$tst_port2 \
	'$host_remote tcp $port:$srcport'
## TESTCASE:    remote NetLabel IPv4, mac failure (dom)
    + connect \
	mlsop=dom expres=fail err=EHOSTUNREACH \
	host=remote type=netlabel op=recv_tcp ipv=ipv4 srcport=$tst_port2 \
	'$host_remote tcp $port:$srcport'
## TESTCASE:    remote NetLabel IPv4, mac success (domby)
    + connect \
	mlsop=domby expres=success \
	host=remote type=netlabel op=recv_tcp ipv=ipv4 srcport=$tst_port2 \
	'$host_remote tcp $port:$srcport'
# ## TESTCASE:    local IPsec IPv4, mac success (eq)
#     + connect \
# 	mlsop=eq expres=success \
# 	host=local type=ipsec op=recv_tcp ipv=ipv4 srcport=$tst_port3 \
# 	'$host_remote tcp $port:$srcport'
# ## TESTCASE:    local IPsec IPv4, mac failure (incomp)
#     + connect \
# 	mlsop=incomp expres=fail err=ETIMEDOUT \
# 	host=local type=ipsec op=recv_tcp ipv=ipv4 srcport=$tst_port3 \
# 	'$host_remote tcp $port:$srcport'
# ## TESTCASE:    local IPsec IPv4, mac failure (dom)
#     + connect \
# 	mlsop=dom expres=fail err=ETIMEDOUT \
# 	host=local type=ipsec op=recv_tcp ipv=ipv4 srcport=$tst_port3 \
# 	'$host_remote tcp $port:$srcport'
# ## TESTCASE:    local IPsec IPv4, mac success (domby)
#     + connect \
# 	mlsop=domby expres=success \
# 	host=local type=ipsec op=recv_tcp ipv=ipv4 srcport=$tst_port3 \
# 	'$host_remote tcp $port:$srcport'
## TESTCASE:    remote IPsec IPv4, mac success (eq)
    + connect \
	mlsop=eq expres=success \
	host=remote type=ipsec op=recv_tcp ipv=ipv4 srcport=$tst_port3 \
	'$host_remote tcp $port:$srcport'
## TESTCASE:    remote IPsec IPv4, mac failure (incomp)
    + connect \
	mlsop=incomp expres=fail err=ETIMEDOUT \
	host=remote type=ipsec op=recv_tcp ipv=ipv4 srcport=$tst_port3 \
	'$host_remote tcp $port:$srcport'
## TESTCASE:    remote IPsec IPv4, mac failure (dom)
    + connect \
	mlsop=dom expres=fail err=ETIMEDOUT \
	host=remote type=ipsec op=recv_tcp ipv=ipv4 srcport=$tst_port3 \
	'$host_remote tcp $port:$srcport'
## TESTCASE:    remote IPsec IPv4, mac success (domby)
    + connect \
	mlsop=domby expres=success \
	host=remote type=ipsec op=recv_tcp ipv=ipv4 srcport=$tst_port3 \
	'$host_remote tcp $port:$srcport'
# ## TESTCASE:    local IPsec IPv6, mac success (eq)
#     + connect \
# 	mlsop=eq expres=success \
# 	host=local type=ipsec op=recv_tcp ipv=ipv6 srcport=$tst_port3 \
# 	'$host_remote tcp $port:$srcport'
# ## TESTCASE:    local IPsec IPv6, mac failure (incomp)
#     + connect \
# 	mlsop=incomp expres=fail err=ETIMEDOUT \
# 	host=local type=ipsec op=recv_tcp ipv=ipv6 srcport=$tst_port3 \
# 	'$host_remote tcp $port:$srcport'
# ## TESTCASE:    local IPsec IPv6, mac failure (dom)
#     + connect \
# 	mlsop=dom expres=fail err=ETIMEDOUT \
# 	host=local type=ipsec op=recv_tcp ipv=ipv6 srcport=$tst_port3 \
# 	'$host_remote tcp $port:$srcport'
# ## TESTCASE:    local IPsec IPv6, mac success (domby)
#     + connect \
# 	mlsop=domby expres=success \
# 	host=local type=ipsec op=recv_tcp ipv=ipv6 srcport=$tst_port3 \
# 	'$host_remote tcp $port:$srcport'
## TESTCASE:    remote IPsec IPv6, mac success (eq)
    + connect \
	mlsop=eq expres=success \
	host=remote type=ipsec op=recv_tcp ipv=ipv6 srcport=$tst_port3 \
	'$host_remote tcp $port:$srcport'
## TESTCASE:    remote IPsec IPv6, mac failure (incomp)
    + connect \
	mlsop=incomp expres=fail err=ETIMEDOUT \
	host=remote type=ipsec op=recv_tcp ipv=ipv6 srcport=$tst_port3 \
	'$host_remote tcp $port:$srcport'
## TESTCASE:    remote IPsec IPv6, mac failure (dom)
    + connect \
	mlsop=dom expres=fail err=ETIMEDOUT \
	host=remote type=ipsec op=recv_tcp ipv=ipv6 srcport=$tst_port3 \
	'$host_remote tcp $port:$srcport'
## TESTCASE:    remote IPsec IPv6, mac success (domby)
    + connect \
	mlsop=domby expres=success \
	host=remote type=ipsec op=recv_tcp ipv=ipv6 srcport=$tst_port3 \
	'$host_remote tcp $port:$srcport'
fi

## SYSCALL:     recvfrom()
## PURPOSE:
## Verify that incoming traffic is only allowed when the sensitivity label of
## the incoming packet dominates (is greater than or equal to) to the receiving
## process.  These test cases
## make use of a remote test driver to generate traffic from the remote node
## to the host under test, see the setup_default() function above for details
## on configuring the remote test driver.  In addition to sanity checks using
## unlabled networking the test cases below test NetLabel and labeled IPsec
## labeled packets where the receiving process is equal to (mlsop=eq), is
## incomparable to (mlsop=incomp), dominates (mlsop=dom), and is dominated by
## (mlsop=domby) the remote test driver and the resulting network traffic.
## The test procedure is as follows:
##  1. Configure the test driver to generate traffic at a specific sensitivity
##     label after a delay
##  2. Configure the audit subsystem to watch for the syscall record
##  3. Execute the test case on the local system and verify the result
##  4. Check the audit log for the correct syscall result and in the case of
##     failure check for SELinux generated audit records indicating that
##     incoming traffic was rejected
## TESTCASE:    local unlabeled IPv4, sanity check
+ recvfrom \
    mlsop=eq expres=success \
    host=local type=unlabeled op=sendrand_udp ipv=ipv4 port=$tst_port1 \
    '$ipv $port'
## TESTCASE:    local unlabeled IPv6, sanity check
+ recvfrom \
    mlsop=eq expres=success \
    host=local type=unlabeled op=sendrand_udp ipv=ipv6 port=$tst_port1 \
    '$ipv $port'
## TESTCASE:    remote unlabeled IPv4, sanity check
+ recvfrom \
    mlsop=eq expres=success \
    host=remote type=unlabeled op=sendrand_udp ipv=ipv4 port=$tst_port1 \
    '$ipv $port'
## TESTCASE:    remote unlabeled IPv6, sanity check
+ recvfrom \
    mlsop=eq expres=success \
    host=remote type=unlabeled op=sendrand_udp ipv=ipv6 port=$tst_port1 \
    '$ipv $port'
if [[ $PPROFILE == lspp ]]; then
## TESTCASE:    local NetLabel IPv4, mac success (eq)
    + recvfrom \
	mlsop=eq expres=success \
	host=local type=netlabel op=sendrand_udp ipv=ipv4 port=$tst_port2 \
	'$ipv $port'
## TESTCASE:    local NetLabel IPv4, mac failure (incomp)
    + recvfrom \
	mlsop=incomp expres=fail err=EINTR \
	augrokfunc=augrok_default_inbound_rej \
	host=local type=netlabel op=sendrand_udp ipv=ipv4 port=$tst_port2 \
	'$ipv $port'
## TESTCASE:    local NetLabel IPv4, mac success (dom)
    + recvfrom \
	mlsop=dom expres=success  \
	augrokfunc=augrok_default \
	host=local type=netlabel op=sendrand_udp ipv=ipv4 port=$tst_port2 \
	'$ipv $port'
## TESTCASE:    local NetLabel IPv4, mac failure (domby)
    + recvfrom \
	mlsop=domby expres=fail err=EINTR \
	augrokfunc=augrok_default_inbound_rej \
	host=local type=netlabel op=sendrand_udp ipv=ipv4 port=$tst_port2 \
	'$ipv $port'
## TESTCASE:    remote NetLabel IPv4, mac success (eq)
    + recvfrom \
	mlsop=eq expres=success \
	host=remote type=netlabel op=sendrand_udp ipv=ipv4 port=$tst_port2 \
	'$ipv $port'
## TESTCASE:    remote NetLabel IPv4, mac failure (incomp)
    + recvfrom \
	mlsop=incomp expres=fail err=EINTR \
	augrokfunc=augrok_default_inbound_rej \
	host=remote type=netlabel op=sendrand_udp ipv=ipv4 port=$tst_port2 \
	'$ipv $port'
## TESTCASE:    remote NetLabel IPv4, mac success (dom)
    + recvfrom \
	mlsop=dom expres=success \
	augrokfunc=augrok_default \
	host=remote type=netlabel op=sendrand_udp ipv=ipv4 port=$tst_port2 \
	'$ipv $port'
## TESTCASE:    remote NetLabel IPv4, mac failure (domby)
    + recvfrom \
	mlsop=domby expres=fail err=EINTR \
	augrokfunc=augrok_default_inbound_rej \
	host=remote type=netlabel op=sendrand_udp ipv=ipv4 port=$tst_port2 \
	'$ipv $port'
# ## TESTCASE:    local IPsec IPv4, mac success (eq)
#     + recvfrom \
# 	mlsop=eq expres=success \
# 	host=local type=ipsec op=sendrand_udp ipv=ipv4 port=$tst_port3 \
# 	'$ipv $port'
# ## TESTCASE:    local IPsec IPv4, mac failure (incomp)
#     + recvfrom \
# 	mlsop=incomp expres=fail err=EINTR \
# 	augrokfunc=augrok_default_inbound_rej \
# 	host=local type=ipsec op=sendrand_udp ipv=ipv4 port=$tst_port3 \
# 	'$ipv $port'
# ## TESTCASE:    local IPsec IPv4, mac success (dom)
#     + recvfrom \
# 	mlsop=dom expres=success \
# 	augrokfunc=augrok_default \
# 	host=local type=ipsec op=sendrand_udp ipv=ipv4 port=$tst_port3 \
# 	'$ipv $port'
# ## TESTCASE:    local IPsec IPv4, mac failure (domby)
#     + recvfrom \
# 	mlsop=domby expres=fail err=EINTR \
# 	host=local type=ipsec op=sendrand_udp ipv=ipv4 port=$tst_port3 \
# 	'$ipv $port'
## TESTCASE:    remote IPsec IPv4, mac success (eq)
    + recvfrom \
	mlsop=eq expres=success \
	host=remote type=ipsec op=sendrand_udp ipv=ipv4 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    remote IPsec IPv4, mac failure (incomp)
    + recvfrom \
	mlsop=incomp expres=fail err=EINTR \
	augrokfunc=augrok_default_inbound_rej \
	host=remote type=ipsec op=sendrand_udp ipv=ipv4 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    remote IPsec IPv4, mac success (dom)
    + recvfrom \
	mlsop=dom expres=success \
	augrokfunc=augrok_default \
	host=remote type=ipsec op=sendrand_udp ipv=ipv4 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    remote IPsec IPv4, mac failure (domby)
    + recvfrom \
	mlsop=domby expres=fail err=EINTR \
	host=remote type=ipsec op=sendrand_udp ipv=ipv4 port=$tst_port3 \
	'$ipv $port'
# ## TESTCASE:    local IPsec IPv6, mac success (eq)
#     + recvfrom \
# 	mlsop=eq expres=success \
# 	host=local type=ipsec op=sendrand_udp ipv=ipv6 port=$tst_port3 \
# 	'$ipv $port'
# ## TESTCASE:    local IPsec IPv6, mac failure (incomp)
#     + recvfrom \
# 	mlsop=incomp expres=fail err=EINTR \
# 	augrokfunc=augrok_default_inbound_rej \
# 	host=local type=ipsec op=sendrand_udp ipv=ipv6 port=$tst_port3 \
# 	'$ipv $port'
# ## TESTCASE:    local IPsec IPv6, mac success (dom)
#     + recvfrom \
# 	mlsop=dom expres=success \
# 	augrokfunc=augrok_default \
# 	host=local type=ipsec op=sendrand_udp ipv=ipv6 port=$tst_port3 \
# 	'$ipv $port'
# ## TESTCASE:    local IPsec IPv6, mac failure (domby)
#     + recvfrom \
# 	mlsop=domby expres=fail err=EINTR \
# 	host=local type=ipsec op=sendrand_udp ipv=ipv6 port=$tst_port3 \
# 	'$ipv $port'
## TESTCASE:    remote IPsec IPv6, mac success (eq)
    + recvfrom \
	mlsop=eq expres=success \
	host=remote type=ipsec op=sendrand_udp ipv=ipv6 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    remote IPsec IPv6, mac failure (incomp)
    + recvfrom \
	mlsop=incomp expres=fail err=EINTR \
	augrokfunc=augrok_default_inbound_rej \
	host=remote type=ipsec op=sendrand_udp ipv=ipv6 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    remote IPsec IPv6, mac success (dom)
    + recvfrom \
	mlsop=dom expres=success \
	augrokfunc=augrok_default \
	host=remote type=ipsec op=sendrand_udp ipv=ipv6 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    remote IPsec IPv6, mac failure (domby)
    + recvfrom \
	mlsop=domby expres=fail err=EINTR \
	host=remote type=ipsec op=sendrand_udp ipv=ipv6 port=$tst_port3 \
	'$ipv $port'
fi

## SYSCALL:     recvmsg()
## PURPOSE:
## Verify that incoming traffic is only allowed when the sensitivity label of
## the incoming packet dominates (is greater than or equal to) the receiving
## process.  These test cases
## make use of a remote test driver to generate traffic from the remote node
## to the host under test, see the setup_default() function above for details
## on configuring the remote test driver.  In addition to sanity checks using
## unlabled networking the test cases below test NetLabel and labeled IPsec
## labeled packets where the receiving process is equal to (mlsop=eq), is
## incomparable to (mlsop=incomp), dominates (mlsop=dom), and is dominated by
## (mlsop=domby) the remote test driver and the resulting network traffic.
## The test procedure is as follows:
##  1. Configure the test driver to generate traffic at a specific sensitivity
##     label after a delay
##  2. Configure the audit subsystem to watch for the syscall record
##  3. Execute the test case on the local system and verify the result
##  4. Check the audit log for the correct syscall result and in the case of
##     failure check for SELinux generated audit records indicating that
##     incoming traffic was rejected
## TESTCASE:    local unlabeled IPv4, sanity check
+ recvmsg \
    mlsop=eq expres=success \
    host=local type=unlabeled op=sendrand_udp ipv=ipv4 port=$tst_port1 \
    '$ipv $port'
## TESTCASE:    local unlabeled IPv6, sanity check
+ recvmsg \
    mlsop=eq expres=success \
    host=local type=unlabeled op=sendrand_udp ipv=ipv6 port=$tst_port1 \
    '$ipv $port'
## TESTCASE:    remote unlabeled IPv4, sanity check
+ recvmsg \
    mlsop=eq expres=success \
    host=remote type=unlabeled op=sendrand_udp ipv=ipv4 port=$tst_port1 \
    '$ipv $port'
## TESTCASE:    remote unlabeled IPv6, sanity check
+ recvmsg \
    mlsop=eq expres=success \
    host=remote type=unlabeled op=sendrand_udp ipv=ipv6 port=$tst_port1 \
    '$ipv $port'
if [[ $PPROFILE == lspp ]]; then
## TESTCASE:    local NetLabel IPv4, mac success (eq)
    + recvmsg \
	mlsop=eq expres=success \
	host=local type=netlabel op=sendrand_udp ipv=ipv4 port=$tst_port2 \
	'$ipv $port'
## TESTCASE:    local NetLabel IPv4, mac failure (incomp)
    + recvmsg \
	mlsop=incomp expres=fail err=EINTR \
	augrokfunc=augrok_default_inbound_rej \
	host=local type=netlabel op=sendrand_udp ipv=ipv4 port=$tst_port2 \
	'$ipv $port'
## TESTCASE:    local NetLabel IPv4, mac success (dom)
    + recvmsg \
	mlsop=dom expres=success \
	augrokfunc=augrok_default \
	host=local type=netlabel op=sendrand_udp ipv=ipv4 port=$tst_port2 \
	'$ipv $port'
## TESTCASE:    local NetLabel IPv4, mac failure (domby)
    + recvmsg \
	mlsop=domby expres=fail err=EINTR \
	augrokfunc=augrok_default_inbound_rej \
	host=local type=netlabel op=sendrand_udp ipv=ipv4 port=$tst_port2 \
	'$ipv $port'
## TESTCASE:    remote NetLabel IPv4, mac success (eq)
    + recvmsg \
	mlsop=eq expres=success \
	host=remote type=netlabel op=sendrand_udp ipv=ipv4 port=$tst_port2 \
	'$ipv $port'
## TESTCASE:    remote NetLabel IPv4, mac failure (incomp)
    + recvmsg \
	mlsop=incomp expres=fail err=EINTR \
	augrokfunc=augrok_default_inbound_rej \
	host=remote type=netlabel op=sendrand_udp ipv=ipv4 port=$tst_port2 \
	'$ipv $port'
## TESTCASE:    remote NetLabel IPv4, mac success (dom)
    + recvmsg \
	mlsop=dom expres=success \
	augrokfunc=augrok_default \
	host=remote type=netlabel op=sendrand_udp ipv=ipv4 port=$tst_port2 \
	'$ipv $port'
## TESTCASE:    remote NetLabel IPv4, mac failure (domby)
    + recvmsg \
	mlsop=domby expres=fail err=EINTR \
	augrokfunc=augrok_default_inbound_rej \
	host=remote type=netlabel op=sendrand_udp ipv=ipv4 port=$tst_port2 \
	'$ipv $port'
# ## TESTCASE:    local IPsec IPv4, mac success (eq)
#     + recvmsg \
# 	mlsop=eq expres=success \
# 	host=local type=ipsec op=sendrand_udp ipv=ipv4 port=$tst_port3 \
# 	'$ipv $port'
# ## TESTCASE:    local IPsec IPv4, mac failure (incomp)
#     + recvmsg \
# 	mlsop=incomp expres=fail err=EINTR \
# 	augrokfunc=augrok_default_inbound_rej \
# 	host=local type=ipsec op=sendrand_udp ipv=ipv4 port=$tst_port3 \
# 	'$ipv $port'
# ## TESTCASE:    local IPsec IPv4, mac success (dom)
#     + recvmsg \
# 	mlsop=dom expres=success err=EINTR \
# 	augrokfunc=augrok_default \
# 	host=local type=ipsec op=sendrand_udp ipv=ipv4 port=$tst_port3 \
# 	'$ipv $port'
# ## TESTCASE:    local IPsec IPv4, mac failure (domby)
#     + recvmsg \
# 	mlsop=domby expres=fail err=EINTR \
# 	host=local type=ipsec op=sendrand_udp ipv=ipv4 port=$tst_port3 \
# 	'$ipv $port'
## TESTCASE:    remote IPsec IPv4, mac success (eq)
    + recvmsg \
	mlsop=eq expres=success \
	host=remote type=ipsec op=sendrand_udp ipv=ipv4 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    remote IPsec IPv4, mac failure (incomp)
    + recvmsg \
	mlsop=incomp expres=fail err=EINTR \
	augrokfunc=augrok_default_inbound_rej \
	host=remote type=ipsec op=sendrand_udp ipv=ipv4 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    remote IPsec IPv4, mac success (dom)
    + recvmsg \
	mlsop=dom expres=success \
	augrokfunc=augrok_default \
	host=remote type=ipsec op=sendrand_udp ipv=ipv4 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    remote IPsec IPv4, mac failure (domby)
    + recvmsg \
	mlsop=domby expres=fail err=EINTR \
	host=remote type=ipsec op=sendrand_udp ipv=ipv4 port=$tst_port3 \
	'$ipv $port'
# ## TESTCASE:    local IPsec IPv6, mac success (eq)
#     + recvmsg \
# 	mlsop=eq expres=success \
# 	host=local type=ipsec op=sendrand_udp ipv=ipv6 port=$tst_port3 \
# 	'$ipv $port'
# ## TESTCASE:    local IPsec IPv6, mac failure (incomp)
#     + recvmsg \
# 	mlsop=incomp expres=fail err=EINTR \
# 	augrokfunc=augrok_default_inbound_rej \
# 	host=local type=ipsec op=sendrand_udp ipv=ipv6 port=$tst_port3 \
# 	'$ipv $port'
# ## TESTCASE:    local IPsec IPv6, mac success (dom)
#     + recvmsg \
# 	mlsop=dom expres=success \
# 	augrokfunc=augrok_default \
# 	host=local type=ipsec op=sendrand_udp ipv=ipv6 port=$tst_port3 \
# 	'$ipv $port'
# ## TESTCASE:    local IPsec IPv6, mac failure (domby)
#     + recvmsg \
# 	mlsop=domby expres=fail err=EINTR \
# 	host=local type=ipsec op=sendrand_udp ipv=ipv6 port=$tst_port3 \
# 	'$ipv $port'
## TESTCASE:    remote IPsec IPv6, mac success (eq)
    + recvmsg \
	mlsop=eq expres=success \
	host=remote type=ipsec op=sendrand_udp ipv=ipv6 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    remote IPsec IPv6, mac failure (incomp)
    + recvmsg \
	mlsop=incomp expres=fail err=EINTR \
	augrokfunc=augrok_default_inbound_rej \
	host=remote type=ipsec op=sendrand_udp ipv=ipv6 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    remote IPsec IPv6, mac success (dom)
    + recvmsg \
	mlsop=dom expres=success \
	augrokfunc=augrok_default \
	host=remote type=ipsec op=sendrand_udp ipv=ipv6 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    remote IPsec IPv6, mac failure (domby)
    + recvmsg \
	mlsop=domby expres=fail err=EINTR \
	host=remote type=ipsec op=sendrand_udp ipv=ipv6 port=$tst_port3 \
	'$ipv $port'
fi

## SYSCALL:     recvmmsg()
## PURPOSE:
## Verify that incoming traffic is only allowed when the sensitivity label of
## the incoming packet dominates (is greater than or equal to) the receiving
## process.  These test cases
## make use of a remote test driver to generate traffic from the remote node
## to the host under test, see the setup_default() function above for details
## on configuring the remote test driver.  In addition to sanity checks using
## unlabled networking the test cases below test NetLabel and labeled IPsec
## labeled packets where the receiving process is equal to (mlsop=eq), is
## incomparable to (mlsop=incomp), dominates (mlsop=dom), and is dominated by
## (mlsop=domby) the remote test driver and the resulting network traffic.
## The test procedure is as follows:
##  1. Configure the test driver to generate traffic at a specific sensitivity
##     label after a delay
##  2. Configure the audit subsystem to watch for the syscall record
##  3. Execute the test case on the local system and verify the result
##  4. Check the audit log for the correct syscall result and in the case of
##     failure check for SELinux generated audit records indicating that
##     incoming traffic was rejected
if [[ $HOSTTYPE == x86_64 ]]; then
## TESTCASE:    local unlabeled IPv4, sanity check
    + recvmmsg \
        mlsop=eq expres=success \
        host=local type=unlabeled op=sendrand_udp ipv=ipv4 port=$tst_port1 \
        '$ipv $port'
## TESTCASE:    local unlabeled IPv6, sanity check
    + recvmmsg \
        mlsop=eq expres=success \
        host=local type=unlabeled op=sendrand_udp ipv=ipv6 port=$tst_port1 \
        '$ipv $port'
## TESTCASE:    remote unlabeled IPv4, sanity check
    + recvmmsg \
        mlsop=eq expres=success \
        host=remote type=unlabeled op=sendrand_udp ipv=ipv4 port=$tst_port1 \
        '$ipv $port'
## TESTCASE:    remote unlabeled IPv6, sanity check
    + recvmmsg \
        mlsop=eq expres=success \
        host=remote type=unlabeled op=sendrand_udp ipv=ipv6 port=$tst_port1 \
        '$ipv $port'
    if [[ $PPROFILE == lspp ]]; then
## TESTCASE:    local NetLabel IPv4, mac success (eq)
        + recvmmsg \
	    mlsop=eq expres=success \
	    host=local type=netlabel op=sendrand_udp ipv=ipv4 port=$tst_port2 \
	    '$ipv $port'
## TESTCASE:    local NetLabel IPv4, mac failure (incomp)
        + recvmmsg \
	    mlsop=incomp expres=fail err=EINTR \
	    augrokfunc=augrok_default_inbound_rej \
	    host=local type=netlabel op=sendrand_udp ipv=ipv4 port=$tst_port2 \
	    '$ipv $port'
## TESTCASE:    local NetLabel IPv4, mac success (dom)
        + recvmmsg \
	    mlsop=dom expres=success \
	    augrokfunc=augrok_default \
	    host=local type=netlabel op=sendrand_udp ipv=ipv4 port=$tst_port2 \
	    '$ipv $port'
## TESTCASE:    local NetLabel IPv4, mac failure (domby)
        + recvmmsg \
	    mlsop=domby expres=fail err=EINTR \
	    augrokfunc=augrok_default_inbound_rej \
	    host=local type=netlabel op=sendrand_udp ipv=ipv4 port=$tst_port2 \
	    '$ipv $port'
## TESTCASE:    remote NetLabel IPv4, mac success (eq)
        + recvmmsg \
	    mlsop=eq expres=success \
	    host=remote type=netlabel op=sendrand_udp ipv=ipv4 port=$tst_port2 \
	    '$ipv $port'
## TESTCASE:    remote NetLabel IPv4, mac failure (incomp)
        + recvmmsg \
	    mlsop=incomp expres=fail err=EINTR \
	    augrokfunc=augrok_default_inbound_rej \
	    host=remote type=netlabel op=sendrand_udp ipv=ipv4 port=$tst_port2 \
	    '$ipv $port'
## TESTCASE:    remote NetLabel IPv4, mac success (dom)
        + recvmmsg \
	    mlsop=dom expres=success \
	    augrokfunc=augrok_default \
	    host=remote type=netlabel op=sendrand_udp ipv=ipv4 port=$tst_port2 \
	    '$ipv $port'
## TESTCASE:    remote NetLabel IPv4, mac failure (domby)
        + recvmmsg \
	    mlsop=domby expres=fail err=EINTR \
	    augrokfunc=augrok_default_inbound_rej \
	    host=remote type=netlabel op=sendrand_udp ipv=ipv4 port=$tst_port2 \
	    '$ipv $port'
# ## TESTCASE:    local IPsec IPv4, mac success (eq)
#         + recvmmsg \
# 	    mlsop=eq expres=success \
# 	    host=local type=ipsec op=sendrand_udp ipv=ipv4 port=$tst_port3 \
# 	    '$ipv $port'
# ## TESTCASE:    local IPsec IPv4, mac failure (incomp)
#         + recvmmsg \
# 	    mlsop=incomp expres=fail err=EINTR \
# 	    augrokfunc=augrok_default_inbound_rej \
# 	    host=local type=ipsec op=sendrand_udp ipv=ipv4 port=$tst_port3 \
# 	    '$ipv $port'
# ## TESTCASE:    local IPsec IPv4, mac success (dom)
#         + recvmmsg \
# 	    mlsop=dom expres=success err=EINTR \
# 	    augrokfunc=augrok_default \
# 	    host=local type=ipsec op=sendrand_udp ipv=ipv4 port=$tst_port3 \
# 	    '$ipv $port'
# ## TESTCASE:    local IPsec IPv4, mac failure (domby)
#         + recvmmsg \
# 	    mlsop=domby expres=fail err=EINTR \
# 	    host=local type=ipsec op=sendrand_udp ipv=ipv4 port=$tst_port3 \
# 	    '$ipv $port'
## TESTCASE:    remote IPsec IPv4, mac success (eq)
        + recvmmsg \
	    mlsop=eq expres=success \
	    host=remote type=ipsec op=sendrand_udp ipv=ipv4 port=$tst_port3 \
	    '$ipv $port'
## TESTCASE:    remote IPsec IPv4, mac failure (incomp)
        + recvmmsg \
	    mlsop=incomp expres=fail err=EINTR \
	    augrokfunc=augrok_default_inbound_rej \
	    host=remote type=ipsec op=sendrand_udp ipv=ipv4 port=$tst_port3 \
	    '$ipv $port'
## TESTCASE:    remote IPsec IPv4, mac success (dom)
        + recvmmsg \
	    mlsop=dom expres=success \
	    augrokfunc=augrok_default \
	    host=remote type=ipsec op=sendrand_udp ipv=ipv4 port=$tst_port3 \
	    '$ipv $port'
## TESTCASE:    remote IPsec IPv4, mac failure (domby)
        + recvmmsg \
	    mlsop=domby expres=fail err=EINTR \
	    host=remote type=ipsec op=sendrand_udp ipv=ipv4 port=$tst_port3 \
	    '$ipv $port'
# ## TESTCASE:    local IPsec IPv6, mac success (eq)
#         + recvmmsg \
# 	    mlsop=eq expres=success \
# 	    host=local type=ipsec op=sendrand_udp ipv=ipv6 port=$tst_port3 \
# 	    '$ipv $port'
# ## TESTCASE:    local IPsec IPv6, mac failure (incomp)
#         + recvmmsg \
# 	    mlsop=incomp expres=fail err=EINTR \
# 	    augrokfunc=augrok_default_inbound_rej \
# 	    host=local type=ipsec op=sendrand_udp ipv=ipv6 port=$tst_port3 \
# 	    '$ipv $port'
# ## TESTCASE:    local IPsec IPv6, mac success (dom)
#         + recvmmsg \
# 	    mlsop=dom expres=success \
# 	    augrokfunc=augrok_default \
# 	    host=local type=ipsec op=sendrand_udp ipv=ipv6 port=$tst_port3 \
# 	    '$ipv $port'
# ## TESTCASE:    local IPsec IPv6, mac failure (domby)
#         + recvmmsg \
# 	    mlsop=domby expres=fail err=EINTR \
# 	    host=local type=ipsec op=sendrand_udp ipv=ipv6 port=$tst_port3 \
# 	    '$ipv $port'
## TESTCASE:    remote IPsec IPv6, mac success (eq)
        + recvmmsg \
	    mlsop=eq expres=success \
	    host=remote type=ipsec op=sendrand_udp ipv=ipv6 port=$tst_port3 \
	    '$ipv $port'
## TESTCASE:    remote IPsec IPv6, mac failure (incomp)
        + recvmmsg \
	    mlsop=incomp expres=fail err=EINTR \
	    augrokfunc=augrok_default_inbound_rej \
	    host=remote type=ipsec op=sendrand_udp ipv=ipv6 port=$tst_port3 \
	    '$ipv $port'
## TESTCASE:    remote IPsec IPv6, mac success (dom)
        + recvmmsg \
	    mlsop=dom expres=success \
	    augrokfunc=augrok_default \
	    host=remote type=ipsec op=sendrand_udp ipv=ipv6 port=$tst_port3 \
	    '$ipv $port'
## TESTCASE:    remote IPsec IPv6, mac failure (domby)
        + recvmmsg \
	    mlsop=domby expres=fail err=EINTR \
	    host=remote type=ipsec op=sendrand_udp ipv=ipv6 port=$tst_port3 \
	    '$ipv $port'
    fi
fi

## SYSCALL:     sendmsg()
## PURPOSE:
## Verify that outgoing traffic is only allowed when the sensitivity label
## of the sending process is equal to the sensitivity label on the IPsec SA
## to process/transform the traffic/packet.  These test cases make use of a
## remote test driver to receive traffic from the host under test, see the
## setup_default() function above for details on configuring the remote test
## driver.  In addition to sanity checks using unlabeled networking the test
## cases below test labeled IPsec connections where the sending process is
## equal to (mlsop=eq), is incomparable to (mlsop=incomp),
## dominates (mlsop=dom), and is dominated by (mlsop=domby) the IPsec SA.
## The test procedure is as follows:
##  1. Configure the test driver to accept new connections at a specific
##     sensitivity label
##  2. Configure the audit subsystem to watch for the syscall record
##  3. Execute the test case on the local system and verify the result
##  4. Check the audit log for the correct syscall result
## TESTCASE:    local unlabeled IPv4, sanity check
+ sendmsg \
    mlsop=eq expres=success \
    host=local type=unlabeled op=recv_udp ipv=ipv4 srcport=$tst_port1 \
    '$host_remote $port:$srcport'
## TESTCASE:    local unlabeled IPv6, sanity check
+ sendmsg \
    mlsop=eq expres=success \
    host=local type=unlabeled op=recv_udp ipv=ipv6 srcport=$tst_port1 \
    '$host_remote $port:$srcport'
## TESTCASE:    remote unlabeled IPv4, sanity check
+ sendmsg \
    mlsop=eq expres=success \
    host=remote type=unlabeled op=recv_udp ipv=ipv4 srcport=$tst_port1 \
    '$host_remote $port:$srcport'
## TESTCASE:    remote unlabeled IPv6, sanity check
+ sendmsg \
    mlsop=eq expres=success \
    host=remote type=unlabeled op=recv_udp ipv=ipv6 srcport=$tst_port1 \
    '$host_remote $port:$srcport'

## SYSCALL:     sendto()
## PURPOSE:
## Verify that outgoing traffic is only allowed when the sensitivity label
## of the sending process is equal to the sensitivity label on the IPsec SA
## to process/transform the traffic/packet.  These test cases make use of a
## remote test driver to receive traffic from the host under test, see the
## setup_default() function above for details on configuring the remote test
## driver.  In addition to sanity checks using unlabeled networking the test
## cases below test labeled IPsec connections where the sending process is
## equal to (mlsop=eq), is incomparable to (mlsop=incomp),
## dominates (mlsop=dom), and is dominated by (mlsop=domby) the IPsec SA.
## The test procedure is as follows:
##  1. Configure the test driver to accept new connections at a specific
##     sensitivity label
##  2. Configure the audit subsystem to watch for the syscall record
##  3. Execute the test case on the local system and verify the result
##  4. Check the audit log for the correct syscall result
## TESTCASE:    local unlabeled IPv4, sanity check
+ sendto \
    mlsop=eq expres=success \
    host=local type=unlabeled op=recv_udp ipv=ipv4 srcport=$tst_port1 \
    '$host_remote $port:$srcport'
## TESTCASE:    local unlabeled IPv6, sanity check
+ sendto \
    mlsop=eq expres=success \
    host=local type=unlabeled op=recv_udp ipv=ipv6 srcport=$tst_port1 \
    '$host_remote $port:$srcport'
## TESTCASE:    remote unlabeled IPv4, sanity check
+ sendto \
    mlsop=eq expres=success \
    host=remote type=unlabeled op=recv_udp ipv=ipv4 srcport=$tst_port1 \
    '$host_remote $port:$srcport'
## TESTCASE:    remote unlabeled IPv6, sanity check
+ sendto \
    mlsop=eq expres=success \
    host=remote type=unlabeled op=recv_udp ipv=ipv6 srcport=$tst_port1 \
    '$host_remote $port:$srcport'

## SYSCALL:     read()
## PURPOSE:
## Verify that incoming traffic is only allowed when the sensitivity label of
## the incoming packet dominates (is greater than or equal to) the receiving
## process.  These test cases
## make use of a remote test driver to generate traffic from the remote node
## to the host under test, see the setup_default() function above for details
## on configuring the remote test driver.  In addition to sanity checks using
## unlabled networking the test cases below test NetLabel and labeled IPsec
## labeled packets where the receiving process is equal to (mlsop=eq), is
## incomparable to (mlsop=incomp), dominates (mlsop=dom), and is dominated by
## (mlsop=domby) the remote test driver and the resulting network traffic.
## The test procedure is as follows:
##  1. Configure the test driver to generate traffic at a specific sensitivity
##     label after a delay
##  2. Configure the audit subsystem to watch for the syscall record
##  3. Execute the test case on the local system and verify the result
##  4. Check the audit log for the correct syscall result and in the case of
##     failure check for SELinux generated audit records indicating that
##     incoming traffic was rejected
## TESTCASE:    local unlabeled IPv4, sanity check
+ read \
    mlsop=eq expres=success \
    auwatchfunc=auwatch_syscall augrokfunc=augrok_syscall \
    host=local type=unlabeled op=sendrand_udp ipv=ipv4 port=$tst_port1 \
    '$ipv $port'
## TESTCASE:    local unlabeled IPv6, sanity check
+ read \
    mlsop=eq expres=success \
    auwatchfunc=auwatch_syscall augrokfunc=augrok_syscall \
    host=local type=unlabeled op=sendrand_udp ipv=ipv6 port=$tst_port1 \
    '$ipv $port'
## TESTCASE:    remote unlabeled IPv4, sanity check
+ read \
    mlsop=eq expres=success \
    auwatchfunc=auwatch_syscall augrokfunc=augrok_syscall \
    host=remote type=unlabeled op=sendrand_udp ipv=ipv4 port=$tst_port1 \
    '$ipv $port'
## TESTCASE:    remote unlabeled IPv6, sanity check
+ read \
    mlsop=eq expres=success \
    auwatchfunc=auwatch_syscall augrokfunc=augrok_syscall \
    host=remote type=unlabeled op=sendrand_udp ipv=ipv6 port=$tst_port1 \
    '$ipv $port'
if [[ $PPROFILE == lspp ]]; then
## TESTCASE:    local NetLabel IPv4, mac success (eq)
    + read \
	mlsop=eq expres=success \
	auwatchfunc=auwatch_syscall augrokfunc=augrok_syscall \
	host=local type=netlabel op=sendrand_udp ipv=ipv4 port=$tst_port2 \
	'$ipv $port'
## TESTCASE:    local NetLabel IPv4, mac failure (incomp)
    + read \
	mlsop=incomp expres=fail err=EINTR \
	auwatchfunc=auwatch_syscall augrokfunc=augrok_syscall_inbound_rej \
	host=local type=netlabel op=sendrand_udp ipv=ipv4 port=$tst_port2 \
	'$ipv $port'
## TESTCASE:    local NetLabel IPv4, mac success (dom)
    + read \
	mlsop=dom expres=success \
	auwatchfunc=auwatch_syscall augrokfunc=augrok_syscall \
	host=local type=netlabel op=sendrand_udp ipv=ipv4 port=$tst_port2 \
	'$ipv $port'
## TESTCASE:    local NetLabel IPv4, mac failure (domby)
    + read \
	mlsop=domby expres=fail err=EINTR \
	auwatchfunc=auwatch_syscall augrokfunc=augrok_syscall_inbound_rej \
	host=local type=netlabel op=sendrand_udp ipv=ipv4 port=$tst_port2 \
	'$ipv $port'
## TESTCASE:    remote NetLabel IPv4, mac success (eq)
    + read \
	mlsop=eq expres=success \
	auwatchfunc=auwatch_syscall augrokfunc=augrok_syscall \
	host=remote type=netlabel op=sendrand_udp ipv=ipv4 port=$tst_port2 \
	'$ipv $port'
## TESTCASE:    remote NetLabel IPv4, mac failure (incomp)
    + read \
	mlsop=incomp expres=fail err=EINTR \
	auwatchfunc=auwatch_syscall augrokfunc=augrok_syscall_inbound_rej \
	host=remote type=netlabel op=sendrand_udp ipv=ipv4 port=$tst_port2 \
	'$ipv $port'
## TESTCASE:    remote NetLabel IPv4, mac success (dom)
    + read \
	mlsop=dom expres=success \
	auwatchfunc=auwatch_syscall augrokfunc=augrok_syscall \
	host=remote type=netlabel op=sendrand_udp ipv=ipv4 port=$tst_port2 \
	'$ipv $port'
## TESTCASE:    remote NetLabel IPv4, mac failure (domby)
    + read \
	mlsop=domby expres=fail err=EINTR \
	auwatchfunc=auwatch_syscall augrokfunc=augrok_syscall_inbound_rej \
	host=remote type=netlabel op=sendrand_udp ipv=ipv4 port=$tst_port2 \
	'$ipv $port'
# ## TESTCASE:    local IPsec IPv4, mac success (eq)
#     + read \
# 	mlsop=eq expres=success \
# 	auwatchfunc=auwatch_syscall augrokfunc=augrok_syscall \
# 	host=local type=ipsec op=sendrand_udp ipv=ipv4 port=$tst_port3 \
# 	'$ipv $port'
# ## TESTCASE:    local IPsec IPv4, mac failure (incomp)
#     + read \
# 	mlsop=incomp expres=fail err=EINTR \
# 	auwatchfunc=auwatch_syscall augrokfunc=augrok_syscall_inbound_rej \
# 	host=local type=ipsec op=sendrand_udp ipv=ipv4 port=$tst_port3 \
# 	'$ipv $port'
# ## TESTCASE:    local IPsec IPv4, mac success (dom)
#     + read \
# 	mlsop=dom expres=success \
# 	auwatchfunc=auwatch_syscall augrokfunc=augrok_syscall \
# 	host=local type=ipsec op=sendrand_udp ipv=ipv4 port=$tst_port3 \
# 	'$ipv $port'
# ## TESTCASE:    local IPsec IPv4, mac failure (domby)
#     + read \
# 	mlsop=domby expres=fail err=EINTR \
# 	auwatchfunc=auwatch_syscall augrokfunc=augrok_syscall \
# 	host=local type=ipsec op=sendrand_udp ipv=ipv4 port=$tst_port3 \
# 	'$ipv $port'
## TESTCASE:    remote IPsec IPv4, mac success (eq)
    + read \
	mlsop=eq expres=success \
	auwatchfunc=auwatch_syscall augrokfunc=augrok_syscall \
	host=remote type=ipsec op=sendrand_udp ipv=ipv4 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    remote IPsec IPv4, mac failure (incomp)
    + read \
	mlsop=incomp expres=fail err=EINTR \
	auwatchfunc=auwatch_syscall augrokfunc=augrok_syscall_inbound_rej \
	host=remote type=ipsec op=sendrand_udp ipv=ipv4 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    remote IPsec IPv4, mac success (dom)
    + read \
	mlsop=dom expres=success \
	auwatchfunc=auwatch_syscall augrokfunc=augrok_syscall \
	host=remote type=ipsec op=sendrand_udp ipv=ipv4 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    remote IPsec IPv4, mac failure (domby)
    + read \
	mlsop=domby expres=fail err=EINTR \
	auwatchfunc=auwatch_syscall augrokfunc=augrok_syscall \
	host=remote type=ipsec op=sendrand_udp ipv=ipv4 port=$tst_port3 \
	'$ipv $port'
# ## TESTCASE:    local IPsec IPv6, mac success (eq)
#     + read \
# 	mlsop=eq expres=success \
# 	auwatchfunc=auwatch_syscall augrokfunc=augrok_syscall \
# 	host=local type=ipsec op=sendrand_udp ipv=ipv6 port=$tst_port3 \
# 	'$ipv $port'
# ## TESTCASE:    local IPsec IPv6, mac failure (incomp)
#     + read \
# 	mlsop=incomp expres=fail err=EINTR \
# 	auwatchfunc=auwatch_syscall augrokfunc=augrok_syscall_inbound_rej \
# 	host=local type=ipsec op=sendrand_udp ipv=ipv6 port=$tst_port3 \
# 	'$ipv $port'
# ## TESTCASE:    local IPsec IPv6, mac success (dom)
#     + read \
# 	mlsop=dom expres=success \
# 	auwatchfunc=auwatch_syscall augrokfunc=augrok_syscall \
# 	host=local type=ipsec op=sendrand_udp ipv=ipv6 port=$tst_port3 \
# 	'$ipv $port'
# ## TESTCASE:    local IPsec IPv6, mac failure (domby)
#     + read \
# 	mlsop=domby expres=fail err=EINTR \
# 	auwatchfunc=auwatch_syscall augrokfunc=augrok_syscall \
# 	host=local type=ipsec op=sendrand_udp ipv=ipv6 port=$tst_port3 \
# 	'$ipv $port'
## TESTCASE:    remote IPsec IPv6, mac success (eq)
    + read \
	mlsop=eq expres=success \
	auwatchfunc=auwatch_syscall augrokfunc=augrok_syscall \
	host=remote type=ipsec op=sendrand_udp ipv=ipv6 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    remote IPsec IPv6, mac failure (incomp)
    + read \
	mlsop=incomp expres=fail err=EINTR \
	auwatchfunc=auwatch_syscall augrokfunc=augrok_syscall_inbound_rej \
	host=remote type=ipsec op=sendrand_udp ipv=ipv6 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    remote IPsec IPv6, mac success (dom)
    + read \
	mlsop=dom expres=success err=EINTR \
	auwatchfunc=auwatch_syscall augrokfunc=augrok_syscall \
	host=remote type=ipsec op=sendrand_udp ipv=ipv6 port=$tst_port3 \
	'$ipv $port'
## TESTCASE:    remote IPsec IPv6, mac failure (domby)
    + read \
	mlsop=domby expres=fail err=EINTR \
	auwatchfunc=auwatch_syscall augrokfunc=augrok_syscall \
	host=remote type=ipsec op=sendrand_udp ipv=ipv6 port=$tst_port3 \
	'$ipv $port'
fi
