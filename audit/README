(c) Copyright Hewlett-Packard Development Company, L.P., 2005

| Quickstart
+-----------

sudo make run

It's not actually necessary to build as root.  If you'd prefer to build as a
normal user, you can do:

make -C syscalls
make -C fail-safe
sudo make run

This avoids the directories that don't actually build yet.

| Using run.bash
+---------------

From the top level, you just want to use "make run".  run.bash will tell you
this if you try to use it directly.  The "run" target will execute run.bash in
each subdirectory then tally the results.

To run an individual set of tests, you can use "make run" or call run.bash.
Using the latter gives you control over which tests are executed.  For example:

    cd syscalls
    sudo ./run.bash -- -ALL +chown

It's a little cryptic, but here's why: First, run.bash takes arguments of its
own, for example --verbose.  After those arguments, i.e. following --, you can
add or remove tests.  -ALL removes all the tests that were listed in run.conf.
Then you add back the test that you want to run, in this case +chown

| Writing run.conf
+-----------------

This configuration file is a bash script that sourced by run.bash.  It
primarily consists of a list of tests to run, but can also contain
some variable and function settings.

The list of tests is built using two functions (+ and -) provided by
run.bash.  To add a test to the list:

  + testname

Generally it's unnecessary in this file to remove tests from the list,
but you can do so with:

  - testname

Variables
---------
VARIATIONS (array)

    - by default, VARIATIONS=().  When + is called, the specified
      test simply added to the list verbatim.

    - When VARIATIONS is defined, tests are added to the list
      through a more complex process: for each variation in the
      list, the make_variation function is called with "testname"
      "variation", and it is expected to echo back a string which
      fully describes the resulting test.  The default
      make_variation function simply joins them with a separating
      space.

    - The + function (as well as -) will add all variations by
      default, but can accept a list of variations instead, for
      example:

      VARIATIONS=( empty_input good_input bad_input huge_input )

      # huge_input doesn't apply to test1
      + test1
      - test1 huge_input

      # test2 doesn't take any input
      + test2 empty_input

Functions
---------
make_variation(testcase, variation)

    - default is: echo "$1 $2" (see run.bash)

run_test(testcase)

    - default is: eval "$1" (see run.bash)

    - run_test is called with only one argument, which is the result
      of make_variation when the test list was built

    - if you override run_test, make sure to use eval in case $1
      contains any quoted arguments

    - an example, following the VARIATIONS example above:

      function run_test {
        declare input=${1##* }      # remove up to last space
        set -- "${1% *}"            # remove last space and following
        case $input in
          empty_input) eval "tests/$1 </dev/null"; return $? ;;
          good_input)  eval "tests/$1 <input/good"; return $? ;;
          bad_input)   eval "tests/$1 <input/bad"; return $? ;;
          huge_input)  eval "tests/$1 <input/huge"; return $? ;;
          *) echo "Error: unknown variation"; return 2 ;;
        esac
      }

startup_hook()
    
    - default is: true (see run.bash)

    - can be defined to do any special setup required by your
      tests.  Note this runs prior to looping through the tests,
      not prior to each test.  If you need special setup prior to
      running each test, put it in run_test

cleanup_hook()

    - default is: true (see run.bash)

    - runs after looping through all the tests

