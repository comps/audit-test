(c) Copyright Hewlett-Packard Development Company, L.P., 2005

| Quickstart
+-----------

sudo make run

It's not actually necessary to build as root.  If you'd prefer to build as a
normal user, you can do:

make all
sudo make run

Dependencies
------------

audit-test requires the following packages in order to run:

expect
audit-libs-devel

| Using run.bash
+---------------

From the top level, you just want to use "make run".  The "run" target will
execute run.bash in each subdirectory then tally the results.

To run an individual set of tests, you can use "make run" or call run.bash.
Using the latter gives you control over which tests are executed.  For example:

    cd syscalls
    sudo ./run.bash chown

| Writing tests
+--------------

Each test case is expected to be an independent executable that returns an
exit status.  An executable can be shared between tests by using
comand-line options to select test variations.  For example, the syscalls
directory uses a single executable "syscalls" which takes options to
indicate which syscall should be tested.  You should choose whichever
method works best for your set of tests.

The exit status is interpreted by the test harness (run.bash) as follows:

    0     - PASS, meaning that the test behaved as expected
    1     - FAIL, meaning that the test did not PASS
    other - ERROR, meaning that there was an error which prevented the test from
            being performed, such as a setup step which did not complete
            correctly, or a failed memory allocation, etc.

The test case is expected to generate debugging information to either stdout or
stderr.  The debugging information is captured by the harness and displayed only
when requested by --verbose, --debug, or investigation of run.log

Bash tests
----------
Tests written in bash can make use of common functions in utils/functions.bash.
The library should be loaded with this snippet at the top of the test case:

    export PATH=/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin
    if [[ -z $TOPDIR ]]; then
        TOPDIR=$(
            while [[ ! $PWD -ef / ]]; do
                [[ -f rules.mk ]] && { echo $PWD; exit 0; }
                cd ..
            done
            exit 1
        ) || { echo "Can't find TOPDIR, where is rules.mk?" >&2; exit 2; }
        export TOPDIR
    fi
    PATH=$TOPDIR/utils:$PATH

    source functions.bash

This snippet additionally puts the utils directory in the PATH, which is helpful
for running augrok and other shared utility programs.

If you augment functions.bash, beware that it is expected to behave a litle
differently from the test cases.  Zero status is success, non-zero is error
(there is no distinction between fail/error in the utility functions).
More importantly, debugging output goes to stdout, error output goes to stderr.
The reason for this is that the common functions are also used by the test
harness, which wants to be able to /dev/null the debug info without losing the
error messages.

| Writing run.conf
+-----------------

This configuration file is a bash script that sourced by run.bash.  It
primarily consists of a list of tests to run, but can also contain
some variable and function settings.

The list of tests is built using two functions (+ and -) provided by
run.bash.  To add a test to the list:

  + testname

Generally it's unnecessary in this file to remove tests from the list,
but you can do so with:

  - testname

Variables
---------
VARIATIONS (array)

    - by default, VARIATIONS=().  When + is called, the specified
      test simply added to the list verbatim.

    - When VARIATIONS is defined, tests are added to the list
      through a more complex process: for each variation in the
      list, the make_variation function is called with "testname"
      "variation", and it is expected to echo back a string which
      fully describes the resulting test.  The default
      make_variation function simply joins them with a separating
      space.

    - The + function (as well as -) will add all variations by
      default, but can accept a list of variations instead, for
      example:

      VARIATIONS=( empty_input good_input bad_input huge_input )

      # huge_input doesn't apply to test1
      + test1
      - test1 huge_input

      # test2 doesn't take any input
      + test2 empty_input

Functions
---------
make_variation(testcase, variation)

    - default is: echo "$1 $2" (see run.bash)

run_test(testcase)

    - default is: eval "$1" (see run.bash)

    - run_test is called with only one argument, which is the result
      of make_variation when the test list was built

    - if you override run_test, make sure to use eval in case $1
      contains any quoted arguments

    - an example, following the VARIATIONS example above:

      function run_test {
        declare input=${1##* }      # remove up to last space
        set -- "${1% *}"            # remove last space and following
        case $input in
          empty_input) eval "tests/$1 </dev/null"; return $? ;;
          good_input)  eval "tests/$1 <input/good"; return $? ;;
          bad_input)   eval "tests/$1 <input/bad"; return $? ;;
          huge_input)  eval "tests/$1 <input/huge"; return $? ;;
          *) echo "Error: unknown variation"; return 2 ;;
        esac
      }

startup_hook()
    
    - default is: true (see run.bash)

    - can be defined to do any special setup required by your
      tests.  Note this runs prior to looping through the tests,
      not prior to each test.  If you need special setup prior to
      running each test, put it in run_test

cleanup_hook()

    - default is: true (see run.bash)

    - runs after looping through all the tests

