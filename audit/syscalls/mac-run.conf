#!/bin/bash
# =============================================================================
# (c) Copyright Hewlett-Packard Development Company, L.P., 2007
#
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of version 2 the GNU General Public License as
#   published by the Free Software Foundation.
#   
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#   
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
# =============================================================================

## Unless specified, the expected error for test failures is EACCES.

##
## FS syscalls
##

## SYSCALL:	creat()
## PURPOSE:
## Verify that the creat() syscall is subject to the correct MLS constraints
## when creating new files in the file system.  There are two types of
## testcases in this set of tests.  The first, using the 'perm=dir_add_name'
## variable, tries to create a new file in a directory which has a MLS
## sensitivity label which may or may not be accessible to the test process
## executing the creat() syscall.  The second, using the 'perm=file_create'
## variable, tries to create a new file which itself has a MLS sensitvity label
## which may or may not be allowed by the security policy.  The test procedure
## is as follows:
##  1. Create a new parent directory and if perm=dir_add_name then label the
##     directory such that the MLS relationship between the parent directory
##     and the test process is defined by the mlsop variable (dom, domby,
##     incomp), if perm=file_create then create the parent directory with the
##     same MLS sensitvity label as the test process
##  2. If perm=file_create then call the setfscreatecon() API so that a new
##     file system object will be created with a MLS sensitivity label
##     such that the MLS relationship between the test process and the
##     newly created file system object is defined by the mlsop variable (dom,
##     domby, incomp)
##  3. Execute the test process and attempt to create a new file, verify
##     the result
##  4. Check the audit log for the correct syscall result
+ creat perm=dir_add_name expres=success mlsop=eq
+ creat perm=dir_add_name expres=fail mlsop=domby 
+ creat perm=file_create expres=success mlsop=eq
+ creat perm=file_create expres=fail mlsop=dom 

## SYSCALL:	execve()
## PURPOSE:
## Verify that the execve() syscall is subject to the correct MLS constraints
## when executing a program.  The test cases below try to execute a file which
## has a MLS sensitivity label which may or may not be accessible to the test
## process executing the execve() syscall.  The test procedure is as follows:
##  1. Create an executable test file and label it in such a way that the MLS
##     relationship between the file and the test process is defined by the
##     mlsop variable (dom, domby, incomp)
##  2. Execute the test process and attempt the execve() syscall, verify
##     the results
##  3. Check the audit log for the correct syscall result
+ execve perm=file_exec expres=success mlsop=eq
+ execve perm=file_exec expres=success mlsop=dom
+ execve perm=file_exec expres=fail mlsop=domby 
+ execve perm=file_exec expres=fail mlsop=incomp 

## SYSCALL:	link()
## PURPOSE:
## Verify that the link() syscall is subject to the correct MLS constraints
## when creating new hard links in the file system.  There are two types of
## testcases in this set of tests.  The first, using the 'perm=dir_add_name'
## variable, tries to create a new hard link in a directory which has a MLS
## sensitivity label which may or may not be accessible to the test process
## executing the link() syscall.  The second, using the 'perm=file_link'
## variable, tries to create a hard link to a source file which has a MLS
## sensitvity label which may or may not be accessible to the subject test
## process executing the link() syscall.  The test procedure is as follows:
##  1. Create a new source file, if perm=file_link then label the source
##     source file such that the MLS relationship between the file and the
##     test processes is defined by the mlsop variable (dom, domby, incomp)
##  2. Create a new destination directory for the hard link, if
##     perm=dir_add_name then label the directory such that the MLS
##     relationship between the directory and the test processes is defined by
##     the mlsop variable (dom, domby, incomp)
##  3. Execute the test process and attempt to create a hard link, verify the
##     result
##  4. Check the audit log for the correct syscall result
+ link perm=dir_add_name which=new expres=success mlsop=eq
+ link perm=dir_add_name which=new expres=fail mlsop=domby 
+ link perm=file_link which=old expres=success mlsop=eq
+ link perm=file_link which=old expres=fail mlsop=dom 
+ link perm=file_link which=old expres=fail mlsop=domby 
+ link perm=file_link which=old expres=fail mlsop=incomp 

## SYSCALL:	linkat()
## PURPOSE:
## Verify that the linkat() syscall is subject to the correct MLS constraints
## when creating new hard links in the file system, relative to a directory file
## descriptor. See above for more details.
## TESTCASE:    create a link in a new dir, mac success
+ linkat perm=dir_add_name at=1 which=new expres=success mlsop=eq
## TESTCASE:    create a link in a new dir, mac failure in the new dir (dom)
+ linkat perm=dir_add_name at=1 which=new expres=fail mlsop=dom 
## TESTCASE:    create a link in a new dir, mac failure in the new dir (domby)
+ linkat perm=dir_add_name at=1 which=new expres=fail mlsop=domby 
## TESTCASE:    create a link in a new dir, mac failure in the new dir (incomp)
+ linkat perm=dir_add_name at=1 which=new expres=fail mlsop=incomp 
## TESTCASE:    create a link in a new dir, mac success
+ linkat perm=file_link at=1 which=old expres=success mlsop=eq
## TESTCASE:    create a link in a new dir, mac failure in the src file (dom)
+ linkat perm=file_link at=1 which=old expres=fail mlsop=dom 
## TESTCASE:    create a link in a new dir, mac failure in the src file (domby)
+ linkat perm=file_link at=1 which=old expres=fail mlsop=domby 
## TESTCASE:    create a link in a new dir, mac failure in the src file (incomp)
+ linkat perm=file_link at=1 which=old expres=fail mlsop=incomp 

## SYSCALL:	mkdir()
## PURPOSE:
## Verify that the mkdir() syscall is subject to the correct MLS constraints
## when creating new directories in the file system.  There are two types of
## testcases in this set of tests.  The first, using the 'perm=dir_add_name'
## variable, tries to create a new sub-directory in a directory which has a MLS
## sensitivity label which may or may not be accessible to the test process
## executing the mkdir() syscall.  The second, using the 'perm=file_create'
## variable, tries to create a new directory which itself has a MLS sensitvity
## label which may or may not be allowed by the security policy.  The test
## procedure is as follows:
##  1. Create a new parent directory and if perm=dir_add_name then label the
##     directory such that the MLS relationship between the parent directory
##     and the test process is defined by the mlsop variable (dom, domby,
##     incomp), if perm=file_create then create the parent directory with the
##     same MLS sensitvity label as the test process
##  2. If perm=file_create then call the setfscreatecon() API so that a new
##     file system object will be created with a MLS sensitivity label
##     such that the MLS relationship between the test process and the
##     newly created file system object is defined by the mlsop variable (dom,
##     domby, incomp)
##  3. Execute the test process and attempt to create a new directory, verify
##     the result
##  4. Check the audit log for the correct syscall result
+ mkdir perm=dir_add_name expres=success mlsop=eq
+ mkdir perm=dir_add_name expres=fail mlsop=dom 
+ mkdir perm=dir_add_name expres=fail mlsop=domby 
+ mkdir perm=dir_add_name expres=fail mlsop=incomp 
+ mkdir perm=file_create expres=success mlsop=eq
+ mkdir perm=file_create expres=fail mlsop=domby 

## SYSCALL:     mkdirat()
## PURPOSE:
## Verify that the mkdirat() syscall is subject to the correct MLS constraints
## when creating new directories in the file system, relative to a directory
## file descriptor. See above for more details.
## TESTCASE:    create a new directory, mac success
+ mkdirat perm=dir_add_name at=1 expres=success mlsop=eq
## TESTCASE:    create a new directory, mac failure (dom)
+ mkdirat perm=dir_add_name at=1 expres=fail mlsop=dom 
## TESTCASE:    create a new directory, mac failure (domby)
+ mkdirat perm=dir_add_name at=1 expres=fail mlsop=domby 
## TESTCASE:    create a new directory, mac failure (incomp)
+ mkdirat perm=dir_add_name at=1 expres=fail mlsop=incomp 
## TESTCASE:    create a new filesystem directory, mac success
+ mkdirat perm=file_create at=1 expres=success mlsop=eq
## TESTCASE:    create a new filesystem directory, mac failure (dom)
+ mkdirat perm=file_create at=1 expres=fail mlsop=dom 
## TESTCASE:    create a new filesystem directory, mac failure (domby)
+ mkdirat perm=file_create at=1 expres=fail mlsop=domby 
## TESTCASE:    create a new filesystem directory, mac failure (incomp)
+ mkdirat perm=file_create at=1 expres=fail mlsop=incomp 

## SYSCALL:	mknod()
## PURPOSE:
## Verify that the mknod() syscall is subject to the correct MLS constraints
## when creating new nodes in the file system.  There are two types of
## testcases in this set of tests.  The first, using the 'perm=dir_add_name'
## variable, tries to create a new node in a directory which has a MLS
## sensitivity label which may or may not be accessible to the test process
## executing the mknod() syscall.  The second, using the 'perm=file_create'
## variable, tries to create a new node which itself has a MLS sensitvity
## label which may or may not be allowed by the security policy.  The test
## procedure is as follows:
##  1. Create a new parent directory and if perm=dir_add_name then label the
##     directory such that the MLS relationship between the parent directory
##     and the test process is defined by the mlsop variable (dom, domby,
##     incomp), if perm=file_create then create the parent directory with the
##     same MLS sensitvity label as the test process
##  2. If perm=file_create then call the setfscreatecon() API so that a new
##     file system object will be created with a MLS sensitivity label
##     such that the MLS relationship between the test process and the
##     newly created file system object is defined by the mlsop variable (dom,
##     domby, incomp)
##  3. Execute the test process and attempt to create a new node, verify the
##     result
##  4. Check the audit log for the correct syscall result
+ mknod perm=dir_add_name expres=success mlsop=eq
+ mknod perm=dir_add_name expres=fail mlsop=dom 
+ mknod perm=file_create expres=success mlsop=eq
+ mknod perm=file_create expres=fail mlsop=incomp 

## SYSCALL:	mknodat()
## PURPOSE:
## Verify that the mknodat() syscall is subject to the correct MLS constraints
## when creating new nodes in the file system, relative to a directory
## file descriptor. See above for more details.
## TESTCASE:    create a new filesystem node, mac success
+ mknodat perm=dir_add_name at=1 expres=success mlsop=eq
## TESTCASE:    create a new filesystem node, mac failure (dom)
+ mknodat perm=dir_add_name at=1 expres=fail mlsop=dom 
## TESTCASE:    create a new filesystem node, mac failure (domby)
+ mknodat perm=dir_add_name at=1 expres=fail mlsop=domby 
## TESTCASE:    create a new filesystem node, mac failure (incomp)
+ mknodat perm=dir_add_name at=1 expres=fail mlsop=incomp 
## TESTCASE:    create a new filesystem node, mac success
+ mknodat perm=file_create at=1 expres=success mlsop=eq
## TESTCASE:    create a new filesystem node, mac failure (dom)
+ mknodat perm=file_create at=1 expres=fail mlsop=dom 
## TESTCASE:    create a new filesystem node, mac failure (domby)
+ mknodat perm=file_create at=1 expres=fail mlsop=domby 
## TESTCASE:    create a new filesystem node, mac failure (incomp)
+ mknodat perm=file_create at=1 expres=fail mlsop=incomp 

## SYSCALL:	mount()
## PURPOSE:
## Verify that the mount() syscall is subject to the correct MLS constraints
## when mounting a filesystem.  The test cases below try to mount a filesystem
## at a mount point which has a MLS sensitivity label which may or may not be
## accessible to the test process executing the mount() syscall.  The test
## procedure is as follows:

##  1. Create a new directory which will be the mount point and label it in such
##     a way that the MLS relationship between the directory and the test
##     process is defined by the mlsop variable (dom, domby, incomp)
##  2. Execute the test process and attempt the mount() syscall, verify
##     the results
##  3. Check the audit log for the correct syscall result
+ mount perm=dir_mount expres=success mlsop=eq
+ mount perm=dir_mount expres=fail mlsop=dom 
+ mount perm=dir_mount expres=fail mlsop=domby 
+ mount perm=dir_mount expres=fail mlsop=incomp 

## SYSCALL:	open()
## PURPOSE:
## Verify that the open() syscall is subject to the correct MLS constraints
## when opening new or existing files.  There are four types of testcases in
## this set of tests.  The first, using the 'perm=dir_add_name' variable, tries
## to create a new file in a directory which has a MLS sensitivity label which
## may or may not be accessible to the test process executing the open()
## syscall.  The second, using the 'perm=file_create' variable, tries to create
## a new file which itself has a MLS sensitvity label which may or may not be
## allowed by the security policy.  The third test type, using the
## 'perm=file_read' variable, tries to open a file for reading which has a MLS
## sensitivity label which may or may not be accessible to the test process
## executing the open() syscall.  The fourth test type, using the
## 'perm=file_write' variable, tries to open a file for writing which has a MLS
## sensitivity label which may or may not be accessible to the test process
## executing the open() syscall.  The test procedure is as follows:
##  1. Create a new parent directory and if perm=dir_add_name then label the
##     directory such that the MLS relationship between the parent directory
##     and the test process is defined by the mlsop variable (dom, domby,
##     incomp), otherwise create then create the parent directory with the
##     same MLS sensitvity label as the test process
##  2. If perm=file_create then call the setfscreatecon() API so that a new
##     file system object will be created with a MLS sensitivity label
##     such that the MLS relationship between the test process and the
##     newly created file system object is defined by the mlsop variable (dom,
##     domby, incomp)
##  3. If perm=file_read or perm=file_write, then create a file and label it in
##     such a way that the MLS relationship between the file and the test
##     process is defined by the mlsop variable (dom, domby, incomp)
##  4. Execute the test process and attempt the open() syscall, using the
##     value of flag to determine whether to create a new file or open
##     an existing file for read or write.  Verify the result. 
##  5. Check the audit log for the correct syscall result
+ open perm=dir_add_name flag=create expres=success mlsop=eq
+ open perm=dir_add_name flag=create expres=fail mlsop=incomp 
+ open perm=file_create flag=create expres=success mlsop=eq
+ open perm=file_create flag=create expres=fail mlsop=dom 
+ open perm=file_read flag=read expres=success mlsop=eq
+ open perm=file_read flag=read expres=fail mlsop=domby 
+ open perm=file_write flag=write expres=success mlsop=eq
+ open perm=file_write flag=write expres=fail mlsop=dom 

## SYSCALL:	openat()
## PURPOSE:
## Verify that the openat() syscall is subject to the correct MLS constraints
## when opening new or existing files, relative to a directory
## file descriptor. See above for more details.
## TESTCASE:    create a new file, mac success
+ openat perm=dir_add_name at=1 flag=create expres=success mlsop=eq
## TESTCASE:    create a new file, mac failure (dom)
+ openat perm=dir_add_name at=1 flag=create expres=fail mlsop=dom 
## TESTCASE:    create a new file, mac failure (domby)
+ openat perm=dir_add_name at=1 flag=create expres=fail mlsop=domby 
## TESTCASE:    create a new file, mac failure (incomp)
+ openat perm=dir_add_name at=1 flag=create expres=fail mlsop=incomp 
## TESTCASE:    create a new file, mac success
+ openat perm=file_create at=1 flag=create expres=success mlsop=eq
## TESTCASE:    create a new file, mac failure (dom)
+ openat perm=file_create at=1 flag=create expres=fail mlsop=dom 
## TESTCASE:    create a new file, mac failure (domby)
+ openat perm=file_create at=1 flag=create expres=fail mlsop=domby 
## TESTCASE:    create a new file, mac failure (incomp)
+ openat perm=file_create at=1 flag=create expres=fail mlsop=incomp 
## TESTCASE:    open an existing file for reading, mac success
+ openat perm=file_read at=1 flag=read expres=success mlsop=eq
## TESTCASE:    open an existing file for reading, mac success
+ openat perm=file_read at=1 flag=read expres=success mlsop=dom
## TESTCASE:    open an existing file for reading, mac failure (domby)
+ openat perm=file_read at=1 flag=read expres=fail mlsop=domby 
## TESTCASE:    open an existing file for reading, mac failure (incomp)
+ openat perm=file_read at=1 flag=read expres=fail mlsop=incomp 
## TESTCASE:    open an existing file for writing, mac success
+ openat perm=file_write at=1 flag=write expres=success mlsop=eq
## TESTCASE:    open an existing file for writing, mac failure (dom)
+ openat perm=file_write at=1 flag=write expres=fail mlsop=dom 
## TESTCASE:    open an existing file for writing, mac failure (domby)
+ openat perm=file_write at=1 flag=write expres=fail mlsop=domby 
## TESTCASE:    open an existing file for writing, mac failure (incomp)
+ openat perm=file_write at=1 flag=write expres=fail mlsop=incomp 

## SYSCALL:	readlink()
## PURPOSE:
## Verify that the readlink() syscall is subject to the correct MLS
## constraints when reading symbolic links in the file system.  The test cases
## below try to read a symbolic link which was created with a MLS sensitivity
## label which may or may not be accessible to the subject test processes
## executing the readlink() syscall.  The test procedure is as follows:
##  1. Create a test file and a symbolic link to that test file, label the
##     symbolic link in such a  way that the MLS relationship between the
##     symlink and the test process is defined by the mlsop variable (dom,
##     domby, incomp)
##  2. Execute the test process and attempt the readlink() syscall, verify
##     the results
##  3. Check the audit log for the correct syscall result
+ readlink perm=symlink_read expres=success mlsop=eq
+ readlink perm=symlink_read expres=fail mlsop=domby 

## SYSCALL:	readlinkat()
## PURPOSE:
## Verify that the readlinkat() syscall is subject to the correct MLS
## constraints when reading symbolic links in the file system, relative to a
## directory file descriptor. See above for more details.
## TESTCASE:    read a symlink, mac success
+ readlinkat perm=symlink_read at=1 expres=success mlsop=eq
## TESTCASE:    read a symlink, mac success
+ readlinkat perm=symlink_read at=1 expres=success mlsop=dom
## TESTCASE:    read a symlink, mac failure (domby)
+ readlinkat perm=symlink_read at=1 expres=fail mlsop=domby 
## TESTCASE:    read a symlink, mac success (incomp)
+ readlinkat perm=symlink_read at=1 expres=fail mlsop=incomp 

## SYSCALL:	rename()
## PURPOSE:
## Verify that the rename() syscall is subject to the correct MLS constraints
## when renaming/moving files or directories.  There are seven types of
## testcases in this set of tests.  The first, using the
## 'perm=dir_remove_name,which=old' variables, creates the original file in a
## parent directory with a MLS sensitivity label which may or may not be
## accessible to the test process and tries to move this file into a new
## directory.  The second test, using the 'perm=file_rename' variable, creates
## a new file with a MLS sensitivity label which may or may not be accessible
## to the test process and tries to rename the file.  The third test, using the
## 'perm=dir_reparent' variable, creates a new directory with a MLS sensitivity
## label which may or may not be accessible to the test process and tries to
## rename the directory.  The fourth test, using the 'perm=dir_add_name'
## variable, creates a new parent directory with a MLS sensitivity label which
## may or may not be accessible to the test process and tries to move the
## original file into this new directory.  The fifth test, using the
## 'perm=dir_remove_name,which=new' variables, creates a parent directory with a
## MLS sensitivity label which may or may not be accessible to the test process
## and tries to rename a file to the name of an existing file in that directory.
## The sixth test, using the 'perm=file_unlink' variable, tries to rename a file
## to another file with a MLS sensitivity label which may or may not be
## accessible to the test process.  The seventh test, using the 'perm=dir_rmdir'
## variable, tries to rename a directory to another directory with a MLS
## sensitivity label which may or may not be accessible to the test process.
## The test procedure is as follows:
##  1.  Create a new parent directory for the original object. If
##      perm=dir_remove_name,which=old then label the directory such that the
##      MLS relationship between the parent directory and the test process is
##      defined by the mlsop variable (dom, domby, incomp), otherwise create the
##      parent directory with the same MLS sensitvity label as the test process.
##  2.  Create the original object. If perm=file_rename or perm=dir_reparent
##      then label the file or directory such that the MLS relationship between
##      it and the test process is defined by the mlsop variable (dom, domby,
##      incomp), otherwise create the original object with the same MLS
##      sensitvity label as the test process.
##  3.  Create a new parent directory for the new location. If perm=dir_add_name
##      or perm=dir_remove_name,which=new then label the directory such that the
##      MLS relationship between the parent directory and the test process is
##      defined by the mlsop variable (dom, domby, incomp), otherwise create the
##      parent directory with the same MLS sensitvity label as the test process.
##  4.  If perm=dir_remove_name,which=new or perm=file_unlink, then create a
##      file at the new location. If perm=file_unlink then label the file such
##      that the MLS relationship between the file and the test process is
##      defined by the mlsop variable (dom, domby, incomp).
##  5.  If perm=dir_rmdir, then create a directory at the new location and label
##      it such that the MLS relationship between the directory and the test
##      process is defined by the mlsop variable (dom, domby, incomp).
##  6.  Execute the test process and attempt the rename() syscall, verify the
##      results
##  7.  Check the audit log for the correct syscall result
## In the following tests, the test object is at the old path.
+ rename perm=dir_remove_name entry=file which=old expres=success mlsop=eq \
  tag=rename__mac_dir_remove_name_old_success_subj_eq_obj
+ rename perm=dir_remove_name entry=file which=old expres=fail mlsop=dom \
  tag=rename__mac_dir_remove_name_old_fail_subj_dom_obj
+ rename perm=file_rename expres=success mlsop=eq
+ rename perm=file_rename expres=fail mlsop=dom 
+ rename perm=file_rename expres=fail mlsop=domby 
+ rename perm=file_rename expres=fail mlsop=incomp 
+ rename perm=dir_reparent expres=success mlsop=eq
+ rename perm=dir_reparent expres=fail mlsop=dom 
+ rename perm=dir_reparent expres=fail mlsop=domby 
+ rename perm=dir_reparent expres=fail mlsop=incomp 
## In the following tests, the test object is at the new path.
+ rename perm=dir_add_name which=new expres=success mlsop=eq
+ rename perm=dir_add_name which=new expres=fail mlsop=incomp 
+ rename perm=dir_remove_name entry=file which=new expres=success mlsop=eq \
  tag=rename__mac_dir_remove_name_new_success_subj_eq_obj
+ rename perm=dir_remove_name entry=file which=new expres=fail mlsop=domby \
  tag=rename__mac_dir_remove_name_new_fail_subj_domby_obj
+ rename perm=file_unlink which=new expres=success mlsop=eq
+ rename perm=file_unlink which=new expres=fail mlsop=dom 
+ rename perm=dir_rmdir which=new expres=success mlsop=eq
+ rename perm=dir_rmdir which=new expres=fail mlsop=domby 

## SYSCALL:	renameat()
## PURPOSE:
## Verify that the renameat() syscall is subject to the correct MLS constraints
## when renaming/moving files or directories relative to a directory file
## descriptor. See above for more details.
## TESTCASE:    rename/move a file, mac success
+ renameat perm=dir_remove_name at=1 entry=file which=old expres=success mlsop=eq \
  tag=renameat__mac_dir_remove_name_old_success_subj_eq_obj
## TESTCASE:    rename/move a file, mac failure (dom)
+ renameat perm=dir_remove_name at=1 entry=file which=old expres=fail mlsop=dom \
  tag=renameat__mac_dir_remove_name_old_fail_subj_dom_obj
## TESTCASE:    rename/move a file, mac failure (domby)
+ renameat perm=dir_remove_name at=1 entry=file which=old expres=fail mlsop=domby \
  tag=renameat__mac_dir_remove_name_old_fail_subj_domby_obj
## TESTCASE:    rename/move a file, mac failure (incomp)
+ renameat perm=dir_remove_name at=1 entry=file which=old expres=fail mlsop=incomp \
  tag=renameat__mac_dir_remove_name_old_fail_subj_incomp_obj
## TESTCASE:    rename a file, mac success
+ renameat perm=file_rename at=1 expres=success mlsop=eq
## TESTCASE:    rename a file, mac failure (dom)
+ renameat perm=file_rename at=1 expres=fail mlsop=dom 
## TESTCASE:    rename a file, mac failure (domby)
+ renameat perm=file_rename at=1 expres=fail mlsop=domby 
## TESTCASE:    rename a file, mac failure (incomp)
+ renameat perm=file_rename at=1 expres=fail mlsop=incomp 
## TESTCASE:    rename/move a directory, mac success
+ renameat perm=dir_reparent at=1 expres=success mlsop=eq
## TESTCASE:    rename/move a directory, mac failure (dom)
+ renameat perm=dir_reparent at=1 expres=fail mlsop=dom 
## TESTCASE:    rename/move a directory, mac failure (domby)
+ renameat perm=dir_reparent at=1 expres=fail mlsop=domby 
## TESTCASE:    rename/move a directory, mac failure (incomp)
+ renameat perm=dir_reparent at=1 expres=fail mlsop=incomp 
## TESTCASE:    rename/move a file, mac success
+ renameat perm=dir_add_name at=1 which=new expres=success mlsop=eq
## TESTCASE:    rename/move a file, mac failure (dom)
+ renameat perm=dir_add_name at=1 which=new expres=fail mlsop=dom 
## TESTCASE:    rename/move a file, mac failure (domby)
+ renameat perm=dir_add_name at=1 which=new expres=fail mlsop=domby 
## TESTCASE:    rename/move a file, mac failure (incomp)
+ renameat perm=dir_add_name at=1 which=new expres=fail mlsop=incomp 
## TESTCASE:    rename/move a file, mac success
+ renameat perm=dir_remove_name at=1 entry=file which=new expres=success mlsop=eq \
  tag=renameat__mac_dir_remove_name_new_success_subj_eq_obj
## TESTCASE:    rename/move a file, mac failure (dom)
+ renameat perm=dir_remove_name at=1 entry=file which=new expres=fail mlsop=dom \
  tag=renameat__mac_dir_remove_name_new_fail_subj_dom_obj
## TESTCASE:    rename/move a file, mac failure (domby)
+ renameat perm=dir_remove_name at=1 entry=file which=new expres=fail mlsop=domby \
  tag=renameat__mac_dir_remove_name_new_fail_subj_domby_obj
## TESTCASE:    rename/move a file, mac failure (incomp)
+ renameat perm=dir_remove_name at=1 entry=file which=new expres=fail mlsop=incomp \
  tag=renameat__mac_dir_remove_name_new_fail_subj_incomp_obj
## TESTCASE:    rename a file, mac success
+ renameat perm=file_unlink at=1 which=new expres=success mlsop=eq
## TESTCASE:    rename a file, mac failure (dom)
+ renameat perm=file_unlink at=1 which=new expres=fail mlsop=dom 
## TESTCASE:    rename a file, mac failure (domby)
+ renameat perm=file_unlink at=1 which=new expres=fail mlsop=domby 
## TESTCASE:    rename a file, mac failure (incomp)
+ renameat perm=file_unlink at=1 which=new expres=fail mlsop=incomp 
## TESTCASE:    rename/move a directory, mac success
+ renameat perm=dir_rmdir at=1 which=new expres=success mlsop=eq
## TESTCASE:    rename/move a directory, mac failure (dom)
+ renameat perm=dir_rmdir at=1 which=new expres=fail mlsop=dom 
## TESTCASE:    rename/move a directory, mac failure (domby)
+ renameat perm=dir_rmdir at=1 which=new expres=fail mlsop=domby 
## TESTCASE:    rename/move a directory, mac failure (incomp)
+ renameat perm=dir_rmdir at=1 which=new expres=fail mlsop=incomp 

## SYSCALL:	rmdir()
## PURPOSE:
## Verify that the rmdir() syscall is subject to the correct MLS constraints
## when removing directories from the file system.  There are two types of
## testcases in this set of tests.  The first, using the 'perm=dir_remove_name'
## variable, tries to remove a sub-directory from a directory which has a MLS
## sensitivity label which may or may not be accessible to the test process
## executing the rmdir() syscall.  The second test tries to remove a directory
## which itself has a MLS sensitivity label which may or may not be accessible
## to the test process executing the rmdir() syscall.  The test procedure is as
## follows:
##  1. Create a new parent directory and if perm=dir_remove_name then label the
##     directory such that the MLS relationship between the parent directory
##     and the test process is defined by the mlsop variable (dom, domby,
##     incomp), if perm=dir_rmdir then create the parent directory with the
##     same MLS sensitvity label as the test process
##  2. If perm=dir_rmdir then create a new directory with a label such that the
##     MLS relationship between the directory and the test process is defined by
##     the mlsop variable (dom, domby, incomp)
##  3.  Execute the test process and attempt the rmdir() syscall, verify the
##      results
##  4.  Check the audit log for the correct syscall result
+ rmdir perm=dir_remove_name entry=dir expres=success mlsop=eq
+ rmdir perm=dir_remove_name entry=dir expres=fail mlsop=domby 
+ rmdir perm=dir_rmdir expres=success mlsop=eq
+ rmdir perm=dir_rmdir expres=fail mlsop=dom 
+ rmdir perm=dir_rmdir expres=fail mlsop=domby 
+ rmdir perm=dir_rmdir expres=fail mlsop=incomp 

## SYSCALL:	symlink()
## PURPOSE:
## Verify that the symlink() syscall is subject to the correct MLS
## constraints when creating new symbolic links in the file system.  There are
## two types of testcases in this set of tests.  The first, using the
## 'perm=dir_add_name' variable, tries to create a symbolic link in a directory
## which has a MLS sensitivity label which may or may not be accessible to the
## subject test process executing the symlink() syscall.  The second test,
## using the 'perm=file_create' variable, tries to create a new symlink with a
## specific MLS sensitvity label which may or may not be allowed by the security
## policy.  The test procedure is as follows:
##  1. Create a new parent directory and if perm=dir_add_name then label the
##     directory such that the MLS relationship between the parent directory
##     and the test process is defined by the mlsop variable (dom, domby,
##     incomp), if perm=file_create then create the parent directory with the
##     same MLS sensitvity label as the test process
##  2. If perm=file_create then call the setfscreatecon() API so that a new
##     file system object will be created with a MLS sensitivity label
##     such that the MLS relationship between the test process and the
##     newly created file system object is defined by the mlsop variable (dom,
##     domby, incomp)
##  3. Execute the test process and attempt the symlink() syscall, verify
##     the result
##  4. Check the audit log for the correct syscall result
+ symlink perm=dir_add_name which=new expres=success mlsop=eq
+ symlink perm=dir_add_name which=new expres=fail mlsop=dom 
+ symlink perm=file_create which=new expres=success mlsop=eq
+ symlink perm=file_create which=new expres=fail mlsop=domby 

## SYSCALL:	symlinkat()
## PURPOSE:
## Verify that the symlinkat() syscall is subject to the correct MLS
## constraints when creating new symbolic links in the file system, relative to
## a directory file descriptor. See above for more details.
## TESTCASE:    create a new symbolic link, mac success
+ symlinkat perm=dir_add_name at=1 which=new expres=success mlsop=eq
## TESTCASE:    create a new symbolic link, mac failure (dom)
+ symlinkat perm=dir_add_name at=1 which=new expres=fail mlsop=dom 
## TESTCASE:    create a new symbolic link, mac failure (domby)
+ symlinkat perm=dir_add_name at=1 which=new expres=fail mlsop=domby 
## TESTCASE:    create a new symbolic link, mac failure (incomp)
+ symlinkat perm=dir_add_name at=1 which=new expres=fail mlsop=incomp 
## TESTCASE:    create a new symbolic link, mac success
+ symlinkat perm=file_create at=1 which=new expres=success mlsop=eq
## TESTCASE:    create a new symbolic link, mac failure (dom)
+ symlinkat perm=file_create at=1 which=new expres=fail mlsop=dom 
## TESTCASE:    create a new symbolic link, mac failure (domby)
+ symlinkat perm=file_create at=1 which=new expres=fail mlsop=domby 
## TESTCASE:    create a new symbolic link, mac failure (incomp)
+ symlinkat perm=file_create at=1 which=new expres=fail mlsop=incomp 

## SYSCALL:	truncate(), truncate64()
## PURPOSE:
## Verify that the truncate() syscall is subject to the correct MLS
## constraints when cutting off a file to a specified length.  The test cases
## below try to truncate a file which has a MLS sensitivity label which may or
## may not be accessible to the test process executing the truncate() syscall.
## The test procedure is as follows:
##  1. Create a test file and label it in such a way that the MLS relationship
##     between the file and the test process is defined by the mlsop variable
##     (dom, domby, incomp)
##  2. Execute the test process and attempt the truncate() syscall, verify
##     the results
##  3. Check the audit log for the correct syscall result
+ truncate perm=file_write expres=success mlsop=eq
+ truncate perm=file_write expres=fail mlsop=domby 
if [[ $MODE == 32 ]]; then
+ truncate64 perm=file_write expres=success mlsop=eq
+ truncate64 perm=file_write expres=fail mlsop=incomp 
fi  

## SYSCALL:	unlink()
## PURPOSE:
## Verify that the unlink() syscall is subject to the correct MLS constraints
## when removing files from the file system.  There are two types of testcases
## in this set of tests.  The first, using the 'perm=dir_remove_name' variable,
## tries to remove a file from a directory which has a MLS sensitivity label
## which may or may not be accessible to the test process executing the
## unlink() syscall.  The second, using the 'perm=file_unlink' variable, tries
## to remove a file which itself has a MLS sensitivity label which may or may
## not be accessible to the test process executing the unlink() syscall.
## The test procedure is as follows:
##  1. Create a new parent directory and if perm=dir_remove_name then label the
##     directory such that the MLS relationship between the parent directory
##     and the test process is defined by the mlsop variable (dom, domby,
##     incomp), if perm=file_unlink then create the parent directory with the
##     same MLS sensitvity label as the test process
##  2. If perm=file_unlink then create a new file with a label such that the
##     MLS relationship between the file and the test process is defined by the
##     mlsop variable (dom, domby, incomp)
##  3.  Execute the test process and attempt the unlink() syscall, verify the
##      results
##  4.  Check the audit log for the correct syscall result
+ unlink perm=dir_remove_name entry=file expres=success mlsop=eq
+ unlink perm=dir_remove_name entry=file expres=fail mlsop=incomp 
+ unlink perm=file_unlink expres=success mlsop=eq
+ unlink perm=file_unlink expres=fail mlsop=dom 
+ unlink perm=file_unlink expres=fail mlsop=domby 
+ unlink perm=file_unlink expres=fail mlsop=incomp 

## SYSCALL:	unlinkat()
## PURPOSE:
## Verify that the unlinkat() syscall is subject to the correct MLS constraints
## when removing files from the file system, relative to a directory file
## descriptor. See above for more details.
## TESTCASE:    remove a file from a labeled directory, mac success
+ unlinkat perm=dir_remove_name at=1 entry=file expres=success mlsop=eq
## TESTCASE:    remove a file from a labeled directory, mac failure (dom)
+ unlinkat perm=dir_remove_name at=1 entry=file expres=fail mlsop=dom 
## TESTCASE:    remove a file from a labeled directory, mac failure (domby)
+ unlinkat perm=dir_remove_name at=1 entry=file expres=fail mlsop=domby 
## TESTCASE:    remove a file from a labeled directory, mac failure (incomp)
+ unlinkat perm=dir_remove_name at=1 entry=file expres=fail mlsop=incomp 
## TESTCASE:    remove a file, mac success
+ unlinkat perm=file_unlink at=1 expres=success mlsop=eq
## TESTCASE:    remove a file, mac failure (dom)
+ unlinkat perm=file_unlink at=1 expres=fail mlsop=dom 
## TESTCASE:    remove a file, mac failure (domby)
+ unlinkat perm=file_unlink at=1 expres=fail mlsop=domby 
## TESTCASE:    remove a file, mac failure (incomp)
+ unlinkat perm=file_unlink at=1 expres=fail mlsop=incomp 

## SYSCALL:	uselib()
## PURPOSE:
## Verify that the uselib() syscall is subject to the correct MLS constraints
## when loading a shared library.  The test cases below try to load a library
## which has a MLS sensitivity label which may or may not be accessible to the
## test process executing the uselib() syscall.
## NOTE:
## The kernel only accepts obsolete formats, so the true success case is
## difficult to reproduce. Permission checks happen before the format checks, so
## verifying ENOEXEC is sufficient to demonstrate DAC/MAC success.
## The test procedure is as follows:
##  1. Create a shared library and label it in such a way that the MLS
##     relationship between the library and the test process is defined by the
##     mlsop variable (dom, domby, incomp)
##  2. Execute the test process and attempt the uselib() syscall, verify
##     the results
##  3. Check the audit log for the correct syscall result
if [[ $HOSTTYPE != x86_64 ]]; then
## TESTCASE:	mac success (eq)
+ uselib perm=file_exec expres=fail mlsop=eq err=ENOEXEC \
  tag=uselib__mac_file_exec_success_subj_eq_obj
## TESTCASE:	mac success (dom)
+ uselib perm=file_exec expres=fail mlsop=dom err=ENOEXEC \
  tag=uselib__mac_file_exec_success_subj_dom_obj
## TESTCASE:	mac failure (domby)
+ uselib perm=file_exec expres=fail mlsop=domby 
## TESTCASE:	mac failure (incomp)
+ uselib perm=file_exec expres=fail mlsop=incomp 
fi

##
## IPC syscalls
##

## SYSCALL:     msgget(), ipc()
## PURPOSE:
## Verify that the msgget() and ipc() syscalls are subject to the correct MLS
## constraints when getting a message queue identifier. There are two types of
## testcases in this set of tests. The first, using the 'perm=msg_key_read'
## variable, tries to open a message queue for reading which has a MLS
## sensitivity label which may or may not be accessible to the test process.
## The second, using the 'perm=msg_key_write' variable, tries to open a message
## queue for writing which has a MLS sensitivity label which may or may not be
## accessible to the test process.  The test procedure is as follows:
##  1. Create a new message queue such that the MLS relationship between the
##     message queue and the test process is defined by the mlsop variable
##     (dom, domby, incomp)
##  2. Execute the test process and attempt the msgget() or ipc() syscall.  With
##     the ipc() syscall the function is determined by the 'op' variable.  The
##     test process requests the message queue for read or write depending on
##     the 'perm' value '*_read' or '*_write'.  Verify the result.
##  3. Check the audit log for the correct syscall result
if [[ $MODE == 64 ]]; then
+ msgget perm=msg_key_read expres=success mlsop=eq
+ msgget perm=msg_key_read expres=success mlsop=dom
+ msgget perm=msg_key_read expres=fail mlsop=domby 
+ msgget perm=msg_key_read expres=fail mlsop=incomp 
+ msgget perm=msg_key_write expres=success mlsop=eq
+ msgget perm=msg_key_write expres=fail mlsop=dom 
+ msgget perm=msg_key_write expres=fail mlsop=domby 
+ msgget perm=msg_key_write expres=fail mlsop=incomp 
fi
if [[ $MODE == 32 ]]; then
+ ipc op=msgget perm=msg_key_read expres=success mlsop=eq
+ ipc op=msgget perm=msg_key_read expres=success mlsop=dom
+ ipc op=msgget perm=msg_key_read expres=fail mlsop=domby 
+ ipc op=msgget perm=msg_key_read expres=fail mlsop=incomp 
+ ipc op=msgget perm=msg_key_write expres=success mlsop=eq
+ ipc op=msgget perm=msg_key_write expres=fail mlsop=dom 
+ ipc op=msgget perm=msg_key_write expres=fail mlsop=domby 
+ ipc op=msgget perm=msg_key_write expres=fail mlsop=incomp 
fi

## SYSCALL:     msgrcv(), ipc()
## PURPOSE:
## Verify that the msgrcv() and ipc() syscalls are subject to the correct MLS
## constraints when receiving messages from a message queue.  The test cases
## below try to receive a message from a message queue which has a MLS
## sensitivity label which may or may not be accessible to the test process.
## The test procedure is as follows:
##  1. Create a new message queue such that the MLS relationship between the
##     message queue and the test process is defined by the mlsop variable
##     (dom, domby, incomp)
##  2. Send a message to the message queue.
##  3. Execute the test process and attempt the msgrcv() or ipc() syscall.  With
##     the ipc() syscall the function is determined by the 'op' variable.
##     Verify the result.
##  4. Check the audit log for the correct syscall result
if [[ $MODE == 64 ]]; then
+ msgrcv perm=msg_id_recv expres=success mlsop=eq
+ msgrcv perm=msg_id_recv expres=success mlsop=dom
+ msgrcv perm=msg_id_recv expres=fail mlsop=domby 
+ msgrcv perm=msg_id_recv expres=fail mlsop=incomp 
fi
if [[ $MODE == 32 ]]; then
+ ipc op=msgrcv perm=msg_id_recv expres=success mlsop=eq
+ ipc op=msgrcv perm=msg_id_recv expres=success mlsop=dom
+ ipc op=msgrcv perm=msg_id_recv expres=fail mlsop=domby 
+ ipc op=msgrcv perm=msg_id_recv expres=fail mlsop=incomp 
fi

## SYSCALL:     msgsnd(), ipc()
## PURPOSE:
## Verify that the msgsnd() and ipc() syscalls are subject to the correct MLS
## constraints when sending messages to a message queue.  The test cases
## below try to send a message to a message queue which has a MLS
## sensitivity label which may or may not be accessible to the test process.
## The test procedure is as follows:
##  1. Create a new message queue such that the MLS relationship between the
##     message queue and the test process is defined by the mlsop variable
##     (dom, domby, incomp)
##  2. Execute the test process and attempt the msgsnd() or ipc() syscall.  With
##     the ipc() syscall the function is determined by the 'op' variable.
##     Verify the result.
##  4. Check the audit log for the correct syscall result
if [[ $MODE == 64 ]]; then
+ msgsnd perm=msg_id_send msg="this is a test" expres=success mlsop=eq \
  testfunc=test_runcon_msg_send
+ msgsnd perm=msg_id_send msg="this is a test" expres=fail mlsop=dom \
   testfunc=test_runcon_msg_send
+ msgsnd perm=msg_id_send msg="this is a test" expres=fail mlsop=domby \
   testfunc=test_runcon_msg_send
+ msgsnd perm=msg_id_send msg="this is a test" expres=fail mlsop=incomp \
   testfunc=test_runcon_msg_send
fi
if [[ $MODE == 32 ]]; then
+ ipc op=msgsnd perm=msg_id_send msg="this is a test" expres=success mlsop=eq \
  testfunc=test_runcon_msg_send
+ ipc op=msgsnd perm=msg_id_send msg="this is a test" expres=fail mlsop=dom \
   testfunc=test_runcon_msg_send
+ ipc op=msgsnd perm=msg_id_send msg="this is a test" expres=fail mlsop=domby \
   testfunc=test_runcon_msg_send
+ ipc op=msgsnd perm=msg_id_send msg="this is a test" expres=fail mlsop=incomp \
   testfunc=test_runcon_msg_send
fi

## SYSCALL:     semget(), ipc()
## PURPOSE:
## Verify that the semget() and ipc() syscalls are subject to the correct MLS
## constraints when getting a semaphore set identifier. There are two types of
## testcases in this set of tests. The first, using the 'perm=sem_key_read'
## variable, tries to open a semaphore set for reading which has a MLS
## sensitivity label which may or may not be accessible to the test process.
## The second, using the 'perm=sem_key_write' variable, tries to open a
## semaphore set for writing which has a MLS sensitivity label which may or may
## not be accessible to the test process.  The test procedure is as follows:
##  1. Create a new semaphore set such that the MLS relationship between the
##     semaphore set and the test process is defined by the mlsop variable
##     (dom, domby, incomp)
##  2. Execute the test process and attempt the semget() or ipc() syscall.  With
##     the ipc() syscall the function is determined by the 'op' variable.  The
##     test process requests the semaphore set for read or write depending on
##     the 'perm' value '*_read' or '*_write'.  Verify the result.
##  3. Check the audit log for the correct syscall result
if [[ $MODE == 64 ]]; then
+ semget perm=sem_key_read expres=success mlsop=eq
+ semget perm=sem_key_read expres=success mlsop=dom
+ semget perm=sem_key_read expres=fail mlsop=domby 
+ semget perm=sem_key_read expres=fail mlsop=incomp 
+ semget perm=sem_key_write expres=success mlsop=eq
+ semget perm=sem_key_write expres=fail mlsop=dom 
+ semget perm=sem_key_write expres=fail mlsop=domby 
+ semget perm=sem_key_write expres=fail mlsop=incomp 
fi
if [[ $MODE == 32 ]]; then
+ ipc op=semget perm=sem_key_read expres=success mlsop=eq
+ ipc op=semget perm=sem_key_read expres=success mlsop=dom
+ ipc op=semget perm=sem_key_read expres=fail mlsop=domby 
+ ipc op=semget perm=sem_key_read expres=fail mlsop=incomp 
+ ipc op=semget perm=sem_key_write expres=success mlsop=eq
+ ipc op=semget perm=sem_key_write expres=fail mlsop=dom 
+ ipc op=semget perm=sem_key_write expres=fail mlsop=domby 
+ ipc op=semget perm=sem_key_write expres=fail mlsop=incomp 
fi

## SYSCALL:     semop(), ipc()
## PURPOSE:
## Verify that the semop() and ipc() syscalls are subject to the correct MLS
## constraints when performing semaphore operations.  The test cases
## below try to perform a read operation on a semaphore in a set which has a MLS
## sensitivity label which may or may not be accessible to the test process.
## The test procedure is as follows:
##  1. Create a new semaphore set such that the MLS relationship between the
##     semaphore set and the test process is defined by the mlsop variable
##     (dom, domby, incomp)
##  2. Execute the test process and attempt the semop() or ipc() syscall with a
##     read operation.  With the ipc() syscall the function is determined by the
##     'op' variable.  Verify the result.
##  3. Check the audit log for the correct syscall result
if [[ $MODE == 64 ]]; then
+ semop perm=sem_id_read expres=success mlsop=eq
+ semop perm=sem_id_read expres=success mlsop=dom
+ semop perm=sem_id_read expres=fail mlsop=domby 
+ semop perm=sem_id_read expres=fail mlsop=incomp 
fi
if [[ $MODE == 32 ]]; then
+ ipc op=semop perm=sem_id_read expres=success mlsop=eq
+ ipc op=semop perm=sem_id_read expres=success mlsop=dom
+ ipc op=semop perm=sem_id_read expres=fail mlsop=domby 
+ ipc op=semop perm=sem_id_read expres=fail mlsop=incomp 
fi

## SYSCALL:     semtimedop(), ipc()
## PURPOSE:
## Verify that the semtimedop() and ipc() syscalls are subject to the correct MLS
## constraints when performing semaphore operations.  The test cases
## below try to perform a write operation on a semaphore in a set which has a MLS
## sensitivity label which may or may not be accessible to the test process.
## The test procedure is as follows:
##  1. Create a new semaphore set such that the MLS relationship between the
##     semaphore set and the test process is defined by the mlsop variable
##     (dom, domby, incomp)
##  2. Execute the test process and attempt the semop() or ipc() syscall with a
##     write operation.  With the ipc() syscall the function is determined by the
##     'op' variable.  Verify the result.
##  3. Check the audit log for the correct syscall result
if [[ $MODE == 64 ]]; then
+ semtimedop perm=sem_id_write expres=success mlsop=eq
+ semtimedop perm=sem_id_write expres=fail mlsop=dom 
+ semtimedop perm=sem_id_write expres=fail mlsop=domby 
+ semtimedop perm=sem_id_write expres=fail mlsop=incomp 
fi
if [[ $MODE == 32 ]]; then
+ ipc op=semtimedop perm=sem_id_write expres=success mlsop=eq
+ ipc op=semtimedop perm=sem_id_write expres=fail mlsop=dom 
+ ipc op=semtimedop perm=sem_id_write expres=fail mlsop=domby 
+ ipc op=semtimedop perm=sem_id_write expres=fail mlsop=incomp 
fi

## SYSCALL:     shmat(), ipc()
## PURPOSE:
## Verify that the shmat() and ipc() syscalls are subject to the correct MLS
## constraints when attaching to a shared memory segment.  There are two types
## of testcases in this set of tests.  The first, using the 'perm=shm_id_read'
## variable, tries to attach for reading only to a shared memory segment which
## has a MLS sensitivity label which may or may not be accessible to the test
## process.  The second, using the 'perm=shm_id_write' variable, tries to attach
## for read/write to a shared memory segment which has a MLS sensitivity label
## which may or may not be accessible to the test process.  The test procedure
## is as follows:
##  1. Create a new shared memory segment such that the MLS relationship between
##     the shared memory segment and the test process is defined by the mlsop
##     variable (dom, domby, incomp)
##  2. Execute the test process and attempt the shmat() or ipc() syscall,
##     requesting to attach readonly or read/write based on the value of the
##     'perm' variable.  With the ipc() syscall the function is determined by
##     the 'op' variable.  Verify the result.
##  3. Check the audit log for the correct syscall result
if [[ $MODE == 64 ]]; then
+ shmat perm=shm_id_read expres=success mlsop=eq
+ shmat perm=shm_id_read expres=success mlsop=dom
+ shmat perm=shm_id_read expres=fail mlsop=domby 
+ shmat perm=shm_id_read expres=fail mlsop=incomp 
+ shmat perm=shm_id_write expres=success mlsop=eq
+ shmat perm=shm_id_write expres=fail mlsop=dom 
+ shmat perm=shm_id_write expres=fail mlsop=domby 
+ shmat perm=shm_id_write expres=fail mlsop=incomp 
fi
if [[ $MODE == 32 ]]; then
+ ipc op=shmat perm=shm_id_read expres=success mlsop=eq \
  augrokfunc=augrok_mls_op_label_no_exit
+ ipc op=shmat perm=shm_id_read expres=success mlsop=dom \
  augrokfunc=augrok_mls_op_label_no_exit
+ ipc op=shmat perm=shm_id_read expres=fail mlsop=domby 
+ ipc op=shmat perm=shm_id_read expres=fail mlsop=incomp 
+ ipc op=shmat perm=shm_id_write expres=success mlsop=eq \
  augrokfunc=augrok_mls_op_label_no_exit
+ ipc op=shmat perm=shm_id_write expres=fail mlsop=dom 
+ ipc op=shmat perm=shm_id_write expres=fail mlsop=domby 
+ ipc op=shmat perm=shm_id_write expres=fail mlsop=incomp 
fi

## SYSCALL:     shmget(), ipc()
## PURPOSE:
## Verify that the shmget() and ipc() syscalls are subject to the correct MLS
## constraints when getting a shared memory segment id. There are two types of
## testcases in this set of tests. The first, using the 'perm=shm_key_read'
## variable, tries to open a shared memory segment for reading which has a MLS
## sensitivity label which may or may not be accessible to the test process.
## The second, using the 'perm=shm_key_write' variable, tries to open a
## shared memory segment for writing which has a MLS sensitivity label which may
## or may not be accessible to the test process.  The test procedure is as
## follows:
##  1. Create a new shared memory segment such that the MLS relationship between
##     the shared memory segment and the test process is defined by the mlsop
##     variable (dom, domby, incomp)
##  2. Execute the test process and attempt the shmget() or ipc() syscall.  With
##     the ipc() syscall the function is determined by the 'op' variable.  The
##     test process requests the shared memory segment for read or write
##     depending on the 'perm' value '*_read' or '*_write'.  Verify the result.
##  3. Check the audit log for the correct syscall result
if [[ $MODE == 64 ]]; then
+ shmget perm=shm_key_read expres=success mlsop=eq
+ shmget perm=shm_key_read expres=success mlsop=dom
+ shmget perm=shm_key_read expres=fail mlsop=domby 
+ shmget perm=shm_key_read expres=fail mlsop=incomp 
+ shmget perm=shm_key_write expres=success mlsop=eq
+ shmget perm=shm_key_write expres=fail mlsop=dom 
+ shmget perm=shm_key_write expres=fail mlsop=domby 
+ shmget perm=shm_key_write expres=fail mlsop=incomp 
fi
if [[ $MODE == 32 ]]; then
+ ipc op=shmget perm=shm_key_read expres=success mlsop=eq
+ ipc op=shmget perm=shm_key_read expres=success mlsop=dom
+ ipc op=shmget perm=shm_key_read expres=fail mlsop=domby 
+ ipc op=shmget perm=shm_key_read expres=fail mlsop=incomp 
+ ipc op=shmget perm=shm_key_write expres=success mlsop=eq
+ ipc op=shmget perm=shm_key_write expres=fail mlsop=dom 
+ ipc op=shmget perm=shm_key_write expres=fail mlsop=domby 
+ ipc op=shmget perm=shm_key_write expres=fail mlsop=incomp 
fi

##
## MQ syscalls
##

## SYSCALL:     mq_open()
## PURPOSE:
## Verify that the mq_open() syscall is subject to the correct MLS constraints
## when opening new or existing message queues.  There are three types of
## testcases in this set of tests.  The first, using the 'perm=mq_create'
## variable, tries to create a new message queue which itself has a MLS
## sensitvity label which may or may not be allowed by the security policy.
## The second, using the 'perm=mq_read' variable, tries to open a message queue
## for reading which has a MLS sensitivity label which may or may not be
## accessible to the test process executing the mq_open() syscall.  The third,
## using the 'perm=mq_write' variable, tries to open a message queue for writing
## which has a MLS sensitivity label which may or may not be accessible to the
## test process executing the mq_open() syscall.  The test procedure is as
## follows:
##  1. If perm=mq_create then call the setfscreatecon() API so that a new
##     message queue will be created with a MLS sensitivity label
##     such that the MLS relationship between the test process and the
##     newly created message queue is defined by the mlsop variable (dom,
##     domby, incomp)
##  2. If perm=mq_read or perm=mq_write, then create a message queue and label
##     it in such a way that the MLS relationship between the message queue and
##     the test process is defined by the mlsop variable (dom, domby, incomp)
##  3. Execute the test process and attempt the mq_open() syscall, using the
##     value of flag to determine whether to create a new message queue or open
##     an existing message queue for read or write.  Verify the result. 
##  4. Check the audit log for the correct syscall result
+ mq_open perm=mq_create flag=create expres=success mlsop=eq
+ mq_open perm=mq_create flag=create expres=fail mlsop=dom 
+ mq_open perm=mq_create flag=create expres=fail mlsop=domby 
+ mq_open perm=mq_create flag=create expres=fail mlsop=incomp 
+ mq_open perm=mq_read flag=read expres=success mlsop=eq
+ mq_open perm=mq_read flag=read expres=success mlsop=dom
+ mq_open perm=mq_read flag=read expres=fail mlsop=domby 
+ mq_open perm=mq_read flag=read expres=fail mlsop=incomp 
+ mq_open perm=mq_write flag=write expres=success mlsop=eq
+ mq_open perm=mq_write flag=write expres=fail mlsop=dom 

## SYSCALL:     mq_unlink()
## PURPOSE:

## Verify that the mq_unlink() syscall is subject to the correct MLS constraints
## when removing message queues.  The test cases below try to remove a message
## queue which has a MLS sensitivity label which may or may not be accessible to
## the test process.  The test procedure is as follows:
##  1. Create a message queue and label it in such a way that the MLS
##     relationship between the message queue and the test process is defined by
##     the mlsop variable (dom, domby, incomp)
##  2. Execute the test process and attempt the mq_unlink() syscall, verify the
##     result. 
##  3. Check the audit log for the correct syscall result
+ mq_unlink perm=mq_write expres=success mlsop=eq
+ mq_unlink perm=mq_write expres=fail mlsop=domby 
+ mq_unlink perm=mq_write expres=fail mlsop=incomp 

##
## PROCESS syscalls
##

## SYSCALL:	kill()
## PURPOSE:
## Verify that the kill() syscall is subject to the correct MLS constraints
## when sending a signal to a process.  There are two types of testcases in this
## set of tests.  The first, using the 'perm=process_sigusr1' variable, tries to
## send the SIGUSR1 signal to a single process which has a MLS sensitivity label
## which may or may not be accessible to the test process executing the kill()
## syscall.  The second, using the 'perm=pgrp_sigkill' variable, tries to send
## the SIGKILL signal to a group of processes which have MLS sensitivity labels
## which may or may not be accessible to the test process executing the kill()
## syscall.  The test procedure is as follows:
##  1. Start a new process or group of processes such that the MLS relationship
##     between the process or process group and the test process is defined by
##     the mlsop variable (dom, domby, incomp).
##  2. Execute the test process and attempt the kill() syscall with the
##     specified signal, verify the result
##  3. Check the audit log for the correct syscall result
+ kill perm=process_sigusr1 expres=success mlsop=eq
+ kill perm=process_sigusr1 expres=fail mlsop=dom 
+ kill perm=pgrp_sigkill expres=success mlsop=eq testfunc=test_runcon_kill_pgrp
+ kill perm=pgrp_sigkill expres=fail mlsop=dom  testfunc=test_runcon_kill_pgrp

## SYSCALL:	tgkill()
## PURPOSE:
## Verify that the tgkill() syscall is subject to the correct MLS constraints
## when sending a signal to a process.  The testcases below try to send the
## SIGKILL signal to a process which has a MLS sensitivity label which may or
## may not be accessible to the test process executing the tgkill() syscall.
## The test procedure is as follows:
##  1. Start a new dummy process such that the MLS relationship between the
##     dummy process and the test process is defined by the mlsop variable (dom,
##     domby, incomp).
##  2. Execute the test process and attempt the tgkill() syscall, verify
##     the result
##  3. Check the audit log for the correct syscall result
+ tgkill perm=process_sigkill expres=success mlsop=eq
+ tgkill perm=process_sigkill expres=fail mlsop=domby 

## SYSCALL:	tkill()
## PURPOSE:
## Verify that the tkill() syscall is subject to the correct MLS constraints
## when sending a signal to a process.  The testcases below try to send the
## SIGSTOP signal to a process which has a MLS sensitivity label which may or
## may not be accessible to the test process executing the tkill() syscall.
## The test procedure is as follows:
##  1. Start a new dummy process such that the MLS relationship between the
##     dummy process and the test process is defined by the mlsop variable (dom,
##     domby, incomp).
##  2. Execute the test process and attempt the tkill() syscall, verify
##     the result
##  3. Check the audit log for the correct syscall result
+ tkill perm=process_sigstop expres=success mlsop=eq
+ tkill perm=process_sigstop expres=fail mlsop=incomp 

## SYSCALL:	ptrace()
## PURPOSE:
## Verify that the ptrace() syscall is subject to the correct MLS constraints
## when tracing a process.  The testcases below try to commence tracing a
## process which has a MLS sensitivity label which may or may not be accessible
## to the test process executing the ptrace() syscall.  The test procedure is as
## follows:
##  1. Start a new dummy process such that the MLS relationship between the
##     dummy process and the test process is defined by the mlsop variable (dom,
##     domby, incomp).
##  2. Execute the test process and attempt the ptrace() syscall with the
##     PTRACE_ATTACH request, verify the result
##  3. Check the audit log for the correct syscall result
+ ptrace perm=process_attach expres=success mlsop=eq
+ ptrace perm=process_attach expres=fail mlsop=dom err=EPERM
+ ptrace perm=process_attach expres=fail mlsop=domby err=EPERM
+ ptrace perm=process_attach expres=fail mlsop=incomp err=EPERM

##
## XATTR syscalls
##

## SYSCALL:	getxattr(), lgetxattr()
## PURPOSE:
## Verify that the getxattr() and lgetxattr() syscalls are subject to the
## correct MLS constraints when retrieving extended attribute values other than
## the security attribute values.  The testcases below try to retrieve an
## extended attribute value for a file which has a MLS sensitivity label which
## may or may not be accessible to the test process executing the syscall.
## The test procedure is as follows:
##  1. Create a new file and label it such that the MLS relationship between the
##     file and the test process is defined by the mlsop variable (dom, domby,
##     incomp).
##  2. Execute the test process and attempt to retrieve the value for the
##     extended attribute specified by flag, verify the result
##  3. Check the audit log for the correct syscall result
+ getxattr perm=file_read flag=security.selinux expres=success mlsop=dom
+ getxattr perm=file_read flag=security.selinux expres=fail mlsop=domby 
+ lgetxattr perm=file_read flag=security.selinux expres=success mlsop=eq
+ lgetxattr perm=file_read flag=security.selinux expres=fail mlsop=incomp 

## SYSCALL:	listxattr(), llistxattr()
## PURPOSE:
## Verify that the listxattr() and llistxattr() syscalls are subject to the
## correct MLS constraints when listing extended attribute names.  The testcases
## below try to list extended attribute names for a file which has a MLS
## sensitivity label which may or may not be accessible to the test process
## executing the syscall.  The test procedure is as follows:
##  1. Create a new file and label it such that the MLS relationship between the
##     file and the test process is defined by the mlsop variable (dom, domby,
##     incomp).
##  2. Execute the test process and attempt to list the names of the extended
##     attributes of the test file, verify the result
##  3. Check the audit log for the correct syscall result
+ listxattr perm=file_read expres=success mlsop=dom
+ listxattr perm=file_read expres=fail mlsop=domby 
+ llistxattr perm=file_read expres=success mlsop=eq
+ llistxattr perm=file_read expres=fail mlsop=incomp 
