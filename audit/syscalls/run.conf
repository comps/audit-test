# =============================================================================
# (c) Copyright Hewlett-Packard Development Company, L.P., 2005
#
#   This program is free software;  you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY;  without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
#   the GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program;  if not, write to the Free Software
#   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
# =============================================================================

#----------------------------------------------------------------------
# Notes for syscalls' run.conf
# ----------------------------
# The two variations for each syscall tested are basic-good and
# basic-bad.
# These are interpreted in run_test to call ./syscalls either with -s
# or without.
#----------------------------------------------------------------------
VARIATIONS=( basic-good basic-bad )
function make_variation { printf "%-20s %s" "$1" "$2"; }
function run_test { 
    declare status=0 b32

    # goodargs case appends -s
    set -- "${1/%basic-good/ -s}"
    set -- "${1/%basic-bad/}"
    set -- "${1/%remove-good/ -v remove -s}"
    set -- "${1/%remove-bad/ -v remove}"
    set -- "${1/%setperms-good/ -v setperms -s}"
    set -- "${1/%setperms-bad/ -v setperms}"
    set -- "${1/%file-good/ -v file -s}"
    set -- "${1/%file-bad/ -v file}"
    set -- "${1/%symlink-good/ -v symlink -s}"
    set -- "${1/%symlink-bad/ -v file}"

    # Force the audit log to rotate; add our rule.
    # Since the MODE variable isn't exported to the environment from the
    # Makefile, check the syscalls binary.
    rotate_audit_logs || return 2
    file syscalls | grep -qo 'ELF 32-bit' && \
        file /bin/bash | grep -qo 'ELF 64-bit' && \
        b32='-F arch=b32'
    auditctl $b32 -a entry,always -S ${1%% *} || return 2

    # Run the test
    eval "./syscalls -t $1"
    status=$?

    # Remove the rule we added
    auditctl -d entry,always -S ${1%% *}

    # Display the log items.  Note that (1) auditd might not have flushed
    # everything out despite the sleep, (2) there might be items that managed to
    # hit the log post-rotation.
    if [[ $status != 0 ]]; then
        sleep 0.1
        echo
        echo augrep output
        echo -------------
        augrep type!=DAEMON_ROTATE
    fi

    return $status
}

function startup_hook {
    # for tests/test_init_module.c and tests/test_delete_module.c
    export AUDIT_KMOD_DIR=/lib/modules/$(uname -r)/kernel/drivers/net
    export AUDIT_KMOD_NAME=dummy
}

+ access
+ adjtimex
+ bind
+ capset
+ chdir
+ chmod
+ chown
if [[ $HOSTTYPE == !(ppc|x86_64|s390x|ia64) ]]; then
    + chown32
fi
+ clock_settime
+ clone
if [[ $HOSTTYPE == ia64 ]]; then
    + clone2
fi
+ creat
+ delete_module
+ execve
+ fchmod
+ fchown
if [[ $HOSTTYPE == !(ppc|x86_64|s390x|ia64) ]]; then
    + fchown32
fi
if [[ $HOSTTYPE != ia64 ]]; then
+ fork
fi
+ fremovexattr
+ fsetxattr
+ init_module
+ ioctl
if [[ $HOSTTYPE == i?86 ]]; then
    + ioperm
    + iopl
fi
+ lchown file-good file-bad
if [[ $HOSTTYPE == !(ppc|x86_64|s390x|ia64) ]]; then
    + lchown32 file-good file-bad
fi
+ link
+ lremovexattr file-good file-bad
+ lsetxattr file-good file-bad
+ mkdir
+ mknod
+ mount
+ msgctl remove-good remove-bad setperms-good setperms-bad
+ msgsnd
+ msgrcv
+ msgget
+ open
+ ptrace
+ removexattr
+ rename
+ rmdir
+ semctl remove-good remove-bad setperms-good setperms-bad
+ semget
+ semop
+ semtimedop
+ setfsgid
if [[ $HOSTTYPE == !(ppc|x86_64|s390x|ia64) ]]; then
    + setfsgid32
fi
+ setfsuid
if [[ $HOSTTYPE == !(ppc|x86_64|s390x|ia64) ]]; then
    + setfsuid32
fi
+ setgid
if [[ $HOSTTYPE == !(ppc|x86_64|s390x|ia64) ]]; then
    + setgid32
fi
+ setgroups
if [[ $HOSTTYPE == !(ppc|x86_64|s390x|ia64) ]]; then
    + setgroups32
fi
+ setregid
if [[ $HOSTTYPE == !(ppc|x86_64|s390x|ia64) ]]; then
    + setregid32
fi
+ setresgid
if [[ $HOSTTYPE == !(ppc|x86_64|s390x|ia64) ]]; then
    + setresgid32
fi
+ setresuid
if [[ $HOSTTYPE == !(ppc|x86_64|s390x|ia64) ]]; then
    + setresuid32
fi
+ setreuid
if [[ $HOSTTYPE == !(ppc|x86_64|s390x|ia64) ]]; then
    + setreuid32
fi
+ settimeofday
+ setuid
if [[ $HOSTTYPE == !(ppc|x86_64|s390x|ia64) ]]; then
    + setuid32
fi
+ setxattr
+ shmat
+ shmctl remove-good remove-bad setperms-good setperms-bad
+ shmget
if [[ $HOSTTYPE == !(x86_64|ia64) ]]; then
    + stime
fi
+ swapon
+ symlink
+ truncate
if [[ $HOSTTYPE == !(ppc|x86_64|s390x|ia64) ]]; then
    + truncate64
fi
+ umask basic-good
+ unlink
if [[ $HOSTTYPE != ia64 ]]; then
    + utime
fi
if [[ $HOSTTYPE == ia64 ]]; then
    + utimes
fi
if [[ $HOSTTYPE != ia64 ]]; then
    + vfork
fi
