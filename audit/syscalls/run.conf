# =============================================================================
# (c) Copyright Hewlett-Packard Development Company, L.P., 2005
#
#   This program is free software;  you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY;  without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
#   the GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program;  if not, write to the Free Software
#   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
# =============================================================================

#----------------------------------------------------------------------
# Notes for syscalls' run.conf
# ----------------------------
# The two variations for each syscall tested are goodargs and badargs.
# These are interpreted in run_test to call ./syscalls either with -s
# or without.
#----------------------------------------------------------------------
VARIATIONS=( goodargs badargs )
function make_variation { printf "%-20s %s" "$1" "$2"; }
function run_test { 
    declare status=0

    # goodargs case appends -s
    set -- "${1/%goodargs/ -s}"
    set -- "${1/%badargs/}"

    # Force the audit log to rotate; add our rule
    killall -USR1 auditd
    auditctl -a entry,always -S ${1%% *} || return 2

    # Run the test
    eval "./syscalls -t $1"
    status=$?

    # Remove the rule we added
    auditctl -d entry,always -S ${1%% *}

    # Display the log items.  Note that (1) auditd might not have flushed
    # everything out despite the sleep, (2) there might be items that managed to
    # hit the log post-rotation.
    if [[ $status != 0 ]]; then
        sleep 0.1
        echo
        echo full audit log snippet
        echo ----------------------
        augrep type=~. type!=DAEMON_ROTATE
    fi

    return $status
}

function startup_hook {
    # for tests/test_init_module.c and tests/test_delete_module.c
    export AUDIT_KMOD_DIR=/lib/modules/$(uname -r)/kernel/drivers/net
    export AUDIT_KMOD_NAME=dummy
}

+ access
+ adjtimex
+ bind
+ capset
+ chdir
+ chmod
+ chown
if [[ $HOSTTYPE == !(ppc|x86_64|s390x|ia64) ]]; then
    + chown16
    + chown32
fi
+ clock_settime
+ clone
if [[ $HOSTTYPE == ia64 ]]; then
    + clone2
fi
+ creat
+ delete_module
+ execve
+ fchmod
+ fchown
if [[ $HOSTTYPE == !(ppc|x86_64|s390x|ia64) ]]; then
    + fchown16
    + fchown32
fi
if [[ $HOSTTYPE != ia64 ]]; then
+ fork
fi
+ fremovexattr
+ fsetxattr
+ init_module
+ ioctl
if [[ $HOSTTYPE == i?86 ]]; then
    + ioperm
    + iopl
fi
+ lchown
if [[ $HOSTTYPE == !(ppc|x86_64|s390x|ia64) ]]; then
    + lchown16
    + lchown32
fi
+ link
+ lremovexattr
+ lsetxattr
+ mkdir
+ mknod
+ mount
+ msgctl
+ msgsnd
+ msgrcv
+ msgget
+ open
+ ptrace
+ removexattr
+ rename
+ rmdir
+ semctl
+ semget
+ semop
+ semtimedop
+ setfsgid
if [[ $HOSTTYPE == !(ppc|x86_64|s390x|ia64) ]]; then
    + setfsgid32
fi
+ setfsuid
if [[ $HOSTTYPE == !(ppc|x86_64|s390x|ia64) ]]; then
    + setfsuid32
fi
+ setgid
if [[ $HOSTTYPE == !(ppc|x86_64|s390x|ia64) ]]; then
    + setgid32
fi
+ setgroups
if [[ $HOSTTYPE == !(ppc|x86_64|s390x|ia64) ]]; then
    + setgroups32
fi
+ setregid
if [[ $HOSTTYPE == !(ppc|x86_64|s390x|ia64) ]]; then
    + setregid32
fi
+ setresgid
if [[ $HOSTTYPE == !(ppc|x86_64|s390x|ia64) ]]; then
    + setresgid32
fi
+ setresuid
if [[ $HOSTTYPE == !(ppc|x86_64|s390x|ia64) ]]; then
    + setresuid32
fi
+ setreuid
if [[ $HOSTTYPE == !(ppc|x86_64|s390x|ia64) ]]; then
    + setreuid32
fi
+ settimeofday
+ setuid
if [[ $HOSTTYPE == !(ppc|x86_64|s390x|ia64) ]]; then
    + setuid32
fi
+ setxattr
+ shmat
+ shmctl
+ shmget
if [[ $HOSTTYPE == !(x86_64|ia64) ]]; then
    + stime
fi
+ swapon
+ symlink
+ truncate
if [[ $HOSTTYPE == !(ppc|x86_64|s390x|ia64) ]]; then
    + truncate64
fi
+ umask
- umask badargs
+ unlink
if [[ $HOSTTYPE != ia64 ]]; then
    + utime
fi
if [[ $HOSTTYPE == ia64 ]]; then
    + utimes
fi
if [[ $HOSTTYPE != ia64 ]]; then
    + vfork
fi
