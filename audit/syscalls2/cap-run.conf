#!/bin/bash
# =============================================================================
# (c) Copyright Hewlett-Packard Development Company, L.P., 2007
#
#   This program is free software;  you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY;  without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
#   the GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program;  if not, write to the Free Software
#   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
# =============================================================================

##
## FS syscalls
##

## SYSCALL:	chmod()
## PURPOSE:
## Verify audit of attempts to change permissions of a file.  The test cases
## below try to change the permissions of a file which may or may not be
## owned by the user running the test process.  The test procedure is as
## follows:
## 1.  Create a new file.
## 2a. If expres=success, execute the test process as the file owner and
##     attempt to change the file permissions according to the value specified
##     by the 'flag' variable, verify the result
## 2b. If expres=fail, execute the test process as another user and
##     attempt to change the file permissions according to the value specified
##     by the 'flag' variable, verify the result
## 3.  Check the audit log for the correct syscall result
+ chmod perm=file_priv flag=777 expres=success owner=user
+ chmod perm=file_priv flag=777 expres=fail owner=user err=EPERM

## SYSCALL:	chown()
## PURPOSE:
## Verify audit of attempts to change the ownership of a file.  The test cases
## below try to change the ownership for a file which may or may not be
## owned by the user running the test process.  The test procedure is as
## follows:
## 1.  Create a new file.
## 2a. If expres=success, execute the test process as the file owner and
##     attempt to change the file ownership to the user specified
##     by the 'flag' variable, verify the result
## 2b. If expres=fail, execute the test process as another user and
##     attempt to change the file ownership to the user specified
##     by the 'flag' variable, verify the result
## 3.  Check the audit log for the correct syscall result
+ chown perm=file_priv flag=root expres=success owner=user
+ chown perm=file_priv flag=root expres=fail owner=user err=EPERM
if [[ $MODE == 32 ]]; then
+ chown32 perm=file_priv flag=root expres=success owner=user
+ chown32 perm=file_priv flag=root expres=fail owner=user err=EPERM
fi

## SYSCALL:	fchmod()
## PURPOSE:
## Verify audit of attempts to change permissions of a file.  The test cases
## below try to change the permissions of a file which may or may not be
## owned by the user running the test process.  The test procedure is as
## follows:
## 1.  Create a new file.
## 2a. If expres=success, execute the test process as the file owner and
##     attempt to change the file permissions according to the value specified
##     by the 'flag' variable, verify the result
## 2b. If expres=fail, execute the test process as another user and
##     attempt to change the file permissions according to the value specified
##     by the 'flag' variable, verify the result
## 3.  Check the audit log for the correct syscall result
+ fchmod perm=file_priv flag=777 expres=success owner=user
+ fchmod perm=file_priv flag=777 expres=fail owner=user err=EPERM

## SYSCALL:	fchmodat()
## PURPOSE:
## Verify audit of attempts to change permissions of a file relative to a
## directory file descriptor. See above for more details.
+ fchmodat perm=file_priv at=1 flag=777 expres=success owner=user
+ fchmodat perm=file_priv at=1 flag=777 expres=fail owner=user err=EPERM

## SYSCALL:	fchown()
## PURPOSE:
## Verify audit of attempts to change the ownership of a file.  The test cases
## below try to change the ownership for a file which may or may not be
## owned by the user running the test process.  The test procedure is as
## follows:
## 1.  Create a new file.
## 2a. If expres=success, execute the test process as the file owner and
##     attempt to change the file ownership to the user specified
##     by the 'flag' variable, verify the result
## 2b. If expres=fail, execute the test process as another user and
##     attempt to change the file ownership to the user specified
##     by the 'flag' variable, verify the result
## 3.  Check the audit log for the correct syscall result
+ fchown perm=file_priv flag=root expres=success owner=user
+ fchown perm=file_priv flag=root expres=fail owner=user err=EPERM
if [[ $MODE == 32 ]]; then
+ fchown32 perm=file_priv flag=root expres=success owner=user
+ fchown32 perm=file_priv flag=root expres=fail owner=user err=EPERM
fi

## SYSCALL:	fchownat()
## PURPOSE:
## Verify audit of attempts to change the ownership of a file relative to a
## directory file descriptor. See above for more details.
+ fchownat perm=file_priv at=1 flag=root expres=success owner=user
+ fchownat perm=file_priv at=1 flag=root expres=fail owner=user err=EPERM

## SYSCALL:	lchown()
## PURPOSE:
## Verify audit of attempts to change the ownership of a file.  The test cases
## below try to change the ownership for a file which may or may not be
## owned by the user running the test process.  The test procedure is as
## follows:
## 1.  Create a new file.
## 2a. If expres=success, execute the test process as the file owner and
##     attempt to change the file ownership to the user specified
##     by the 'flag' variable, verify the result
## 2b. If expres=fail, execute the test process as another user and
##     attempt to change the file ownership to the user specified
##     by the 'flag' variable, verify the result
## 3.  Check the audit log for the correct syscall result
+ lchown perm=file_priv flag=root expres=success owner=user
+ lchown perm=file_priv flag=root expres=fail owner=user err=EPERM
if [[ $MODE == 32 ]]; then
+ lchown32 perm=file_priv flag=root expres=success owner=user
+ lchown32 perm=file_priv flag=root expres=fail owner=user err=EPERM
fi

## SYSCALL:     mount()
## PURPOSE:
## Verify audit of attempts to mount a filesystem.  The test cases below try to
## mount a filesystem at a mount point which may or may not be accessible to
## the test process executing the mount() syscall.  The test procedure is as
## follows:
## 1.  Create a new directory which will be the mount point.
## 2a. If expres=success, execute the test process as the directory owner and
##     attempt to mount the filesystem, verify the result
## 2b. If expres=fail, execute the test process as another user and
##     attempt to mount the filesystem, verify the result
## 3.  Check the audit log for the correct syscall result
+ mount perm=dir_mount expres=success owner=user
+ mount perm=dir_mount expres=fail owner=user err=EPERM

## SYSCALL:	swapon()
## PURPOSE:
## Verify audit of attempts to set the swap area. The testcases below try to set
## the swap area as a privileged or unprivileged user.  The test procedure is
## as follows:
## 1.  Create a new file to be used as a swap area.
## 2a. If expres=success, execute the test process as the superuser and
##     attempt to enable the swap file, verify the result
## 2b. If expres=fail, execute the test process as a regular user and
##     attempt to enable the swap file, verify the result
## 3.  Check the audit log for the correct syscall result
+ swapon perm=file_swap expres=success owner=user
+ swapon perm=file_swap expres=fail owner=user err=EPERM

## SYSCALL:	umask()
## PURPOSE:
## Verify audit of attempts to set the file mode creation mask for a process.
## The testcase below sets the file mode creation mask for the test process.
## The umask() syscall is always sucessful.  The test procedure is as follows:
##  1. Execute the test process and set the file mode creation mask,
##     verify the result.
##  2. Check the audit log for the correct syscall result
+ umask perm=umask_set expres=success owner=user

##
## IPC syscalls
##

## Note: When testing the ipc() syscall, the 'op' variable determines the tested
## syscall operation.

## SYSCALL:     msgctl(), ipc()
## PURPOSE:
## Verify audit of attempts to perform message control operations.  There are
## two types of testcases in this set of tests. The first, using the
## 'perm=msg_id_remove' variable, tries to remove a message queue that may or
## may not be owned by the test process.  The second, using the
## 'perm=msg_id_set' variable, tries to set the msg_perm.uid for a message queue
## that may or may not be owned by the test process.  The test procedure is as
## follows:
## 1.  Create a message queue.
## 2a. If expres=success, execute the test process as the message queue
##     owner and attempt the syscall using the value of flag to determine
##     the control operation; verify the result.
## 2b. If expres=fail, execute the test process as another user and attempt the
##     syscall using the value of flag to determine the control operation;
##     verify the result.
## 3.  Check the audit log for the correct syscall result
if [[ $MODE == 64 ]]; then
+ msgctl perm=msg_id_remove expres=success owner=user
+ msgctl perm=msg_id_remove expres=fail owner=user err=EPERM
+ msgctl perm=msg_id_set expres=success owner=user
+ msgctl perm=msg_id_set expres=fail owner=user err=EPERM
else
+ ipc op=msgctl perm=msg_id_remove expres=success owner=user
+ ipc op=msgctl perm=msg_id_remove expres=fail owner=user err=EPERM
+ ipc op=msgctl perm=msg_id_set expres=success owner=user
+ ipc op=msgctl perm=msg_id_set expres=fail owner=user err=EPERM
fi

## SYSCALL:     semctl(), ipc()
## PURPOSE:
## Verify audit of attempts to perform semaphore control operations.  There are
## two types of testcases in this set of tests. The first, using the
## 'perm=sem_id_remove' variable, tries to remove a semaphore set that may or
## may not be owned by the test process.  The second, using the
## 'perm=sem_id_set' variable, tries to set the sem_perm.uid for a semaphore set
## that may or may not be owned by the test process.  The test procedure is as
## follows:
## 1.  Create a semaphore set.
## 2a. If expres=success, execute the test process as the semaphore set
##     owner and attempt the syscall using the value of flag to determine
##     the control operation; verify the result.
## 2b. If expres=fail, execute the test process as another user and attempt the
##     syscall using the value of flag to determine the control operation;
##     verify the result.
## 3.  Check the audit log for the correct syscall result
if [[ $MODE == 64 ]]; then
+ semctl perm=sem_id_remove expres=success owner=user
+ semctl perm=sem_id_remove expres=fail owner=user err=EPERM
+ semctl perm=sem_id_set expres=success owner=user
+ semctl perm=sem_id_set expres=fail owner=user err=EPERM
else
+ ipc op=semctl perm=sem_id_remove expres=success owner=user
+ ipc op=semctl perm=sem_id_remove expres=fail owner=user err=EPERM
+ ipc op=semctl perm=sem_id_set expres=success owner=user
+ ipc op=semctl perm=sem_id_set expres=fail owner=user err=EPERM
fi

## SYSCALL:     shmctl(), ipc()
## PURPOSE:
## Verify audit of attempts to perform shared memory control operations.  There
## are two types of testcases in this set of tests. The first, using the
## 'perm=shm_id_remove' variable, tries to remove a shared memory segment that
## may or may not be owned by the test process.  The second, using the
## 'perm=shm_id_set' variable, tries to set the shm_perm.uid for a shared memory
## segment that may or may not be owned by the test process.  The test procedure
## is as follows:
## 1.  Create a shared memory segment.
## 2a. If expres=success, execute the test process as the shared memory segment
##     owner and attempt the syscall using the value of flag to determine
##     the control operation; verify the result.
## 2b. If expres=fail, execute the test process as another user and attempt the
##     syscall using the value of flag to determine the control operation;
##     verify the result.
## 3.  Check the audit log for the correct syscall result
if [[ $MODE == 64 ]]; then
+ shmctl perm=shm_id_remove expres=success owner=user
+ shmctl perm=shm_id_remove expres=fail owner=user err=EPERM
+ shmctl perm=shm_id_set expres=success owner=user
+ shmctl perm=shm_id_set expres=fail owner=user err=EPERM
else
+ ipc op=shmctl perm=shm_id_remove expres=success owner=user
+ ipc op=shmctl perm=shm_id_remove expres=fail owner=user err=EPERM
+ ipc op=shmctl perm=shm_id_set expres=success owner=user
+ ipc op=shmctl perm=shm_id_set expres=fail owner=user err=EPERM
fi

##
## NETWORK and I/O syscalls
##

## SYSCALL:	bind(), socketcall()
## PURPOSE:
## Verify audit of attempts to bind a port to a socket.  The testcases below try
## bind a privileged port to a socket as the superuser and as a regular user.
## The test procedure is as follows:
## 1a. If expres=success, execute the test process as the superuser and
##     attempt to bind a privileged port, verify the result.
## 1b. If expres=fail, execute the test process as a regular user and
##     attempt to bind a privileged port, verify the result.
##  2. Check the audit log for the correct syscall result
if [[ $MODE == 64 ]]; then
+ bind perm=port_bind_priv expres=success owner=user
+ bind perm=port_bind_priv expres=fail owner=user err=EACCES
fi
if [[ $MODE == 32 ]]; then
+ socketcall perm=port_bind_priv op=bind expres=success owner=user
+ socketcall perm=port_bind_priv op=bind expres=fail owner=user err=EACCES
fi

## SYSCALL:	ioctl()
## PURPOSE:
## Verify audit of attempts to control devices.  The testcases below try to set
## the locking status of the terminal's termios structure as the superuser and
## as a regular user.  The test procedure is as follows:
## 1a. If expres=success, execute the test process as the superuser and
##     attempt to set the locking status, verify the result.
## 1b. If expres=fail, execute the test process as a regular user and
##     attempt to set the locking status, verify the result.
##  2. Check the audit log for the correct syscall result
+ ioctl perm=tty_setlock expres=success owner=user
+ ioctl perm=tty_setlock expres=fail owner=user err=EPERM

## SYSCALL:	ioperm()
## PURPOSE:
## Verify audit of attempts to set the port access permission bits for a
## process.  The testcases below try to set port permission bits as the
## superuser and as a regular user.  The test procedure is as follows:
## 1a. If expres=success, execute the test process as the superuser and
##     attempt to set port permission bits, verify the result.
## 1b. If expres=fail, execute the test process as a regular user and
##     attempt to set port permission bits, verify the result.
##  2. Check the audit log for the correct syscall result
if [[ $MODE == 32 ]]; then
+ ioperm perm=io_perm expres=success owner=user
+ ioperm perm=io_perm expres=fail owner=user err=EPERM
fi

## SYSCALL:	iopl()
## PURPOSE:
## Verify audit of attempts to set the I/O privilege level for a process.
## The testcases below try to set the I/O privilege level as the
## superuser and as a regular user.  The test procedure is as follows:
## 1a. If expres=success, execute the test process as the superuser and
##     attempt to set process's the I/O privilege level, verify the result.
## 1b. If expres=fail, execute the test process as a regular user and
##     attempt to set process's the I/O privilege level, verify the result.
##  2. Check the audit log for the correct syscall result
if [[ $MODE == 32 ]]; then
+ iopl perm=io_priv expres=success owner=user
+ iopl perm=io_priv expres=fail owner=user err=EPERM
fi

##
## PROCESS CONTROL syscalls
##

## SYSCALL:	ptrace()
## PURPOSE:
## Verify that the ptrace() syscall is subject to the correct MLS constraints
## when tracing a process.  The testcases below try to commence tracing a
## process which has a MLS sensitivity label which may or may not be accessible
## to the test process executing the ptrace() syscall.  The test procedure is as
## follows:
##  1. Start a new dummy process such that the MLS relationship between the
##     dummy process and the test process is defined by the mlsop variable (dom,
##     domby, incomp).
##  2. Execute the test process and attempt the ptrace() syscall with the
##     PTRACE_ATTACH request, verify the result
##  3. Check the audit log for the correct syscall result
















+ ptrace perm=process_attach expres=success owner=user
+ ptrace perm=process_attach expres=fail owner=user err=EPERM

+ clone perm=process_newns expres=success owner=user
+ clone perm=process_newns expres=fail owner=user err=EPERM

if [[ $HOSTTYPE == ia64 ]]; then
+ clone2 perm=process_newns expres=success owner=user
+ clone2 perm=process_newns expres=fail owner=user err=EPERM
fi

if [[ $HOSTTYPE != ia64 ]]; then
+ fork perm=process_nproc expres=success owner=user \
  testfunc=test_su_fork
+ fork perm=process_nproc expres=fail owner=user err=EAGAIN \
  testfunc=test_su_fork
fi

if [[ $HOSTTYPE != ia64 ]]; then
+ vfork perm=process_nproc expres=success owner=user \
  testfunc=test_su_fork
+ vfork perm=process_nproc expres=fail owner=user err=EAGAIN \
  testfunc=test_su_fork
fi

##
## PROCESS CREDENTIALS syscalls
##

## SYSCALL:	setgid()
## PURPOSE:
## Verify audit of attempts to set the effective group identity for a
## process.  The testcases below try to set the effective group id as the
## superuser and as a regular user.  The test procedure is as follows:
## 1a. If expres=success, execute the test process as the superuser and
##     attempt to set the effective group id to 0, verify the result.
## 1b. If expres=fail, execute the test process as a regular user and
##     attempt to set the effective group id to 0, verify the result.
##  2. Check the audit log for the correct syscall result
+ setgid perm=gid_set expres=success owner=user
+ setgid perm=gid_set expres=fail owner=user err=EPERM
if [[ $MODE == 32 ]]; then
+ setgid32 perm=gid_set expres=success owner=user
+ setgid32 perm=gid_set expres=fail owner=user err=EPERM
fi

## SYSCALL:	setregid()
## PURPOSE:
## Verify audit of attempts to set the real and effective group identity
## for a process.  The testcases below try to set the real and effective
## group id as the superuser and as a regular user.  The test procedure is
## as follows:
## 1a. If expres=success, execute the test process as the superuser and
##     attempt to set the real/effective group id to 0, verify the result.
## 1b. If expres=fail, execute the test process as a regular user and
##     attempt to set the real/effective group id to 0, verify the result.
##  2. Check the audit log for the correct syscall result
+ setregid perm=gid_set expres=success owner=user
+ setregid perm=gid_set expres=fail owner=user err=EPERM
if [[ $MODE == 32 ]]; then
+ setregid32 perm=gid_set expres=success owner=user
+ setregid32 perm=gid_set expres=fail owner=user err=EPERM
fi

## SYSCALL:	setresgid()
## PURPOSE:
## Verify audit of attempts to set the real, effective and saved group identity
## for a process.  The testcases below try to set the real, effective and saved
## group id as the superuser and as a regular user.  The test procedure is
## as follows:
## 1a. If expres=success, execute the test process as the superuser and
##     attempt to set the real/effective/saved group id to 0, verify the result.
## 1b. If expres=fail, execute the test process as a regular user and
##     attempt to set the real/effective/saved group id to 0, verify the result.
##  2. Check the audit log for the correct syscall result
+ setresgid perm=gid_set expres=success owner=user
+ setresgid perm=gid_set expres=fail owner=user err=EPERM
if [[ $MODE == 32 ]]; then
+ setresgid32 perm=gid_set expres=success owner=user
+ setresgid32 perm=gid_set expres=fail owner=user err=EPERM
fi

## SYSCALL:	setuid()
## PURPOSE:
## Verify audit of attempts to set the effective user identity for a
## process.  The testcases below try to set the effective user id as the
## superuser and as a regular user.  The test procedure is as follows:
## 1a. If expres=success, execute the test process as the superuser and
##     attempt to set the effective user id to 0, verify the result.
## 1b. If expres=fail, execute the test process as a regular user and
##     attempt to set the effective user id to 0, verify the result.
##  2. Check the audit log for the correct syscall result
+ setuid perm=uid_set expres=success owner=user
+ setuid perm=uid_set expres=fail owner=user err=EPERM
if [[ $MODE == 32 ]]; then
+ setuid32 perm=uid_set expres=success owner=user
+ setuid32 perm=uid_set expres=fail owner=user err=EPERM
fi

## SYSCALL:	setreuid()
## PURPOSE:
## Verify audit of attempts to set the real and effective user identity
## for a process.  The testcases below try to set the real and effective
## user id as the superuser and as a regular user.  The test procedure is
## as follows:
## 1a. If expres=success, execute the test process as the superuser and
##     attempt to set the real/effective user id to 0, verify the result.
## 1b. If expres=fail, execute the test process as a regular user and
##     attempt to set the real/effective user id to 0, verify the result.
##  2. Check the audit log for the correct syscall result
+ setreuid perm=uid_set expres=success owner=user
+ setreuid perm=uid_set expres=fail owner=user err=EPERM
if [[ $MODE == 32 ]]; then
+ setreuid32 perm=uid_set expres=success owner=user
+ setreuid32 perm=uid_set expres=fail owner=user err=EPERM
fi

## SYSCALL:	setresuid()
## PURPOSE:
## Verify audit of attempts to set the real, effective and saved user identity
## for a process.  The testcases below try to set the real, effective and saved
## user id as the superuser and as a regular user.  The test procedure is
## as follows:
## 1a. If expres=success, execute the test process as the superuser and
##     attempt to set the real/effective/saved user id to 0, verify the result.
## 1b. If expres=fail, execute the test process as a regular user and
##     attempt to set the real/effective/saved user id to 0, verify the result.
##  2. Check the audit log for the correct syscall result
+ setresuid perm=uid_set expres=success owner=user
+ setresuid perm=uid_set expres=fail owner=user err=EPERM
if [[ $MODE == 32 ]]; then
+ setresuid32 perm=uid_set expres=success owner=user
+ setresuid32 perm=uid_set expres=fail owner=user err=EPERM
fi

##
## TIME syscalls
##

## SYSCALL:	adjtimex()
## PURPOSE:
## Verify audit of attempts to tune the kernel clock. The testcases below try to
## tune the kernel clock both as the superuser and as a regular user.  The test
## procedure is as follows:
## 1a. If expres=success, execute the test process as the superuser, and attempt
##     to read kernel clock tunables, verify the result.
## 1b. If expres=fail, execute the test process as a regular user and 
##     attempt to tune the kernel clock using the mode specified
##     by the 'flag' variable, verify the result
##  2. Check the audit log for the correct syscall result
+ adjtimex perm=time_adjust expres=success owner=user
+ adjtimex perm=time_adjust flag=singleshot expres=fail owner=user err=EPERM

## SYSCALL:	clock_settime()
## PURPOSE:
## Verify audit of attempts to set the system clock. The testcases below try to
## set the system clock both as the superuser and as a regular user.  The test
## procedure is as follows:
## 1a. If expres=success, execute the test process as the superuser, and attempt
##     to set the system clock, verify the result.
## 1b. If expres=fail, execute the test process as a regular user and 
##     attempt to set the system clock, verify the result.
##  2. Check the audit log for the correct syscall result
+ clock_settime perm=time_set expres=success owner=user
+ clock_settime perm=time_set expres=fail owner=user err=EPERM

## SYSCALL:	settimeofday()
## PURPOSE:
## Verify audit of attempts to set the time and/or timezone. The testcases below
## try to set the time and timezone both as the superuser and as a regular user.
## The test procedure is as follows:
## 1a. If expres=success, execute the test process as the superuser, and attempt
##     to set the time, verify the result.
## 1b. If expres=fail, execute the test process as a regular user and 
##     attempt to set the time, verify the result.
##  2. Check the audit log for the correct syscall result
+ settimeofday perm=time_zone_set expres=success owner=user \
  testfunc=test_su_time_zone
+ settimeofday perm=time_zone_set expres=fail owner=user err=EPERM \
  testfunc=test_su_time_zone

## SYSCALL:	stime()
## PURPOSE:
## Verify audit of attempts to set the time. The testcases below try to
## set the time both as the superuser and as a regular user.  The test
## procedure is as follows:
## 1a. If expres=success, execute the test process as the superuser, and attempt
##     to set the time, verify the result.
## 1b. If expres=fail, execute the test process as a regular user and 
##     attempt to set the time, verify the result.
##  2. Check the audit log for the correct syscall result
if [[ $MODE == 32 ]]; then
+ stime perm=time_set expres=success owner=user
+ stime perm=time_set expres=fail owner=user err=EPERM
fi

##
## XATTR syscalls
##

## SYSCALL:	removexattr(), fremovexattr(), lremovexattr()
## PURPOSE:
## Verify that regular users cannot remove security attributes on files they
## do not own.  The testcases below try to remove the security.selinux attribute
## on a file which is owned by the superuser.  The test procedure is as follows:
##  1. Create a new file as the superuser.
##  2. As a regular user, attempt to remove the security.selinux attribute from
##     the file, verify the result.
##  3. Check the audit log for the correct syscall result
if [[ $PPROFILE == lspp ]]; then
+ fremovexattr perm=secattr_remove flag=security.selinux expres=fail owner=user err=EACCES
+ lremovexattr perm=secattr_remove flag=security.selinux expres=fail owner=user err=EACCES
+ removexattr perm=secattr_remove flag=security.selinux expres=fail owner=user err=EACCES
fi

## SYSCALL:	setxattr(), fsetxattr(), lsetxattr()
## PURPOSE:
## Verify that regular users cannot modify the values of security attributes on
## files they do not own.  The testcases below try to modify the value of the
## security.selinux attribute on a file which is owned by the superuser.
## The test procedure is as follows:
##  1. Create a new file as the superuser.
##  2. As a regular user, attempt to modify the file's security.selinux
##     attribute, verify the result.
##  3. Check the audit log for the correct syscall result
if [[ $PPROFILE == lspp ]]; then
+ fsetxattr perm=secattr_set flag=security.selinux expres=fail owner=user \
  err=EPERM testfunc=test_su_setxattr
+ lsetxattr perm=secattr_set flag=security.selinux expres=fail owner=user \
  err=EPERM testfunc=test_su_setxattr
+ setxattr perm=secattr_set flag=security.selinux expres=fail owner=user \
  err=EPERM testfunc=test_su_setxattr
fi
