#!/bin/bash
# =============================================================================
# (c) Copyright Hewlett-Packard Development Company, L.P., 2007
#
#   This program is free software;  you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY;  without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
#   the GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program;  if not, write to the Free Software
#   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
# =============================================================================

function test_dac_default {
    # use $tag instead of $expres to work around the cases
    # where a success is an expected failure.
    if [[ $tag == *success* ]]; then
	read testres exitval pid \
	    <<<"$(do_$syscall $op $dirname $source $target $flag)"
    else
	# use single quotes so $$ doesn't expand early
	read uid euid suid fsuid gid egid sgid fsgid \
	    <<<"$(/bin/su - $TEST_USER -c 'ps --no-headers -p $$ -o uid,euid,suid,fsuid,gid,egid,sgid,fsgid')"
	read testres exitval pid \
	    <<<"$(/bin/su - $TEST_USER -c "$(which do_$syscall) $op $dirname $source $target $flag")"
    fi
}

function test_dac_msg_send {
    # use $tag instead of $expres to work around the cases
    # where a success is an expected failure.
    if [[ $tag == *success* ]]; then
	read testres exitval pid \
	    <<<"$(do_$syscall $op $target $flag "$msg")"
    else
	# use single quotes so $$ doesn't expand early
	read uid euid suid fsuid gid egid sgid fsgid \
	    <<<"$(/bin/su - $TEST_USER -c 'ps --no-headers -p $$ -o uid,euid,suid,fsuid,gid,egid,sgid,fsgid')"
	read testres exitval pid \
	    <<<"$(/bin/su - $TEST_USER -c "$(which do_$syscall) $op $target $flag "$msg"")"
    fi
}

function test_dac_setxattr {
    # use $tag instead of $expres to work around the cases
    # where a success is an expected failure.
    if [[ $tag == *success* ]]; then
	read testres exitval pid \
	    <<<"$(do_$syscall $op $target $flag "$msg")"
    else
	# use single quotes so $$ doesn't expand early
	read uid euid suid fsuid gid egid sgid fsgid \
	    <<<"$(/bin/su - $TEST_USER -c 'ps --no-headers -p $$ -o uid,euid,suid,fsuid,gid,egid,sgid,fsgid')"
	read testres exitval pid \
	    <<<"$(/bin/su - $TEST_USER -c "$(which do_$syscall) $target $flag $value")"
    fi
}

##
## FS syscalls
##

## SYSCALL:	access()
## PURPOSE:
## Verify audit of attempts to check permissions for a file.  The testcases
## below try to check permissions for a file which may or may not be accessible
## to the test process.  The test procedure is as follows:
## 1.  Create a new file and make it only accessible to the file owner.
## 2a. If expres=success, execute the test process as the file owner and
##     attempt to check permissions; verify the result
## 2b. If expres=fail, execute the test process as another user and
##     attempt to check permissions; verify the result
## 3.  Check the audit log for the correct syscall result
+ access perm=file_read expres=success owner=user
+ access perm=file_read expres=fail owner=user err=EACCES

## SYSCALL:	chdir()
## PURPOSE:
## Verify audit of attempts to change working directory.  The test cases
## below try to change the current working directory to a directory that may or
## may not be accessible to the test process.  The test procedure is as follows:
## 1.  Create a new directory.
## 2a. If expres=success, execute the test process as the directory owner and
##     attempt to change the working directory to the new directory;
##     verify the result
## 2b. If expres=fail, execute the test process as another user and
##     attempt to change the working directory to the new directory;
##     verify the result
## 3.  Check the audit log for the correct syscall result
+ chdir perm=dir_exec expres=success owner=user
+ chdir perm=dir_exec expres=fail owner=user err=EACCES

## SYSCALL:	chmod()
## PURPOSE:
## Verify audit of attempts to change permissions of a file.  The test cases
## below try to change the permissions of a file which may or may not be
## owned by the user running the test process.  The test procedure is as
## follows:
## 1.  Create a new file.
## 2a. If expres=success, execute the test process as the file owner and
##     attempt to change the file permissions according to the value specified
##     by the 'flag' variable, verify the result
## 2b. If expres=fail, execute the test process as another user and
##     attempt to change the file permissions according to the value specified
##     by the 'flag' variable, verify the result
## 3.  Check the audit log for the correct syscall result
+ chmod perm=priv_modify flag=777 expres=success owner=user
+ chmod perm=priv_modify flag=777 expres=fail owner=user err=EPERM

## SYSCALL:	chown()
## PURPOSE:
## Verify audit of attempts to change the ownership of a file.  The test cases
## below try to change the ownership for a file which may or may not be
## owned by the user running the test process.  The test procedure is as
## follows:
## 1.  Create a new file.
## 2a. If expres=success, execute the test process as the file owner and
##     attempt to change the file ownership to the user specified
##     by the 'flag' variable, verify the result
## 2b. If expres=fail, execute the test process as another user and
##     attempt to change the file ownership to the user specified
##     by the 'flag' variable, verify the result
## 3.  Check the audit log for the correct syscall result
+ chown perm=priv_modify flag=root expres=success owner=user
+ chown perm=priv_modify flag=root expres=fail owner=user err=EPERM
if [[ $MODE == 32 ]]; then
    + chown32 perm=priv_modify flag=root expres=success owner=user
    + chown32 perm=priv_modify flag=root expres=fail owner=user err=EPERM
fi

## SYSCALL:	creat()
## PURPOSE:
## Verify audit of attempts to create new files in the filesystem.  The
## testcases below try to create a new file in a directory which may or may not
## be accessible to the test process.  The test procedure is as follows:
## 1.  Create a new directory and make it only accessible to the directory owner.
## 2a. If expres=success, execute the test process as the directory owner and
##     attempt to create a new file in the directory, verify the result
## 2b. If expres=fail, execute the test process as another user and
##     attempt to create a new file in the directory, verify the result
## 3.  Check the audit log for the correct syscall result
+ creat perm=dir_add_name expres=success owner=user
+ creat perm=dir_add_name expres=fail owner=user err=EACCES

## SYSCALL:     execve()
## PURPOSE:
## Verify audit of attempts to execute program.  The test cases below try to
## execute a file for which the user may or may not have appropriate
## permissions. The test procedure is as follows:
## 1.  Create a file which is only executable by the file owner.
## 2a. If expres=success, execute the test process as the file owner and
##     attempt to execute the test file, verify the result
## 2b. If expres=fail, execute the test process as another user and attempt to
##     execute the test file, verify the result
##  3. Check the audit log for the correct syscall result
+ execve perm=file_exec expres=success owner=user
+ execve perm=file_exec expres=fail owner=user err=EACCES

## SYSCALL:	fchmod()
## PURPOSE:
## Verify audit of attempts to change permissions of a file.  The test cases
## below try to change the permissions of a file which may or may not be
## owned by the user running the test process.  The test procedure is as
## follows:
## 1.  Create a new file.
## 2a. If expres=success, execute the test process as the file owner and
##     attempt to change the file permissions according to the value specified
##     by the 'flag' variable, verify the result
## 2b. If expres=fail, execute the test process as another user and
##     attempt to change the file permissions according to the value specified
##     by the 'flag' variable, verify the result
## 3.  Check the audit log for the correct syscall result
+ fchmod perm=priv_modify flag=777 expres=success owner=user
+ fchmod perm=priv_modify flag=777 expres=fail owner=user err=EPERM

## SYSCALL:	fchmodat()
## PURPOSE:
## Verify audit of attempts to change permissions of a file relative to a
## directory file descriptor. See above for more details.
+ fchmodat perm=priv_modify at=1 flag=777 expres=success owner=user
+ fchmodat perm=priv_modify at=1 flag=777 expres=fail owner=user err=EPERM

## SYSCALL:	fchown()
## PURPOSE:
## Verify audit of attempts to change the ownership of a file.  The test cases
## below try to change the ownership for a file which may or may not be
## owned by the user running the test process.  The test procedure is as
## follows:
## 1.  Create a new file.
## 2a. If expres=success, execute the test process as the file owner and
##     attempt to change the file ownership to the user specified
##     by the 'flag' variable, verify the result
## 2b. If expres=fail, execute the test process as another user and
##     attempt to change the file ownership to the user specified
##     by the 'flag' variable, verify the result
## 3.  Check the audit log for the correct syscall result
+ fchown perm=priv_modify flag=root expres=success owner=user
+ fchown perm=priv_modify flag=root expres=fail owner=user err=EPERM
if [[ $MODE == 32 ]]; then
    + fchown32 perm=priv_modify flag=root expres=success owner=user
    + fchown32 perm=priv_modify flag=root expres=fail owner=user err=EPERM
fi

## SYSCALL:	fchownat()
## PURPOSE:
## Verify audit of attempts to change the ownership of a file relative to a
## directory file descriptor. See above for more details.
+ fchownat perm=priv_modify at=1 flag=root expres=success owner=user
+ fchownat perm=priv_modify at=1 flag=root expres=fail owner=user err=EPERM

## SYSCALL:	lchown()
## PURPOSE:
## Verify audit of attempts to change the ownership of a file.  The test cases
## below try to change the ownership for a file which may or may not be
## owned by the user running the test process.  The test procedure is as
## follows:
## 1.  Create a new file.
## 2a. If expres=success, execute the test process as the file owner and
##     attempt to change the file ownership to the user specified
##     by the 'flag' variable, verify the result
## 2b. If expres=fail, execute the test process as another user and
##     attempt to change the file ownership to the user specified
##     by the 'flag' variable, verify the result
## 3.  Check the audit log for the correct syscall result
+ lchown perm=priv_modify flag=root expres=success owner=user
+ lchown perm=priv_modify flag=root expres=fail owner=user err=EPERM
if [[ $MODE == 32 ]]; then
    + lchown32 perm=priv_modify flag=root expres=success owner=user
    + lchown32 perm=priv_modify flag=root expres=fail owner=user err=EPERM
fi

## SYSCALL:	link()
## PURPOSE:
## Verify audit of attempts to create hard links in the filesystem. The test
## cases below try to create a new hard link in a directory for which the user
## may or may not have appropriate permissions. The test procedure is as
## follows:
## 1.  Create a new source file which is accessible to all users.
## 2.  Create a new destination directory for the hard link which is only
##     accessible to the directory owner.
## 3a. If expres=success, execute the test process as the directory owner and
##     attempt to create a hard link, verify the result
## 3b. If expres=fail, execute the test process as another user and
##     attempt to create a hard link, verify the result
## 4.  Check the audit log for the correct syscall result
+ link perm=dir_add_name which=new expres=success owner=user
+ link perm=dir_add_name which=new expres=fail owner=user err=EACCES

## SYSCALL:	linkat()
## PURPOSE:
## Verify audit of attempts to create hard links relative to a directory file
## descriptor. See above for more details.
+ linkat perm=dir_add_name at=1 which=new expres=success owner=user
+ linkat perm=dir_add_name at=1 which=new expres=fail owner=user err=EACCES

## SYSCALL:	mkdir()
## PURPOSE:
## Verify audit of attempts to create new directories in the filesystem. The
## test cases below try to create a new sub-directory in a directory for which
## the user may or may not have appropriate permissions.  The test procedure is
## as follows:
## 1.  Create a new destination directory for the sub-directory which is only
##     accessible to the directory owner.
## 2a. If expres=success, execute the test process as the directory owner and
##     attempt to create a directory, verify the result
## 2b. If expres=fail, execute the test process as another user and
##     attempt to create a directory, verify the result
## 3.  Check the audit log for the correct syscall result
+ mkdir perm=dir_add_name expres=success owner=user
+ mkdir perm=dir_add_name expres=fail owner=user err=EACCES

## SYSCALL:	mkdirat()
## PURPOSE:
## Verify audit of attempts to create new directories relative to a directory
## file descriptor. See above for more details.
+ mkdirat perm=dir_add_name at=1 expres=success owner=user
+ mkdirat perm=dir_add_name at=1 expres=fail owner=user err=EACCES

## SYSCALL:	mknod()
## PURPOSE:
## Verify audit of attempts to create new nodes in the filesystem. The
## test cases below try to create a new node in a directory for which the user
## may or may not have appropriate permissions. The test procedure is as
## follows:
## 1.  Create a new destination directory for the node which is only
##     accessible to the directory owner.
## 2a. If expres=success, execute the test process as the directory owner and
##     attempt to create a node, verify the result
## 2b. If expres=fail, execute the test process as another user and
##     attempt to create a node, verify the result
## 3.  Check the audit log for the correct syscall result
+ mknod perm=dir_add_name expres=success owner=user
+ mknod perm=dir_add_name expres=fail owner=user err=EACCES

## SYSCALL:	mknodat()
## PURPOSE:
## Verify audit of attempts to create new nodes relative to a directory
## file descriptor. See above for more details. 
+ mknodat perm=dir_add_name at=1 expres=success owner=user
+ mknodat perm=dir_add_name at=1 expres=fail owner=user err=EACCES

## SYSCALL:     mount()
## PURPOSE:
## Verify audit of attempts to mount a filesystem.  The test cases below try to
## mount a filesystem at a mount point which may or may not be accessible to
## the test process executing the mount() syscall.  The test procedure is as
## follows:
## 1.  Create a new directory which will be the mount point.
## 2a. If expres=success, execute the test process as the directory owner and
##     attempt to mount the filesystem, verify the result
## 2b. If expres=fail, execute the test process as another user and
##     attempt to mount the filesystem, verify the result
## 3.  Check the audit log for the correct syscall result
+ mount perm=mount_dir expres=success owner=user
+ mount perm=mount_dir expres=fail owner=user err=EPERM

## SYSCALL:	open()
## PURPOSE:
## Verify audit of attempts to open or create new files in the filesystem.
## There are three types of testcases in this set of tests.  The first, using the
## 'perm=dir_add_name' variable, tries to create a new file in a directory which
## may or may not be accessible to the test process executing the open()
## syscall.  The second, using the 'perm=file_read' variable, tries to open a
## file for reading for which the test process may or may not have read
## permission.  The third, using the 'perm=file_write' variable, tries to open a
## file for writing for which the test process may or may not have write
## permission.  The test procedure is as follows:
## 1a. If perm=dir_add_name, create a new directory and make it only
##     accessible to the directory owner.
## 1b. If perm=file_read, create a file which is only read-accessible to the
##     file owner.
## 1c. If perm=file_write, create a file which is only write-accessible to the
##     file owner.
## 2a. If expres=success, execute the test process as the directory or file
##     owner and attempt the open() syscall using the value of flag to
##     determine whether to create a new file or open an existing file for read
##     or write; verify the result.
## 2b. If expres=fail, execute the test process as another user and
##     attempt the open() syscall using the value of flag to determine whether
##     to create a new file or open an existing file for read or write; verify
##     the result.
## 3.  Check the audit log for the correct syscall result
+ open perm=dir_add_name flag=create expres=success owner=user
+ open perm=dir_add_name flag=create expres=fail owner=user err=EACCES
+ open perm=file_read flag=read expres=success owner=user
+ open perm=file_read flag=read expres=fail owner=user err=EACCES
+ open perm=file_write flag=write expres=success owner=user
+ open perm=file_write flag=write expres=fail owner=user err=EACCES

## SYSCALL:	openat()
## PURPOSE:
## Verify audit of attempts to open or create new files relative to a directory
## file descriptor. See above for more details.
+ openat perm=dir_add_name at=1 flag=create expres=success owner=user
+ openat perm=dir_add_name at=1 flag=create expres=fail owner=user err=EACCES
+ openat perm=file_read at=1 flag=read expres=success owner=user
+ openat perm=file_read at=1 flag=read expres=fail owner=user err=EACCES
+ openat perm=file_write at=1 flag=write expres=success owner=user
+ openat perm=file_write at=1 flag=write expres=fail owner=user err=EACCES

## SYSCALL:	readlink()
## PURPOSE:
## Verify audit of attempts to read symbolic links in the filesystem.  The test
## cases below try to read a symbolic link for which the user may or may not
## have appropriate permissions.  The test procedure is as follows:
## 1.  Create a new test file which is accessible to all users.
## 2.  Create a new symbolic link to the test file which is only accessible
##     to the symlink owner.
## 3a. If expres=success, execute the test process as the symlink owner and
##     attempt to read the symlink, verify the result
## 3b. If expres=fail, execute the test process as another user and
##     attempt to read the symlink, verify the result
## 4.  Check the audit log for the correct syscall result
+ readlink perm=symlink_read expres=success owner=user
+ readlink perm=symlink_read expres=fail owner=user err=EACCES

## SYSCALL:	readlinkat()
## PURPOSE:
## Verify audit of attempts to read symbolic links relative to a directory
## file descriptor. See above for more details.
+ readlinkat perm=symlink_read at=1 expres=success owner=user
+ readlinkat perm=symlink_read at=1 expres=fail owner=user err=EACCES

## SYSCALL:	rename()
## PURPOSE:
## Verify audit of attempts to change the name or location of a file in the
## filesystem.  There are three types of testcases in this set of tests.  The
## first, using the 'perm=dir_remove_name,which=old' variables, creates the
## original file in a parent directory which may or may not be accessible to the
## test process and tries to move this file into a new directory.  The second
## test, using the 'perm=dir_add_name' variable, creates a new parent directory
## which may or may not be accessible to the test process and tries to move the
## original file into this new directory.  The third test, using the
## 'perm=dir_remove_name,which=new' variables, creates a parent directory which
## may or may not be accessible to the test process and tries to rename a file
## to the name of an existing file in that directory.  The test procedure is as
## follows:
##  1.  Create a new parent directory for the original object. If
##      perm=dir_remove_name,which=old then make it only accessible to the
##	directory owner.
##  2.  Create the original object.
##  3.  Create a new parent directory for the new location. If perm=dir_add_name
##      or perm=dir_remove_name,which=new then make it only accessible to the
##      directory owner.
##  4.  If perm=dir_remove_name,which=new then create a file at the new location.
##  5a. If expres=success, execute the test process as the directory owner and
## 	attempt the rename() syscall, verify the result
##  5b. If expres=fail, execute the test process as another user and attempt the
##      rename() syscall, verify the result
##  6.  Check the audit log for the correct syscall result
+ rename perm=dir_remove_name entry=file which=old expres=success owner=user \
  tag=rename__dir_remove_name_old_success_owner
+ rename perm=dir_remove_name entry=file which=old expres=fail owner=user \
  err=EACCES tag=rename__dir_remove_name_old_fail_owner
+ rename perm=dir_add_name which=new expres=success owner=user
+ rename perm=dir_add_name which=new expres=fail owner=user err=EACCES
+ rename perm=dir_remove_name entry=file which=new expres=success owner=user \
  tag=rename__dir_remove_name_new_success_owner
+ rename perm=dir_remove_name entry=file which=new expres=fail owner=user \
  err=EACCES tag=rename__dir_remove_name_new_fail_owner

## SYSCALL:	renameat()
## PURPOSE:
## Verify audit of attempts to change the name or location of a file relative to
## a directory file descriptor. See above for more details.
+ renameat perm=dir_remove_name at=1 entry=file which=old expres=success owner=user \
  tag=renameat__dir_remove_name_old_success_owner
+ renameat perm=dir_remove_name at=1 entry=file which=old expres=fail owner=user \
  err=EACCES tag=renameat__dir_remove_name_old_fail_owner
+ renameat perm=dir_add_name at=1 which=new expres=success owner=user
+ renameat perm=dir_add_name at=1 which=new expres=fail owner=user err=EACCES
+ renameat perm=dir_remove_name at=1 entry=file which=new expres=success owner=user \
  tag=renameat__dir_remove_name_new_success_owner
+ renameat perm=dir_remove_name at=1 entry=file which=new expres=fail owner=user \
  err=EACCES tag=renameat__dir_remove_name_new_fail_owner

## SYSCALL:     rmdir()
## PURPOSE:
## Verify audit of attempts to an remove empty directory from the filesystem.
## The testcases below try to remove a sub-directory from a directory which may
## or may not be accessible to the test process.  The test procedure is as
## follows:
## 1.  Create a new parent directory which is only accessible to the directory
##     owner.
## 2.  Create a new sub-directory in the parent directory.
## 3a. If expres=success, execute the test process as the directory owner and
##     attempt to remove the sub-directory, verify the result
## 3b. If expres=fail, execute the test process as another user and
##     attempt to remove the sub-directory, verify the result
## 4.  Check the audit log for the correct syscall result
+ rmdir perm=dir_remove_name entry=dir expres=success owner=user
+ rmdir perm=dir_remove_name entry=dir expres=fail owner=user err=EACCES

## SYSCALL:	swapon()
## PURPOSE:
## Verify audit of attempts to set the swap area. The testcases below try to set
## the swap area as a privileged or unprivileged user.  The test procedure is
## as follows:
## 1.  Create a new file to be used as a swap area.
## 2a. If expres=success, execute the test process as the superuser and
##     attempt to enable the swap file, verify the result
## 2b. If expres=fail, execute the test process as a regular user and
##     attempt to enable the swap file, verify the result
## 3.  Check the audit log for the correct syscall result
+ swapon perm=file_swap expres=success owner=user
+ swapon perm=file_swap expres=fail owner=user err=EPERM

## SYSCALL:	symlink()
## PURPOSE:
## Verify audit of attempts to create a symbolic link in the filesystem.  The
## testcases below try to create a new symbolic link in a directory for which
## the user may or may not have appropriate permissions.  The test procedure is
## as follows:
## 1.  Create a new destination directory for the symlink which is only
##     accessible to the directory owner.
## 2a. If expres=success, execute the test process as the directory owner and
##     attempt to create a symlink, verify the result
## 2b. If expres=fail, execute the test process as another user and
##     attempt to create a symlink, verify the result
## 3.  Check the audit log for the correct syscall result
+ symlink perm=dir_add_name which=new expres=success owner=user
+ symlink perm=dir_add_name which=new expres=fail owner=user err=EACCES

## SYSCALL:	symlinkat()
## PURPOSE:
## Verify audit of attempts to create a symbolic link relative to a directory
## file descriptor. See above for more details.
+ symlinkat perm=dir_add_name at=1 which=new expres=success owner=user
+ symlinkat perm=dir_add_name at=1 which=new expres=fail owner=user err=EACCES

## SYSCALL:     truncate(), truncate64()
## PURPOSE:
## Verify audit of attempts to truncate a file to a specified length.  The test
## cases below try to truncate a file which may or may not be writeable by the
## test process executing the truncate() syscall.  The test procedure is as
## follows:
## 1.  Create a file which is only write-accessible to the file owner.
## 2a. If expres=success, execute the test process as the file owner and
##     attempt to truncate the file, verify the result
## 2b. If expres=fail, execute the test process as another user and
##     attempt to truncate the file, verify the result
## 3.  Check the audit log for the correct syscall result
+ truncate perm=file_write expres=success owner=user
+ truncate perm=file_write expres=fail owner=user err=EACCES
if [[ $MODE == 32 ]]; then
+ truncate64 perm=file_write expres=success owner=user
+ truncate64 perm=file_write expres=fail owner=user err=EACCES
fi

## SYSCALL:	unlink()
## PURPOSE:
## Verify audit of attempts to remove a file in the filesystem.  The testcases
## below try to remove a file from a directory for which the user may or may not
## have appropriate permissions.  The test procedure is as follows:
## 1.  Create a new parent directory which is only accessible to the directory
##     owner.
## 2.  Create a new file in the parent directory.
## 3a. If expres=success, execute the test process as the directory owner and
##     attempt to remove the file, verify the result
## 3b. If expres=fail, execute the test process as another user and
##     attempt to remove the file, verify the result
## 4.  Check the audit log for the correct syscall result
+ unlink perm=dir_remove_name entry=file expres=success owner=user
+ unlink perm=dir_remove_name entry=file expres=fail owner=user err=EACCES

## SYSCALL:	unlinkat()
## PURPOSE:
## Verify audit of attempts to remove a file relative to a directory file
## descriptor. See above for more details.
+ unlinkat perm=dir_remove_name at=1 entry=file expres=success owner=user
+ unlinkat perm=dir_remove_name at=1 entry=file expres=fail owner=user err=EACCES

## SYSCALL:	uselib()
## PURPOSE:
## Verify audit of attempts to load shared library.  The testcases below try to
## load a library for which the user may or may not have appropriate
## permissions.
## NOTE:
## The kernel only accepts obsolete formats, so the true success case is
## difficult to reproduce. Permission checks happen before the format checks, so
## verifying ENOEXEC is sufficient to demonstrate DAC/MAC success.
## The test procedure is as follows:
## 1.  Create a dummy shared library which is only accessible to the library
##     owner.
## 2a. If expres=success, execute the test process as the directory owner and
##     attempt to load the library, verify the result
## 2b. If expres=fail, execute the test process as another user and
##     attempt to load the library, verify the result
##  3. Check the audit log for the correct syscall result
if [[ $HOSTTYPE != x86_64 ]]; then
+ uselib perm=file_exec expres=fail owner=user err=ENOEXEC \
  tag=uselib__file_exec_success_user
+ uselib perm=file_exec expres=fail owner=user err=EACCES
fi

## SYSCALL:	utime(), utimes()
## PURPOSE:
## Verify audit of attempts to change access and/or modification times of an
## inode.  The testcases below try to change the timestamps to the current time
## for a file which may or may not be write accessible to the test process.
## The test procedure is as follows:
## 1.  Create a new file which is only write accessible to the file owner.
## 2a. If expres=success, execute the test process as the file owner and
##     attempt to change the file's timestamps; verify the result
## 2b. If expres=fail, execute the test process as another user and
##     attempt to change the file's timestamps; verify the result
## 3.  Check the audit log for the correct syscall result
if [[ $HOSTTYPE != ia64 ]]; then
+ utime perm=file_write expres=success owner=user
+ utime perm=file_write expres=fail owner=user err=EACCES
fi
+ utimes perm=file_write expres=success owner=user
+ utimes perm=file_write expres=fail owner=user err=EACCES

##
## IPC syscalls
##

## Note: When testing the ipc() syscall, the 'op' variable determines the tested
## syscall operation.

## SYSCALL:     msgctl(), ipc()
## PURPOSE:
## Verify audit of attempts to perform message control operations.  There are
## two types of testcases in this set of tests. The first, using the
## 'perm=msg_id_remove' variable, tries to remove a message queue that may or
## may not be owned by the test process.  The second, using the
## 'perm=msg_id_set' variable, tries to set the msg_perm.uid for a message queue
## that may or may not be owned by the test process.  The test procedure is as
## follows:
## 1.  Create a message queue.
## 2a. If expres=success, execute the test process as the message queue
##     owner and attempt the syscall using the value of flag to determine
##     the control operation; verify the result.
## 2b. If expres=fail, execute the test process as another user and attempt the
##     syscall using the value of flag to determine the control operation;
##     verify the result.
## 3.  Check the audit log for the correct syscall result
if [[ $MODE == 64 ]]; then
+ msgctl perm=msg_id_remove expres=success owner=user
+ msgctl perm=msg_id_remove expres=fail owner=user err=EPERM
+ msgctl perm=msg_id_set expres=success owner=user
+ msgctl perm=msg_id_set expres=fail owner=user err=EPERM
else
+ ipc op=msgctl perm=msg_id_remove expres=success owner=user
+ ipc op=msgctl perm=msg_id_remove expres=fail owner=user err=EPERM
+ ipc op=msgctl perm=msg_id_set expres=success owner=user
+ ipc op=msgctl perm=msg_id_set expres=fail owner=user err=EPERM
fi

## SYSCALL:     msgget(), ipc()
## PURPOSE:
## Verify audit of attempts to get a message queue identifier.  There are two
## types of testcases in this set of tests. The first, using the
## 'perm=msg_key_read' variable, tries to open a message queue for reading which
## may or may not be read-accessible to the test process.  The second, using the
## 'perm=msg_key_write' variable, tries to open a message queue for writing
## which may or may not be write-accessible to the test process.  The test
## procedure is as follows:
## 1a. If perm=msg_key_read, create a message queue which is only
##     read-accessible to the message queue owner.
## 1b. If perm=msg_key_write, create a message queue which is only
##     write-accessible to the message queue owner.
## 2a. If expres=success, execute the test process as the message queue
##     owner and attempt the syscall using the value of flag to determine
##     whether to open the message queue for read or write; verify the result.
## 2b. If expres=fail, execute the test process as another user and attempt the
##     syscall using the value of flag to determine whether to open the message
##     queue for read or write; verify the result.
## 3.  Check the audit log for the correct syscall result
if [[ $MODE == 64 ]]; then
+ msgget perm=msg_key_read expres=success owner=user
+ msgget perm=msg_key_read expres=fail owner=user err=EACCES
+ msgget perm=msg_key_write expres=success owner=user
+ msgget perm=msg_key_write expres=fail owner=user err=EACCES
else
+ ipc op=msgget perm=msg_key_read expres=success owner=user
+ ipc op=msgget perm=msg_key_read expres=fail owner=user err=EACCES
+ ipc op=msgget perm=msg_key_write expres=success owner=user
+ ipc op=msgget perm=msg_key_write expres=fail owner=user err=EACCES
fi

## SYSCALL:     msgrcv(), ipc()
## PURPOSE:
## Verify audit of attempts to receive messages from a message queue.  The test
## cases below try to receive a message from a message queue which may or may
## not be accessible to the test process.  The test procedure is as follows:
## 1.  Create a message queue which is only read-accessible to the message queue
##     owner.
## 2a. If expres=success, execute the test process as the message queue
##     owner and attempt to receive a message, verify the result
## 2b. If expres=fail, execute the test process as another user and attempt to
##     receive a message, verify the result
## 3.  Check the audit log for the correct syscall result
if [[ $MODE == 64 ]]; then
+ msgrcv perm=msg_id_recv expres=success owner=user
+ msgrcv perm=msg_id_recv expres=fail owner=user err=EACCES
else
+ ipc op=msgrcv perm=msg_id_recv expres=success owner=user
+ ipc op=msgrcv perm=msg_id_recv expres=fail owner=user err=EACCES
fi

## SYSCALL:     msgsnd(), ipc()
## PURPOSE:
## Verify audit of attempts to send messages to a message queue.  The test
## cases below try to send a message to a message queue which may or may
## not be accessible to the test process.  The test procedure is as follows:
## 1.  Create a message queue which is only write-accessible to the message
##     queue owner.
## 2a. If expres=success, execute the test process as the message queue
##     owner and attempt to send a message, verify the result
## 2b. If expres=fail, execute the test process as another user and attempt to
##     send a message, verify the result
## 3.  Check the audit log for the correct syscall result
if [[ $MODE == 64 ]]; then
+ msgsnd perm=msg_id_send msg="this is a test" expres=success owner=user \
  testfunc=test_dac_msg_send
+ msgsnd perm=msg_id_send msg="this is a test" expres=fail owner=user \
  err=EACCES testfunc=test_dac_msg_send
else
+ ipc op=msgsnd perm=msg_id_send msg="this is a test" expres=success owner=user \
  testfunc=test_dac_msg_send
+ ipc op=msgsnd perm=msg_id_send msg="this is a test" expres=fail owner=user \
  err=EACCES testfunc=test_dac_msg_send
fi

## SYSCALL:     semctl(), ipc()
## PURPOSE:
## Verify audit of attempts to perform semaphore control operations.  There are
## two types of testcases in this set of tests. The first, using the
## 'perm=sem_id_remove' variable, tries to remove a semaphore set that may or
## may not be owned by the test process.  The second, using the
## 'perm=sem_id_set' variable, tries to set the sem_perm.uid for a semaphore set
## that may or may not be owned by the test process.  The test procedure is as
## follows:
## 1.  Create a semaphore set.
## 2a. If expres=success, execute the test process as the semaphore set
##     owner and attempt the syscall using the value of flag to determine
##     the control operation; verify the result.
## 2b. If expres=fail, execute the test process as another user and attempt the
##     syscall using the value of flag to determine the control operation;
##     verify the result.
## 3.  Check the audit log for the correct syscall result
if [[ $MODE == 64 ]]; then
+ semctl perm=sem_id_remove expres=success owner=user
+ semctl perm=sem_id_remove expres=fail owner=user err=EPERM
+ semctl perm=sem_id_set expres=success owner=user
+ semctl perm=sem_id_set expres=fail owner=user err=EPERM
else
+ ipc op=semctl perm=sem_id_remove expres=success owner=user
+ ipc op=semctl perm=sem_id_remove expres=fail owner=user err=EPERM
+ ipc op=semctl perm=sem_id_set expres=success owner=user
+ ipc op=semctl perm=sem_id_set expres=fail owner=user err=EPERM
fi

## SYSCALL:     semget(), ipc()
## PURPOSE:
## Verify audit of attempts to get a semaphore set identifier.  There are two
## types of testcases in this set of tests. The first, using the
## 'perm=sem_key_read' variable, tries to open a semaphore set for read
## operations which may or may not be read-accessible to the test process.  The
## second, using the 'perm=sem_key_write' variable, tries to open a semaphore
## set for write operations which may or may not be write-accessible to the test
## process.  The test procedure is as follows:
## 1a. If perm=sem_key_read, create a semaphore set which is only
##     read-accessible to the semaphore set owner.
## 1b. If perm=sem_key_write, create a semaphore set which is only
##     write-accessible to the semaphore set owner.
## 2a. If expres=success, execute the test process as the semaphore set
##     owner and attempt the syscall using the value of flag to determine
##     whether to open the semaphore set for read or write; verify the result.
## 2b. If expres=fail, execute the test process as another user and attempt the
##     syscall using the value of flag to determine whether to open the
##     semaphore set for read or write; verify the result.
## 3.  Check the audit log for the correct syscall result
if [[ $MODE == 64 ]]; then
+ semget perm=sem_key_read expres=success owner=user
+ semget perm=sem_key_read expres=fail owner=user err=EACCES
+ semget perm=sem_key_write expres=success owner=user
+ semget perm=sem_key_write expres=fail owner=user err=EACCES
else
+ ipc op=semget perm=sem_key_read expres=success owner=user
+ ipc op=semget perm=sem_key_read expres=fail owner=user err=EACCES
+ ipc op=semget perm=sem_key_write expres=success owner=user
+ ipc op=semget perm=sem_key_write expres=fail owner=user err=EACCES
fi

## SYSCALL:     semop(), ipc()
## PURPOSE:
## Verify audit of attempts to perform semaphore operations.  The test
## cases below try to perform a read operation on a semaphore in a set which may
## or may not be accessible to the test process.  The test procedure is as
## follows:
## 1.  Create a semaphore set which is only read-accessible to the semaphore set
##     owner.
## 2a. If expres=success, execute the test process as the semaphore set
##     owner and attempt a read operation, verify the result
## 2b. If expres=fail, execute the test process as another user and attempt a
##     read operation, verify the result
## 3.  Check the audit log for the correct syscall result
if [[ $MODE == 64 ]]; then
+ semop perm=sem_id_read expres=success owner=user
+ semop perm=sem_id_read expres=fail owner=user err=EACCES
else
+ ipc op=semop perm=sem_id_read expres=success owner=user
+ ipc op=semop perm=sem_id_read expres=fail owner=user err=EACCES
fi

## SYSCALL:     semtimedop(), ipc()
## PURPOSE:
## Verify audit of attempts to perform semaphore operations.  The test
## cases below try to perform a write operation on a semaphore in a set which
## may or may not be accessible to the test process.  The test procedure is as
## follows:
## 1.  Create a semaphore set which is only write-accessible to the semaphore
##     set owner.
## 2a. If expres=success, execute the test process as the semaphore set
##     owner and attempt a write operation, verify the result
## 2b. If expres=fail, execute the test process as another user and attempt a
##     write operation, verify the result
## 3.  Check the audit log for the correct syscall result
if [[ $MODE == 64 ]]; then
+ semtimedop perm=sem_id_write expres=success owner=user
+ semtimedop perm=sem_id_write expres=fail owner=user err=EACCES
else
+ ipc op=semtimedop perm=sem_id_write expres=success owner=user
+ ipc op=semtimedop perm=sem_id_write expres=fail owner=user err=EACCES
fi

## SYSCALL:     shmat(), ipc()
## PURPOSE:
## Verify audit of attempts to perform shared memory operations.  The test
## cases below try to perform shared memory operations on a shared memory
## segment which may or may not be accessible to the test process.  The test
## procedure is as follows:
## 1a. If perm=shm_key_read, create a shared memory segment which is only
##     read-accessible to the shared memory segment owner.
## 1b. If perm=shm_key_write, create a shared memory segment which is only
##     write-accessible to the shared memory segment owner.
## 2a. If expres=success, execute the test process as the shared memory segment
##     owner and attempt the syscall using the value of perm to determine
##     whether to perform a read or write operation; verify the result
## 2b. If expres=fail, execute the test process as another user and attempt the
##     syscall using the value of perm to determine whether to perform a read or
##     write operation; verify the result
## 3.  Check the audit log for the correct syscall result
if [[ $MODE == 64 ]]; then
+ shmat perm=shm_id_read expres=success owner=user
+ shmat perm=shm_id_read expres=fail owner=user err=EACCES
+ shmat perm=shm_id_write expres=success owner=user
+ shmat perm=shm_id_write expres=fail owner=user err=EACCES
else
+ ipc op=shmat perm=shm_id_read expres=success owner=user augrokfunc=augrok_no_exit
+ ipc op=shmat perm=shm_id_read expres=fail owner=user err=EACCES
+ ipc op=shmat perm=shm_id_write expres=success owner=user augrokfunc=augrok_no_exit
+ ipc op=shmat perm=shm_id_write expres=fail owner=user err=EACCES
fi

## SYSCALL:     shmctl(), ipc()
## PURPOSE:
## Verify audit of attempts to perform shared memory control operations.  There
## are two types of testcases in this set of tests. The first, using the
## 'perm=shm_id_remove' variable, tries to remove a shared memory segment that
## may or may not be owned by the test process.  The second, using the
## 'perm=shm_id_set' variable, tries to set the shm_perm.uid for a shared memory
## segment that may or may not be owned by the test process.  The test procedure
## is as follows:
## 1.  Create a shared memory segment.
## 2a. If expres=success, execute the test process as the shared memory segment
##     owner and attempt the syscall using the value of flag to determine
##     the control operation; verify the result.
## 2b. If expres=fail, execute the test process as another user and attempt the
##     syscall using the value of flag to determine the control operation;
##     verify the result.
## 3.  Check the audit log for the correct syscall result
if [[ $MODE == 64 ]]; then
+ shmctl perm=shm_id_remove expres=success owner=user
+ shmctl perm=shm_id_remove expres=fail owner=user err=EPERM
+ shmctl perm=shm_id_set expres=success owner=user
+ shmctl perm=shm_id_set expres=fail owner=user err=EPERM
else
+ ipc op=shmctl perm=shm_id_remove expres=success owner=user
+ ipc op=shmctl perm=shm_id_remove expres=fail owner=user err=EPERM
+ ipc op=shmctl perm=shm_id_set expres=success owner=user
+ ipc op=shmctl perm=shm_id_set expres=fail owner=user err=EPERM
fi

## SYSCALL:     shmget(), ipc()
## PURPOSE:
## Verify audit of attempts to get a shared memory id.  There are two types of
## testcases in this set of tests. The first, using the 'perm=shm_key_read'
## variable, tries to open a shared memory segment for read operations which may
## or may not be read-accessible to the test process.  The second, using the
## 'perm=shm_key_write' variable, tries to open a shared memory segment for
## write operations which may or may not be write-accessible to the test
## process.  The test procedure is as follows:
## 1a. If perm=shm_key_read, create a shared memory segment which is only
##     read-accessible to the shared memory segment owner.
## 1b. If perm=shm_key_write, create a shared memory segment which is only
##     write-accessible to the shared memory segment owner.
## 2a. If expres=success, execute the test process as the shared memory segment
##     owner and attempt the syscall using the value of flag to determine
##     whether to request the shared memory segment for read or write; verify
##     the result.
## 2b. If expres=fail, execute the test process as another user and attempt the
##     syscall using the value of flag to determine whether to request the
##     shared memory segment for read or write; verify the result.
## 3.  Check the audit log for the correct syscall result
if [[ $MODE == 64 ]]; then
+ shmget perm=shm_key_read expres=success owner=user
+ shmget perm=shm_key_read expres=fail owner=user err=EACCES
+ shmget perm=shm_key_write expres=success owner=user
+ shmget perm=shm_key_write expres=fail owner=user err=EACCES
else
+ ipc op=shmget perm=shm_key_read expres=success owner=user
+ ipc op=shmget perm=shm_key_read expres=fail owner=user err=EACCES
+ ipc op=shmget perm=shm_key_write expres=success owner=user
+ ipc op=shmget perm=shm_key_write expres=fail owner=user err=EACCES
fi

##
## XATTR syscalls
##

## SYSCALL:	removexattr(), fremovexattr(), lremovexattr()
## PURPOSE:
## Verify audit of attempts to remove an extended attribute.  The testcases
## below try to remove an extended attribute on a file which may or may not be
## accessible to the test process.  The test procedure is as follows:
## 1.  Create a file which is only write-accessible to the file owner.
## 2a. If expres=success, execute the test process as the file owner and
##     attempt to remove an extended attribute, verify the result
## 2b. If expres=fail, execute the test process as another user and
##     attempt to remove an extended attribute, verify the result
## 3.  Check the audit log for the correct syscall result
+ fremovexattr perm=xattr_remove flag=user.mime_type expres=success owner=user
+ fremovexattr perm=xattr_remove flag=user.mime_type expres=fail owner=user err=EACCES
+ lremovexattr perm=xattr_remove flag=user.mime_type expres=success owner=user
+ lremovexattr perm=xattr_remove flag=user.mime_type expres=fail owner=user err=EACCES
+ removexattr perm=xattr_remove flag=user.mime_type expres=success owner=user
+ removexattr perm=xattr_remove flag=user.mime_type expres=fail owner=user err=EACCES

## SYSCALL:	setxattr(), fsetxattr(), lsetxattr()
## PURPOSE:
## Verify audit of attempts to set an extended attribute.  The testcases
## below try to set an extended attribute on a file which may or may not be
## accessible to the test process.  The test procedure is as follows:
## 1.  Create a file which is only write-accessible to the file owner.
## 2a. If expres=success, execute the test process as the file owner and
##     attempt to set an extended attribute, verify the result
## 2b. If expres=fail, execute the test process as another user and
##     attempt to set an extended attribute, verify the result
## 3.  Check the audit log for the correct syscall result
+ fsetxattr perm=xattr_set flag=user.mime_type expres=success owner=user \
  testfunc=test_dac_setxattr
+ fsetxattr perm=xattr_set flag=user.mime_type expres=fail owner=user err=EACCES \
  testfunc=test_dac_setxattr
+ lsetxattr perm=xattr_set flag=user.mime_type expres=success owner=user \
  testfunc=test_dac_setxattr
+ lsetxattr perm=xattr_set flag=user.mime_type expres=fail owner=user err=EACCES \
  testfunc=test_dac_setxattr
+ setxattr perm=xattr_set flag=user.mime_type expres=success owner=user \
  testfunc=test_dac_setxattr
+ setxattr perm=xattr_set flag=user.mime_type expres=fail owner=user err=EACCES \
  testfunc=test_dac_setxattr
