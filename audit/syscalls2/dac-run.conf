#!/bin/bash
# =============================================================================
# (c) Copyright Hewlett-Packard Development Company, L.P., 2007
#
#   This program is free software;  you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY;  without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
#   the GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program;  if not, write to the Free Software
#   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
# =============================================================================

function test_dac_default {
    # use $tag instead of $expres to work around the cases
    # where a success is an expected failure.
    if [[ $tag == *success* ]]; then
	read testres exitval pid \
	    <<<"$(do_$syscall $op $dirname $source $target $flag)"
    else
	# use single quotes so $$ doesn't expand early
	read uid euid suid fsuid gid egid sgid fsgid \
	    <<<"$(/bin/su - $TEST_USER -c 'ps --no-headers -p $$ -o uid,euid,suid,fsuid,gid,egid,sgid,fsgid')"
	read testres exitval pid \
	    <<<"$(/bin/su - $TEST_USER -c "$(which do_$syscall) $op $dirname $source $target $flag")"
    fi
}

##
## FS syscalls
##

## SYSCALL:	fchmod()
## PURPOSE:
## Verify audit of attempts to change permissions of a file.  The test cases
## below try to change the permissions of a file which may or may not be
## owned by the user running the test process.  The test procedure is as
## follows:
## 1.  Create a new file.
## 2a. If expres=success, execute the test process as the file owner and
##     attempt to change the file permissions according to the value specified
##     by the 'flag' variable, verify the result
## 2b. If expres=fail, execute the test process as another user and
##     attempt to change the file permissions according to the value specified
##     by the 'flag' variable, verify the result
## 3.  Check the audit log for the correct syscall result
+ fchmod perm=priv_modify flag=777 expres=success owner=user
+ fchmod perm=priv_modify flag=777 expres=fail owner=user err=EPERM

## SYSCALL:	fchmodat()
## PURPOSE:
## Verify audit of attempts to change permissions of a file relative to a
## directory file descriptor. See above for more details.
+ fchmodat perm=priv_modify at=1 flag=777 expres=success owner=user
+ fchmodat perm=priv_modify at=1 flag=777 expres=fail owner=user err=EPERM

## SYSCALL:	fchown()
## PURPOSE:
## Verify audit of attempts to change the ownership of a file.  The test cases
## below try to change the ownership for a file which may or may not be
## owned by the user running the test process.  The test procedure is as
## follows:
## 1.  Create a new file.
## 2a. If expres=success, execute the test process as the file owner and
##     attempt to change the file ownership to the user specified
##     by the 'flag' variable, verify the result
## 2b. If expres=fail, execute the test process as another user and
##     attempt to change the file ownership to the user specified
##     by the 'flag' variable, verify the result
## 3.  Check the audit log for the correct syscall result
+ fchown perm=priv_modify flag=root expres=success owner=user
+ fchown perm=priv_modify flag=root expres=fail owner=user err=EPERM
if [[ $MODE == 32 ]]; then
    + fchown32 perm=priv_modify flag=root expres=success owner=user
    + fchown32 perm=priv_modify flag=root expres=fail owner=user err=EPERM
fi

## SYSCALL:	fchownat()
## PURPOSE:
## Verify audit of attempts to change the ownership of a file relative to a
## directory file descriptor. See above for more details.
+ fchownat perm=priv_modify at=1 flag=root expres=success owner=user
+ fchownat perm=priv_modify at=1 flag=root expres=fail owner=user err=EPERM

## SYSCALL:	linkat()
## PURPOSE:
## Verify audit of attempts to create hard links relative to a directory file
## descriptor.  The test cases below try to create a new hard link in a
## directory for which the user may or may not have appropriate permissions.
## The test procedure is as follows:
## 1.  Create a new source file which is accessible to all users.
## 2.  Create a new destination directory for the hard link which is only
##     accessible to the directory owner.
## 3a. If expres=success, execute the test process as the directory owner and
##     attempt to create a hard link, verify the result
## 3b. If expres=fail, execute the test process another user and
##     attempt to create a hard link, verify the result
## 4.  Check the audit log for the correct syscall result
+ linkat perm=dir_add_name at=1 which=new expres=success owner=user
+ linkat perm=dir_add_name at=1 which=new expres=fail owner=user err=EACCES

## SYSCALL:	mkdirat()
## PURPOSE:
## Verify audit of attempts to create new directories relative to a directory
## file descriptor.  The test cases below try to create a new sub-directory in a
## directory for which the user may or may not have appropriate permissions.
## The test procedure is as follows:
## 1.  Create a new destination directory for the sub-directory which is only
##     accessible to the directory owner.
## 2a. If expres=success, execute the test process as the directory owner and
##     attempt to create a directory, verify the result
## 2b. If expres=fail, execute the test process another user and
##     attempt to create a directory, verify the result
## 3.  Check the audit log for the correct syscall result
+ mkdirat perm=dir_add_name at=1 expres=success owner=user
+ mkdirat perm=dir_add_name at=1 expres=fail owner=user err=EACCES

## SYSCALL:	mknodat()
## PURPOSE:
## Verify audit of attempts to create new nodes relative to a directory
## file descriptor.  The test cases below try to create a new node in a
## directory for which the user may or may not have appropriate permissions.
## The test procedure is as follows:
## 1.  Create a new destination directory for the node which is only
##     accessible to the directory owner.
## 2a. If expres=success, execute the test process as the directory owner and
##     attempt to create a node, verify the result
## 2b. If expres=fail, execute the test process another user and
##     attempt to create a node, verify the result
## 3.  Check the audit log for the correct syscall result
+ mknodat perm=dir_add_name at=1 expres=success owner=user
+ mknodat perm=dir_add_name at=1 expres=fail owner=user err=EACCES

## SYSCALL:	openat()
## PURPOSE:
## Verify audit of attempts to open or create new files relative to a directory
## file descriptor.  There are three types of testcases in this set of tests.
## The first, using the 'perm=dir_add_name' variable, tries to create a new file in
## a directory which may or may not be accessible to the test process executing
## the open() syscall.  The second, using the 'perm=file_read' variable, tries
## to open a file for reading for which the test process may or may not have read
## permission.  The third, using the 'perm=file_write' variable, tries to open a
## file for writing for which the test process may or may not have write
## permission.  The test procedure is as follows:
## 1a. If perm=dir_add_name, create a new directory and make it only
##     accessible to the test owner.
## 1b. If perm=file_read, create a file which is only read-accessible to the
##     file owner.
## 1c. If perm=file_write, create a file which is only write-accessible to the
##     file owner.
## 2a. If expres=success, execute the test process as the directory owner and
##     attempt the openat() syscall using the value of flag to determine whether
##     to create a new file or open an existing file for read or write; verify
##     the result.
## 2b. If expres=fail, execute the test process as another user and
##     attempt the openat() syscall using the value of flag to determine whether
##     to create a new file or open an existing file for read or write; verify
##     the result.
## 3.  Check the audit log for the correct syscall result
+ openat perm=dir_add_name at=1 flag=create expres=success owner=user
+ openat perm=dir_add_name at=1 flag=create expres=fail owner=user err=EACCES
+ openat perm=file_read at=1 flag=read expres=success owner=user
+ openat perm=file_read at=1 flag=read expres=fail owner=user err=EACCES
+ openat perm=file_write at=1 flag=write expres=success owner=user
+ openat perm=file_write at=1 flag=write expres=fail owner=user err=EACCES

## SYSCALL:	readlinkat()
## PURPOSE:
## Verify audit of attempts to read symbolic links relative to a directory
## file descriptor.  The test cases below try to read a symbolic link for
## which the user may or may not have appropriate permissions.  The test
## procedure is as follows:
## 1.  Create a new test file which is accessible to all users.
## 2.  Create a new symbolic link to the test file which is only accessible
##     to the symlink owner.
## 3a. If expres=success, execute the test process as the symlink owner and
##     attempt to read the symlink, verify the result
## 3b. If expres=fail, execute the test process another user and
##     attempt to read the symlink, verify the result
## 4.  Check the audit log for the correct syscall result
+ readlinkat perm=symlink_read at=1 expres=success owner=user
+ readlinkat perm=symlink_read at=1 expres=fail owner=user err=EACCES

## SYSCALL:	renameat()
## PURPOSE:
## Verify audit of attempts to change the name or location of a file relative to
## a directory file descriptor.  There are three types of testcases in this set
## of tests.  The first, using the 'perm=dir_remove_name,which=old' variables,
## creates the original file in a parent directory which may or may not be
## accessible to the test process and tries to move this file into a new directory.
## The second test, using the 'perm=dir_add_name' variable, creates a new parent
## directory which may or may not be accessible to the test process and tries to
## move the original file into this new directory.  The third test, using the
## 'perm=dir_remove_name,which=new' variables, creates a parent directory which
## may or may not be accessible to the test process and tries to rename a file
## to the name of an existing file in that directory.  The test procedure is as
## follows:
##  1.  Create a new parent directory for the original object. If
##      perm=dir_remove_name,which=old then make it only accessible to the
##	directory owner.
##  2.  Create the original object.
##  3.  Create a new parent directory for the new location. If perm=dir_add_name
##      or perm=dir_remove_name,which=new then make it only accessible to the
##      directory owner.
##  4.  If perm=dir_remove_name,which=new then create a file at the new location.
##  5a. If expres=success, execute the test process as the directory owner and
## 	attempt the renameat() syscall, verify the result
##  5b. If expres=fail, execute the test process another user and attempt the
##      renameat() syscall, verify the result
##  6.  Check the audit log for the correct syscall result
+ renameat perm=dir_remove_name at=1 entry=file which=old expres=success owner=user \
  tag=renameat__dir_remove_name_old_success_owner
+ renameat perm=dir_remove_name at=1 entry=file which=old expres=fail owner=user \
  err=EACCES tag=renameat__dir_remove_name_old_fail_owner
+ renameat perm=dir_add_name at=1 which=new expres=success owner=user
+ renameat perm=dir_add_name at=1 which=new expres=fail owner=user err=EACCES
+ renameat perm=dir_remove_name at=1 entry=file which=new expres=success owner=user \
  tag=renameat__dir_remove_name_new_success_owner
+ renameat perm=dir_remove_name at=1 entry=file which=new expres=fail owner=user \
  err=EACCES tag=renameat__dir_remove_name_new_fail_owner

## SYSCALL:	symlinkat()
## PURPOSE:
## Verify audit of attempts to create a symbolic link relative to a directory
## file descriptor.  The testcases below try to create a new symbolic link in a
## directory for which the user may or may not have appropriate permissions.
## The test procedure is as follows:
## 1.  Create a new destination directory for the symlink which is only
##     accessible to the directory owner.
## 2a. If expres=success, execute the test process as the directory owner and
##     attempt to create a symlink, verify the result
## 2b. If expres=fail, execute the test process another user and
##     attempt to create a symlink, verify the result
## 3.  Check the audit log for the correct syscall result
+ symlinkat perm=dir_add_name at=1 which=new expres=success owner=user
+ symlinkat perm=dir_add_name at=1 which=new expres=fail owner=user err=EACCES

## SYSCALL:	unlinkat()
## PURPOSE:
## Verify audit of attempts to remove a file relative to a directory file
## descriptor.  The testcases below try to remove a file from a directory for
## which the user may or may not have appropriate permissions.  The test
## procedure is as follows:
## 1.  Create a new parent directory which is only accessible to the directory
##     owner.
## 2.  Create a new file in the parent directory.
## 3a. If expres=success, execute the test process as the directory owner and
##     attempt to remove the file, verify the result
## 3b. If expres=fail, execute the test process another user and
##     attempt to remove the file, verify the result
## 4.  Check the audit log for the correct syscall result
+ unlinkat perm=dir_remove_name at=1 entry=file expres=success owner=user
+ unlinkat perm=dir_remove_name at=1 entry=file expres=fail owner=user err=EACCES

## SYSCALL:	uselib()
## PURPOSE:
## Verify audit of attempts to load shared library.  The testcases below try to
## load a library for which the user may or may not have appropriate
## permissions.
## NOTE:
## The kernel only accepts obsolete formats, so the true success case is
## difficult to reproduce. Permission checks happen before the format checks, so
## verifying ENOEXEC is sufficient to demonstrate DAC/MAC success.
## The test procedure is as follows:
## 1.  Create a dummy shared library which is only accessible to the library
##     owner.
## 2a. If expres=success, execute the test process as the directory owner and
##     attempt to load the library, verify the result
## 2b. If expres=fail, execute the test process another user and
##     attempt to load the library, verify the result
##  3. Check the audit log for the correct syscall result
if [[ $HOSTTYPE != x86_64 ]]; then
+ uselib perm=file_exec expres=fail owner=user err=ENOEXEC \
  tag=uselib__file_exec_success_user
+ uselib perm=file_exec expres=fail owner=user err=EACCES
fi
