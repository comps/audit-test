#!/bin/bash
# =============================================================================
# (c) Copyright Hewlett-Packard Development Company, L.P., 2007
#
#   This program is free software;  you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY;  without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
#   the GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program;  if not, write to the Free Software
#   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
# =============================================================================

#
# Functions for setting up MLS test objects
# - may use these named parameters:
#   subj: the context in which the test operation will run 
#   obj: desired context for test object
#
# - may set these test operation parameters:
#   flag: test operation flag
#   dirname: for *at syscalls
#   source: for link,symlink,rename syscalls
#   target: test operation target object (required)
#
# - may set these augrok parameters:
#   name: file or mq name
#   opid: test object pid(s)
#   obj: may re-determine for audit record
#

function create_fs_objects_mac {
    declare p=$1 base
    
    # When creating filesystem objects, all objects other than the actual target
    # object (the one we're testing) should be created with $subj context to
    # avoid early failures on other permission checks.
    case $p in

        # changes to files/dirs (tested object is always the source)
        dir_reparent)
	    create_dir base context=$subj
	    create_dir source basedir=$base context=$obj
            target="$base/new"
            name=$source ;;
        file_link)
	    create_dir base context=$subj
	    create_file source basedir=$base context=$obj
            target="$base/new"
            name=$source ;;
        file_rename)
	    create_dir base context=$subj
	    create_file source basedir=$base context=$obj
            target="$base/new"
            name=$source ;;

        # changes to files/dirs (tested object is always the target)
        dir_rmdir)
	    create_dir base context=$subj
	    [[ -n $which ]] && create_dir source basedir=$base context=$subj
	    create_dir target basedir=$base context=$obj
            name=$target ;;
        file_unlink)
	    create_dir base context=$subj
	    [[ -n $which ]] && create_file source basedir=$base context=$subj
	    create_file target basedir=$base context=$obj
            name=$target ;;
        file_read|file_write)
            create_file target context=$obj
            name=$target;;
        file_exec)
            create_exec target context=$obj
            name=$target;;
	file_create)
            create_dir target context=$subj

	    # determine the fscreate context, see comment for
	    # set_fscreate_context() for an explanation
	    setcontext=$(set_fscreate_context $subj $obj /tmp)

	    # setup other test utility args
            [[ -n $which ]] && source=$tmp1 # if new file is a symlink
            target="$target/new"

	    # setup augrok parameters
	    [[ $expres == fail ]] && augrokfunc=augrok_mls_create_fail
	    name=$target
	    obj=$setcontext ;;
        symlink_read)
            create_symlink target context=$obj
            name=$target ;;

        # changes to directory entries
        dir_add_name)
            create_dir base context=$obj
            target="$base/new"

            name="$base/" # audit adds a trailing /
	    inode=$(runcon $subj -- stat -c '%i' $base)
	    if [[ -n $inode ]]; then
		# If the kernel fails to create the object, audit does not
		# update the value for the "name" field, so the inode number is
		# the reliable way to identify a directory.
		augrokfunc=augrok_mls_inode
	    else
		# These tests verify mls permission checks for directory writes.
		# In some scenarios, this means that we can't *read* the
		# directory either and the kernel will stop path resolution
		# before even attempting the operation. Note that this
		# implementation detail means we cannot truly verify a directory
		# write permission failure for some subj/obj combinations, but
		# we can prove that the operation won't succeed.
		augrokfunc=augrok_mls_search_fail
	    fi

	    if [[ -n $which ]]; then
		create_dir base context=$subj
		create_file source basedir=$base context=$subj
	    fi ;;
        dir_remove_name)
            create_dir base context=$obj
            case $entry in
		dir)  create_dir target basedir=$base context=$subj ;;
		file) create_file target basedir=$base context=$subj ;;
            esac

	    # see above comment regarding directory write tests
            name="$base/" # audit adds a trailing /
	    runcon $subj -- ls $base >/dev/null || \
		augrokfunc=augrok_mls_search_fail

            # for syscalls that operate on more than one pathname
            # determine which is the actual test object
            case $which in
                old)
                    source=$target
		    create_dir base context=$subj
		    create_file target basedir=$base context=$subj ;;
                new)
		    create_dir base context=$subj
		    create_file source basedir=$base context=$subj ;;
            esac
            ;;
        mount_dir)
	    create_dir target context=$obj
	    source=none
	    flag=tmpfs
	    name=$target
            ;;
	mount_context|mount_fscontext)
	    declare opt=${p##*_}

	    create_dir target context=$subj
	    source=none
	    flag=tmpfs
	    setcontext="$(set_fscreate_context $subj $obj /tmp)"
	    # mount doesn't like setrans labels
	    setcontext="$opt=\"$(augrok --resolve=obj=$setcontext)\""
	    prepend_cleanup "umount $target"

	    name=$target
	    augrokfunc=augrok_mls_create_fail
	    ;;
	mount_defcontext)
	    declare loop=/dev/loop0

	    create_file source context=$subj
	    dd if=/dev/zero of=$source seek=20M count=0 bs=1 || \
		exit_error "could not make sparse file"
	    mke2fs -F $source || exit_error "could create ext2 filesystem"
	    runcon -l SystemHigh -- do_loop $source $loop  || \
		exit_error "could not setup loop device for mount"
	    source=$loop
	    append_cleanup "runcon -l SystemHigh -- do_loop_clear $loop"

	    create_dir target context=$subj
	    flag=ext2
	    setcontext="$(set_fscreate_context $subj $obj /tmp)"
	    # mount doesn't like setrans labels
	    setcontext="defcontext=\"$(augrok --resolve=obj=$setcontext)\""
	    prepend_cleanup "umount $target"

	    name=$target
	    augrokfunc=augrok_mls_create_fail
	    ;;

        *) exit_error "unknown perm to test: $p" ;;
    esac

    # ensure filesystem object has correct type
    # must be done _before_ handling for *at calls
    # must not be done if the file doesn't exist yet
    [[ $p == file_create ]] || obj=$(get_fsobj_context $name)

    # special handling for *at syscalls
    if [[ -n $at ]]; then
	dirname=$target
	while [[ $dirname == /*/* ]]; do dirname=${dirname%/*}; done
	[[ -n $source ]] && source=${source#/*/}
	target=${target#/*/}
	name=${name#/*/}
    fi

    # augrok setup
    [[ -z $augrokfunc ]] && augrokfunc=augrok_mls_name
}

function create_ipc_objects_mac {
    declare p=$1 type=${1%_*}
    declare msg_type=1

    create_${type} target context=$obj
    flag=${1##*_} # set operation flag

    # special setup for sending/recving messages
    case $p in
	*_send)
	    flag=$msg_type ;;
	*_recv)
	    declare result

	    flag=$msg_type
	    # always use do_msgsnd regardless of whether the syscall is ipc() or
	    # msgrcv() -- it's using a library call, so it works. we have a
	    # do_ipc utility purely because the harness wants to find a
	    # do_$syscall binary.
	    read result foo bar \
		<<<"$(runcon $obj -- do_msgsnd $target $flag 'test message')"
	    [[ $result == 0 ]] || exit_error "could not send initial message" ;;
    esac

    augrokfunc=augrok_mls
}

function create_mq_objects_mac {
    declare p=$1 mq_dir=/dev/mqueue

    if [[ $p == mq_create ]]; then
	create_mq_name target context=$obj

	mkdir $mq_dir ; mount -t mqueue mqueue $mq_dir
	    # determine the fscreate context, see comment for
	    # set_fscreate_context() for an explanation
	    setcontext=$(set_fscreate_context $subj $obj $mq_dir)
	umount $mq_dir ; rmdir $mq_dir

	[[ $expres == fail ]] && augrokfunc=augrok_mls_create_fail
	obj=$setcontext
    else
	create_mq target context=$obj
	# get the real object type
	mkdir $mq_dir ; mount -t mqueue mqueue $mq_dir
	obj=$(get_fsobj_context "$mq_dir/$target")
	runcon $subj -- ls "$mq_dir/$target" || \
	    augrokfunc=augrok_mls_search_fail
	umount $mq_dir ; rmdir $mq_dir
    fi

    # set augrok params first, before we change $target
    [[ -z $augrokfunc ]] && augrokfunc=augrok_mls_name
    name=$target

    # set operation params
    target="/$target"
}

function create_process_objects_mac {
    declare p=$1

    case $p in
        process_*)
            create_process target context=$obj
            opid=$target ;;
        pgrp_*)
            create_pgrp target context=$obj
            opid+=( $(ps --no-headers -C do_dummy_group -o pid | sort -n) ) ;;
        *) exit_error "unknown perm to test: $p" ;;
    esac

    # set test operation flag
    flag=${p##*_}

    augrokfunc=augrok_mls_opid
}

function test_mac_kill_pgrp {
    read testres exitval pid <<<"$(runcon $subj -- do_$syscall $target $flag group)"
}

function test_mac_msg_send {
    read testres exitval pid <<<"$(runcon $subj -- do_$syscall $op $target $flag "$msg")"
}

function test_mac_default {
    read testres exitval pid \
	<<<"$(runcon $subj -- do_$syscall $op $dirname $source $target $flag $setcontext)"
}

function test_set_secattr {
    declare value=$(cat /proc/self/attr/current)

    # use single quotes so $$ doesn't expand early
    read uid euid suid fsuid gid egid sgid fsgid \
	<<<"$(/bin/su - $TEST_USER -c 'ps --no-headers -p $$ -o uid,euid,suid,fsuid,gid,egid,sgid,fsgid')"
    read testres exitval pid \
	<<<"$(/bin/su - $TEST_USER -c "$(which do_$syscall) $target $flag $value")"
}

##
## FS syscalls
##

## SYSCALL:	creat()
## PURPOSE:     verify audit of attempts to create a file
+ creat perm=dir_add_name expres=success mlsop=eq
+ creat perm=dir_add_name expres=fail mlsop=domby err=EACCES
+ creat perm=file_create expres=success mlsop=eq
+ creat perm=file_create expres=fail mlsop=dom err=EACCES

## SYSCALL:	execve()
+ execve perm=file_exec expres=success mlsop=eq
+ execve perm=file_exec expres=success mlsop=dom
+ execve perm=file_exec expres=fail mlsop=domby err=EACCES
+ execve perm=file_exec expres=fail mlsop=incomp err=EACCES

## SYSCALL:	link()
## PURPOSE:     verify audit of attempts to make a new name for a file
+ link perm=dir_add_name which=new expres=success mlsop=eq
+ link perm=dir_add_name which=new expres=fail mlsop=domby err=EACCES
+ link perm=file_link which=old expres=success mlsop=eq
+ link perm=file_link which=old expres=fail mlsop=dom err=EACCES
+ link perm=file_link which=old expres=fail mlsop=domby err=EACCES
+ link perm=file_link which=old expres=fail mlsop=incomp err=EACCES

## SYSCALL:	linkat()
## PURPOSE:
## Verify that the linkat() syscall is subject to the correct MLS constraints
## when creating new hard links in the file system.  There are two types of
## testcases in this set of tests.  The first, using the 'perm=dir_add_name'
## variable, creates a target directory for the link at a specific MLS
## sensitivity label which may or may not be accessible to the subject test
## processes executing the linkat() syscall.  The second test type, using the
## 'perm=file_link' variable, creates a source file for the link at a specific
## MLS sensitivity label which may or may not be accessible to the subject
## test process executing the linkat() syscall.  The test procedure is as
## follows:
##  1. Create a new source file, if perm=file_link then label the source
##     source file such that the MLS relationship between the file and the
##     test processes is defined by the mlsop variable (dom, domby, incomp)
##  2. Create a new destination directory for the hard link, if
##     perm=dir_add_name then label the directory such that the MLS
##     relationship between the directory and the test processes is defined by
##     the mlsop variable (dom, domby, incomp)
##  3. Execute the test process and attempt to create a hard link, verify the
##     result
##  4. Check the audit log for the correct syscall result
## TESTCASE:    create a link in a new dir, mac success
+ linkat perm=dir_add_name at=1 which=new expres=success mlsop=eq
## TESTCASE:    create a link in a new dir, mac failure in the new dir (dom)
+ linkat perm=dir_add_name at=1 which=new expres=fail mlsop=dom err=EACCES
## TESTCASE:    create a link in a new dir, mac failure in the new dir (domby)
+ linkat perm=dir_add_name at=1 which=new expres=fail mlsop=domby err=EACCES
## TESTCASE:    create a link in a new dir, mac failure in the new dir (incomp)
+ linkat perm=dir_add_name at=1 which=new expres=fail mlsop=incomp err=EACCES
## TESTCASE:    create a link in a new dir, mac success
+ linkat perm=file_link at=1 which=old expres=success mlsop=eq
## TESTCASE:    create a link in a new dir, mac failure in the src file (dom)
+ linkat perm=file_link at=1 which=old expres=fail mlsop=dom err=EACCES
## TESTCASE:    create a link in a new dir, mac failure in the src file (domby)
+ linkat perm=file_link at=1 which=old expres=fail mlsop=domby err=EACCES
## TESTCASE:    create a link in a new dir, mac failure in the src file (incomp)
+ linkat perm=file_link at=1 which=old expres=fail mlsop=incomp err=EACCES

## SYSCALL:	mkdir()
## PURPOSE:     verify audit of attempts to create a directory
+ mkdir perm=dir_add_name expres=success mlsop=eq
+ mkdir perm=dir_add_name expres=fail mlsop=dom err=EACCES
+ mkdir perm=dir_add_name expres=fail mlsop=domby err=EACCES
+ mkdir perm=dir_add_name expres=fail mlsop=incomp err=EACCES
+ mkdir perm=file_create expres=success mlsop=eq
+ mkdir perm=file_create expres=fail mlsop=domby err=EACCES

## SYSCALL:     mkdirat()
## PURPOSE:
## Verify that the mkdirat() syscall is subject to the correct MLS constraints
## when creating new directories in the file system.  In each of the testcases
## below a parent directory is created with a specific MLS sensitivity label
## which may or may not be  accessible to the subject test processes executing
## the mkdirat() syscall.  The test procedure is as follows:
##  1. Create a new parent directory and label is such that the MLS
##     relationship between the parent directory and the test process is
##     defined by the mlsop variable (dom, domby, incomp)
##  2. Execute the test process and attempt to create a new directory, verify
##     the result
##  3. Check the audit log for the correct syscall result
## TESTCASE:    create a new directory, mac success
+ mkdirat perm=dir_add_name at=1 expres=success mlsop=eq
## TESTCASE:    create a new directory, mac failure (dom)
+ mkdirat perm=dir_add_name at=1 expres=fail mlsop=dom err=EACCES
## TESTCASE:    create a new directory, mac failure (domby)
+ mkdirat perm=dir_add_name at=1 expres=fail mlsop=domby err=EACCES
## TESTCASE:    create a new directory, mac failure (incomp)
+ mkdirat perm=dir_add_name at=1 expres=fail mlsop=incomp err=EACCES
## TESTCASE:    create a new filesystem directory, mac success
+ mkdirat perm=file_create at=1 expres=success mlsop=eq
## TESTCASE:    create a new filesystem directory, mac failure (dom)
+ mkdirat perm=file_create at=1 expres=fail mlsop=dom err=EACCES
## TESTCASE:    create a new filesystem directory, mac failure (domby)
+ mkdirat perm=file_create at=1 expres=fail mlsop=domby err=EACCES
## TESTCASE:    create a new filesystem directory, mac failure (incomp)
+ mkdirat perm=file_create at=1 expres=fail mlsop=incomp err=EACCES

## SYSCALL:	mknod()
## PURPOSE:     verify audit of attempts to create a special or ordinary file
+ mknod perm=dir_add_name expres=success mlsop=eq
+ mknod perm=dir_add_name expres=fail mlsop=dom err=EACCES
+ mknod perm=file_create expres=success mlsop=eq
+ mknod perm=file_create expres=fail mlsop=incomp err=EACCES

## SYSCALL:	mknodat()
## PURPOSE:
## Verify that the mknodat() syscall is subject to the correct MLS constraints
## when creating new nodes in the file system.  There are two types of
## testcases in this set of tests.  The first, using the 'perm=dir_add_name'
## variable, creates a parent directory with a specific MLS sensitivity label
## which may or may not be accessible to the subject test processes executing
## the mknodat() syscall.  The second test type, using the 'perm=file_create'
## variable, creates a parent directory with the same MLS sensitvity label as
## the test process, but instructs the test process to create a new node with
## a specific MLS sensitvity label which may or may not be allowed by the
## security policy.  The test procedure is as follows:
##  1. Create a new parent directory and if perm=dir_add_name then label the
##     directory such that the MLS relationship between the parent directory
##     and the test process is defined by the mlsop variable (dom, domby,
##     incomp), if perm=file_create then create the parent directory with the
##     same MLS sensitvity label as the test process
##  2. If perm=file_create then call the setfscreatecon() API so that and new
##     file system created object will be created with a MLS sensitivity label
##     such that the MLS relationship between the parent directory and the
##     newly created file system object is defined by the mlsop variable (dom,
##     domby, incomp)
##  3. Execute the test process and attempt to create a new node, verify the
##     result
##  4. Check the audit log for the correct syscall result
## TESTCASE:    create a new filesystem node, mac success
+ mknodat perm=dir_add_name at=1 expres=success mlsop=eq
## TESTCASE:    create a new filesystem node, mac failure (dom)
+ mknodat perm=dir_add_name at=1 expres=fail mlsop=dom err=EACCES
## TESTCASE:    create a new filesystem node, mac failure (domby)
+ mknodat perm=dir_add_name at=1 expres=fail mlsop=domby err=EACCES
## TESTCASE:    create a new filesystem node, mac failure (incomp)
+ mknodat perm=dir_add_name at=1 expres=fail mlsop=incomp err=EACCES
## TESTCASE:    create a new filesystem node, mac success
+ mknodat perm=file_create at=1 expres=success mlsop=eq
## TESTCASE:    create a new filesystem node, mac failure (dom)
+ mknodat perm=file_create at=1 expres=fail mlsop=dom err=EACCES
## TESTCASE:    create a new filesystem node, mac failure (domby)
+ mknodat perm=file_create at=1 expres=fail mlsop=domby err=EACCES
## TESTCASE:    create a new filesystem node, mac failure (incomp)
+ mknodat perm=file_create at=1 expres=fail mlsop=incomp err=EACCES

## SYSCALL:	mount()
+ mount perm=mount_dir expres=success mlsop=eq
+ mount perm=mount_dir expres=fail mlsop=dom err=EACCES
+ mount perm=mount_dir expres=fail mlsop=domby err=EACCES
+ mount perm=mount_dir expres=fail mlsop=incomp err=EACCES

# mount and set the context for the filesystem and all files
# the object is the initial context (s0)
+ mount perm=mount_context expres=success mlsop=eq
+ mount perm=mount_context expres=fail mlsop=dom err=EACCES

# mount and set the filesystem context
# the object is the initial context (s0)
+ mount perm=mount_fscontext expres=success mlsop=eq
+ mount perm=mount_fscontext expres=fail mlsop=dom err=EACCES

# mount and set the default context for unlabeled files
# the object is the initial context (s0)
+ mount perm=mount_defcontext expres=success mlsop=eq
+ mount perm=mount_defcontext expres=fail mlsop=dom err=EACCES

## SYSCALL:	open()
## PURPOSE:     verify audit of attempts to create/open a file
+ open perm=dir_add_name flag=create expres=success mlsop=eq
+ open perm=dir_add_name flag=create expres=fail mlsop=incomp err=EACCES
+ open perm=file_create flag=create expres=success mlsop=eq
+ open perm=file_create flag=create expres=fail mlsop=dom err=EACCES
+ open perm=file_read flag=read expres=success mlsop=eq
+ open perm=file_read flag=read expres=fail mlsop=domby err=EACCES
+ open perm=file_write flag=write expres=success mlsop=eq
+ open perm=file_write flag=write expres=fail mlsop=dom err=EACCES

## SYSCALL:	openat()
## PURPOSE:
## Verify that the openat() syscall is subject to the correct MLS constraints
## when opening new or existing files.  There are four types of testcases in
## this set of tests.  The first, using the 'perm=dir_add_name' variable,
## creates a parent directory for the new file at a specific MLS sensitivity
## label which may or may not be accessible to the subject test processes
## executing the openat() syscall.  The second test type, using the
## 'perm=file_create' variable creates a parent directory for the new file with
## the same MLS sensitivity label as the process executing the openat() syscall
## but instructs the test process to open a new file with a specific MLS
## sensitvity label which may or may not be allowed by the security policy.
## The third test type, using the 'perm=file_read', creates a new file at a
## specific MLS sensitivity label which may or may not be accessible to the
## subject test processes executing the openat() syscall with the read flag.
## The fourth test type, using the 'perm=file_write',  creates a new file at a
## specific MLS sensitivity label which may or may not be accessible to the
## subject test processes executing the openat() syscall with the write flag.
## The test procedure is as follows:
##  1a. If perm=dir_add_name then a parent directory is created and labeled
##      in such a way that the MLS relationship between the parent directory
##      and the test process is defined by the mlsop variable (dom, domby,
##      incomp)
##  1b. If perm=file_create then a parent directory is created and labeled with
##      the same MLS sensitivity label as the test process
##  1c. If perm=file_read then a file is created and labeled in such a way that
##      the MLS relationship between the file and the test process is defined
##      by the mlsop variable (dom, domby, incomp)
##  1d. If perm=file_write then a file is created and labeled in such a way that
##      the MLS relationship between the file and the test process is defined
##      by the mlsop variable (dom, domby, incomp)
##  2.  Execute the test process and attempt the open() syscall, verify the
##      results
##  3.  Check the audit log for the correct syscall result
## TESTCASE:    create a new file, mac success
+ openat perm=dir_add_name at=1 flag=create expres=success mlsop=eq
## TESTCASE:    create a new file, mac failure (dom)
+ openat perm=dir_add_name at=1 flag=create expres=fail mlsop=dom err=EACCES
## TESTCASE:    create a new file, mac failure (domby)
+ openat perm=dir_add_name at=1 flag=create expres=fail mlsop=domby err=EACCES
## TESTCASE:    create a new file, mac failure (incomp)
+ openat perm=dir_add_name at=1 flag=create expres=fail mlsop=incomp err=EACCES
## TESTCASE:    create a new file, mac success
+ openat perm=file_create at=1 flag=create expres=success mlsop=eq
## TESTCASE:    create a new file, mac failure (dom)
+ openat perm=file_create at=1 flag=create expres=fail mlsop=dom err=EACCES
## TESTCASE:    create a new file, mac failure (domby)
+ openat perm=file_create at=1 flag=create expres=fail mlsop=domby err=EACCES
## TESTCASE:    create a new file, mac failure (incomp)
+ openat perm=file_create at=1 flag=create expres=fail mlsop=incomp err=EACCES
## TESTCASE:    open an existing file for reading, mac success
+ openat perm=file_read at=1 flag=read expres=success mlsop=eq
## TESTCASE:    open an existing file for reading, mac success
+ openat perm=file_read at=1 flag=read expres=success mlsop=dom
## TESTCASE:    open an existing file for reading, mac failure (domby)
+ openat perm=file_read at=1 flag=read expres=fail mlsop=domby err=EACCES
## TESTCASE:    open an existing file for reading, mac failure (incomp)
+ openat perm=file_read at=1 flag=read expres=fail mlsop=incomp err=EACCES
## TESTCASE:    open an existing file for writing, mac success
+ openat perm=file_write at=1 flag=write expres=success mlsop=eq
## TESTCASE:    open an existing file for writing, mac failure (dom)
+ openat perm=file_write at=1 flag=write expres=fail mlsop=dom err=EACCES
## TESTCASE:    open an existing file for writing, mac failure (domby)
+ openat perm=file_write at=1 flag=write expres=fail mlsop=domby err=EACCES
## TESTCASE:    open an existing file for writing, mac failure (incomp)
+ openat perm=file_write at=1 flag=write expres=fail mlsop=incomp err=EACCES

## SYSCALL:	readlink()
## PURPOSE:     verify audit of attempts to read the value of a symlink
+ readlink perm=symlink_read expres=success mlsop=eq
+ readlink perm=symlink_read expres=fail mlsop=domby err=EACCES

## SYSCALL:	readlinkat()
## PURPOSE:
## Verify that the readlinkat() syscall is subject to the correct MLS
## constraints when reading symbolic links in the file system.  The test cases
## below try to read a symbolic link which was created with a MLS sensitivity
## label which may or may not be accessible to the subject test processes
## executing the readlinkat() syscall.  The test procedure is as follows:
##  1. Create a test file and a symbolic link to that test file, label the
##     symbolic link in such a  way that the MLS relationship between the file
##     and the test process is defined by the mlsop variable (dom, domby,
##     incomp)
##  2. Execute the test process and attempt the readlinkat() syscall, verify
##     the results
##  3. Check the audit log for the correct syscall result
## TESTCASE:    read a symlink, mac success
+ readlinkat perm=symlink_read at=1 expres=success mlsop=eq
## TESTCASE:    read a symlink, mac success
+ readlinkat perm=symlink_read at=1 expres=success mlsop=dom
## TESTCASE:    read a symlink, mac failure (domby)
+ readlinkat perm=symlink_read at=1 expres=fail mlsop=domby err=EACCES
## TESTCASE:    read a symlink, mac success (incomp)
+ readlinkat perm=symlink_read at=1 expres=fail mlsop=incomp err=EACCES

## SYSCALL:	rename()
## PURPOSE:     verify audit of attempts to change the name/location of a file/directory
+ rename perm=dir_remove_name entry=file which=old expres=success mlsop=eq \
  tag=rename__dir_remove_name_old_success_subj_eq_obj
+ rename perm=dir_remove_name entry=file which=old expres=fail mlsop=dom \
  err=EACCES tag=rename__dir_remove_name_old_fail_subj_dom_obj
+ rename perm=file_rename expres=success mlsop=eq
+ rename perm=file_rename expres=fail mlsop=dom err=EACCES
+ rename perm=file_rename expres=fail mlsop=domby err=EACCES
+ rename perm=file_rename expres=fail mlsop=incomp err=EACCES
+ rename perm=dir_reparent expres=success mlsop=eq
+ rename perm=dir_reparent expres=fail mlsop=dom err=EACCES
+ rename perm=dir_reparent expres=fail mlsop=domby err=EACCES
+ rename perm=dir_reparent expres=fail mlsop=incomp err=EACCES

+ rename perm=dir_add_name which=new expres=success mlsop=eq
+ rename perm=dir_add_name which=new expres=fail mlsop=incomp err=EACCES
+ rename perm=dir_remove_name entry=file which=new expres=success mlsop=eq \
  tag=rename__dir_remove_name_new_success_subj_eq_obj
+ rename perm=dir_remove_name entry=file which=new expres=fail mlsop=domby \
  err=EACCES tag=rename__dir_remove_name_new_fail_subj_domby_obj
+ rename perm=file_unlink which=new expres=success mlsop=eq
+ rename perm=file_unlink which=new expres=fail mlsop=dom err=EACCES
+ rename perm=dir_rmdir which=new expres=success mlsop=eq
+ rename perm=dir_rmdir which=new expres=fail mlsop=domby err=EACCES

## SYSCALL:	renameat()
## PURPOSE:
## Verify that the renameat() syscall is subject to the correct MLS constraints
## when renaming/moving files or directories.  There are seven types of
## testcases in this set of tests.  The first, using the
## 'perm=dir_remove_name,which=old' variables, creates the original file in a
## parent directory with a MLS sensitivity label which may or may not be
## accessible to the test process and tries to move this file into a new
## directory.  The second test, using the 'perm=file_rename' variable, creates
## a new file with a MLS sensitivity label which may or may not be accessible
## to the test process and tries to rename the file.  The third test, using the
## 'perm=dir_reparent' variable, creates the original file with a MLS
## sensitivity label which may or may not be accessible to the test process and
## tries to move the file to a new directory.  The fourth test, using the
## 'perm=dir_add_name' variable, creates a new parent directory with a MLS
## sensitivity label which may or may not be accessible to the test process and
## tries to move the original file into this new directory.  The fifth test,
## using the 'perm=dir_remove_name,which=new' variables, creates a parent
## directory with a MLS sensitivity label which may or may not be accessible to
## the test process and tries to move this file into this new directory.  The
## sixth test, using the 'perm=file_unlink' variable, tries to rename a file to
## another file with a MLS sensitivity label which may or may not be accessible
## to the test process.  The seventh test, using the 'perm=dir_rmdir' variable,
## tries to rename a directory to another directory with a MLS sensitivity label
## which may or may not be accessible to the test process.  The test procedure
## is as follows:
##  1a. If perm=dir_remove_name,which=old then a file is created in a parent
##      directory which is labeled in such a way that the MLS relationship
##      between the parent directory and the test process is defined by the
##      mlsop variable (dom, domby, incomp)
##  1b. If perm=file_rename or dir_reparent then a file is created with a label
##      such that the MLS relationship between the file and the test process is
##      defined by the mlsop variable (dom, domby, incomp)
##  1c. If perm=dir_add_name or perm=dir_remove_name,which=new then a directory
##      is created which is labeled in such a way that the MLS relationship
##      between the directory and the test process is defined by the mlsop
##      variable (dom, domby, incomp)
##  1d. If perm=file_unlink then two files are created, the second is created
##      with a label such that the MLS relationship between the file and the
##      test process is defined by the mlsop variable (dom, domby, incomp)
##  1e. If perm=dir_rmdir then two directories are created, the second is
##      created with a label such that the MLS relationship between the
##      directory and the test process is defined by the mlsop variable (dom,
##      domby, incomp)
##  2.  Exectue the test process and attempt the renameat() syscall, verify the
##      results
##  3.  Check the audit log for the correct syscall result
## TESTCASE:    rename/move a file, mac success
+ renameat perm=dir_remove_name at=1 entry=file which=old expres=success mlsop=eq \
  tag=renameat__dir_remove_name_old_success_subj_eq_obj
## TESTCASE:    rename/move a file, mac failure (dom)
+ renameat perm=dir_remove_name at=1 entry=file which=old expres=fail mlsop=dom \
  err=EACCES tag=renameat__dir_remove_name_old_fail_subj_dom_obj
## TESTCASE:    rename/move a file, mac failure (domby)
+ renameat perm=dir_remove_name at=1 entry=file which=old expres=fail mlsop=domby \
  err=EACCES tag=renameat__dir_remove_name_old_fail_subj_domby_obj
## TESTCASE:    rename/move a file, mac failure (incomp)
+ renameat perm=dir_remove_name at=1 entry=file which=old expres=fail mlsop=incomp \
  err=EACCES tag=renameat__dir_remove_name_old_fail_subj_incomp_obj
## TESTCASE:    rename a file, mac success
+ renameat perm=file_rename at=1 expres=success mlsop=eq
## TESTCASE:    rename a file, mac failure (dom)
+ renameat perm=file_rename at=1 expres=fail mlsop=dom err=EACCES
## TESTCASE:    rename a file, mac failure (domby)
+ renameat perm=file_rename at=1 expres=fail mlsop=domby err=EACCES
## TESTCASE:    rename a file, mac failure (incomp)
+ renameat perm=file_rename at=1 expres=fail mlsop=incomp err=EACCES
## TESTCASE:    rename/move a directory, mac success
+ renameat perm=dir_reparent at=1 expres=success mlsop=eq
## TESTCASE:    rename/move a directory, mac failure (dom)
+ renameat perm=dir_reparent at=1 expres=fail mlsop=dom err=EACCES
## TESTCASE:    rename/move a directory, mac failure (domby)
+ renameat perm=dir_reparent at=1 expres=fail mlsop=domby err=EACCES
## TESTCASE:    rename/move a directory, mac failure (incomp)
+ renameat perm=dir_reparent at=1 expres=fail mlsop=incomp err=EACCES
## TESTCASE:    rename/move a file, mac success
+ renameat perm=dir_add_name at=1 which=new expres=success mlsop=eq
## TESTCASE:    rename/move a file, mac failure (dom)
+ renameat perm=dir_add_name at=1 which=new expres=fail mlsop=dom err=EACCES
## TESTCASE:    rename/move a file, mac failure (domby)
+ renameat perm=dir_add_name at=1 which=new expres=fail mlsop=domby err=EACCES
## TESTCASE:    rename/move a file, mac failure (incomp)
+ renameat perm=dir_add_name at=1 which=new expres=fail mlsop=incomp err=EACCES
## TESTCASE:    rename/move a file, mac success
+ renameat perm=dir_remove_name at=1 entry=file which=new expres=success mlsop=eq \
  tag=renameat__dir_remove_name_new_success_subj_eq_obj
## TESTCASE:    rename/move a file, mac failure (dom)
+ renameat perm=dir_remove_name at=1 entry=file which=new expres=fail mlsop=dom \
  err=EACCES tag=renameat__dir_remove_name_new_fail_subj_dom_obj
## TESTCASE:    rename/move a file, mac failure (domby)
+ renameat perm=dir_remove_name at=1 entry=file which=new expres=fail mlsop=domby \
  err=EACCES tag=renameat__dir_remove_name_new_fail_subj_domby_obj
## TESTCASE:    rename/move a file, mac failure (incomp)
+ renameat perm=dir_remove_name at=1 entry=file which=new expres=fail mlsop=incomp \
  err=EACCES tag=renameat__dir_remove_name_new_fail_subj_incomp_obj
## TESTCASE:    rename a file, mac success
+ renameat perm=file_unlink at=1 which=new expres=success mlsop=eq
## TESTCASE:    rename a file, mac failure (dom)
+ renameat perm=file_unlink at=1 which=new expres=fail mlsop=dom err=EACCES
## TESTCASE:    rename a file, mac failure (domby)
+ renameat perm=file_unlink at=1 which=new expres=fail mlsop=domby err=EACCES
## TESTCASE:    rename a file, mac failure (incomp)
+ renameat perm=file_unlink at=1 which=new expres=fail mlsop=incomp err=EACCES
## TESTCASE:    rename/move a directory, mac success
+ renameat perm=dir_rmdir at=1 which=new expres=success mlsop=eq
## TESTCASE:    rename/move a directory, mac failure (dom)
+ renameat perm=dir_rmdir at=1 which=new expres=fail mlsop=dom err=EACCES
## TESTCASE:    rename/move a directory, mac failure (domby)
+ renameat perm=dir_rmdir at=1 which=new expres=fail mlsop=domby err=EACCES
## TESTCASE:    rename/move a directory, mac failure (incomp)
+ renameat perm=dir_rmdir at=1 which=new expres=fail mlsop=incomp err=EACCES

## SYSCALL:	rmdir()
## PURPOSE:     verify audit of attempts to delete a directory
+ rmdir perm=dir_remove_name entry=dir expres=success mlsop=eq
+ rmdir perm=dir_remove_name entry=dir expres=fail mlsop=domby err=EACCES
+ rmdir perm=dir_rmdir expres=success mlsop=eq
+ rmdir perm=dir_rmdir expres=fail mlsop=dom err=EACCES
+ rmdir perm=dir_rmdir expres=fail mlsop=domby err=EACCES
+ rmdir perm=dir_rmdir expres=fail mlsop=incomp err=EACCES

## SYSCALL:	symlink()
## PURPOSE:     verify audit of attempts to create a symlink
+ symlink perm=dir_add_name which=new expres=success mlsop=eq
+ symlink perm=dir_add_name which=new expres=fail mlsop=dom err=EACCES
+ symlink perm=file_create which=new expres=success mlsop=eq
+ symlink perm=file_create which=new expres=fail mlsop=domby err=EACCES

## SYSCALL:	symlinkat()
## PURPOSE:
## Verify that the symlinkat() syscall is subject to the correct MLS
## constraints when creating new symbolic links in the file system.  There are
## two types of testcases in this set of tests.  The first, using the
## 'perm=dir_add_name' variable, tries to create a symbolic link in a directory
## which has a MLS sensitivity label which may or may not be accessibile to the
## subject test process executing the symlinkat() syscall.  The second test,
## using the 'perm=file_create' variable, tries to create a symbolic link with
## a specific MLS sensitivity label in a directory which may or may not be
## allowed by the MLS sensitvity label of the parent directory.  The test
## procedure is as follows:
##  1a. If perm=dir_add_name then create a directory that is labeled in such a
##      way that the MLS relationship between the directory and the test
##      process is defined by the mlsop variable (dom, domby, incomp)
##  1b. If perm=file_create then create a directory that is labeled with the
##      same MLS sensitivity label as the test process
##  2.  Exectue the test process and attempt the symlinkat() syscall, verify the
##      results
##  3.  Check the audit log for the correct syscall result
## TESTCASE:    create a new symbolic link, mac success
+ symlinkat perm=dir_add_name at=1 which=new expres=success mlsop=eq
## TESTCASE:    create a new symbolic link, mac failure (dom)
+ symlinkat perm=dir_add_name at=1 which=new expres=fail mlsop=dom err=EACCES
## TESTCASE:    create a new symbolic link, mac failure (domby)
+ symlinkat perm=dir_add_name at=1 which=new expres=fail mlsop=domby err=EACCES
## TESTCASE:    create a new symbolic link, mac failure (incomp)
+ symlinkat perm=dir_add_name at=1 which=new expres=fail mlsop=incomp err=EACCES
## TESTCASE:    create a new symbolic link, mac success
+ symlinkat perm=file_create at=1 which=new expres=success mlsop=eq
## TESTCASE:    create a new symbolic link, mac failure (dom)
+ symlinkat perm=file_create at=1 which=new expres=fail mlsop=dom err=EACCES
## TESTCASE:    create a new symbolic link, mac failure (domby)
+ symlinkat perm=file_create at=1 which=new expres=fail mlsop=domby err=EACCES
## TESTCASE:    create a new symbolic link, mac failure (incomp)
+ symlinkat perm=file_create at=1 which=new expres=fail mlsop=incomp err=EACCES


## SYSCALL:	truncate()
+ truncate perm=file_write expres=success mlsop=eq
+ truncate perm=file_write expres=fail mlsop=domby err=EACCES
if [[ $MODE == 32 ]]; then
+ truncate64 perm=file_write expres=success mlsop=eq
+ truncate64 perm=file_write expres=fail mlsop=incomp err=EACCES
fi  

## SYSCALL:	unlink()
## PURPOSE:     verify audit of attempts to delete a name and/or file
+ unlink perm=dir_remove_name entry=file expres=success mlsop=eq
+ unlink perm=dir_remove_name entry=file expres=fail mlsop=incomp err=EACCES
+ unlink perm=file_unlink expres=success mlsop=eq
+ unlink perm=file_unlink expres=fail mlsop=dom err=EACCES
+ unlink perm=file_unlink expres=fail mlsop=domby err=EACCES
+ unlink perm=file_unlink expres=fail mlsop=incomp err=EACCES

## SYSCALL:	unlinkat()
## PURPOSE:
## Verify that the unlinkat() syscall is subject to the correct MLS constraints
## when removing files from the file system.  There are two types of testcases
## in this set of tests.  The first, using the 'perm=dir_remove_name' variable,
## creates a new directory with a file in it which is labeled in such a way that
## the MLS sensitivity label which may or may not be accessibile to the subject
## test process executing the unlinkat() syscall.  The second test creates a
## new file which is labeled in such a way that the MLS sensitivity label which
## may or may not be accessibile to the subject test process executing the
## unlinkat() syscall.  The test procedure is as follows:
##  1a. If perm=dir_remove_name then create a new directory with a test file
##      where the directory is labeled in such a way that the MLS relationship
##      between the directory and the test process is defined by the mlsop
##      variable (dom, domby, incomp)
##  1b. If perm=file_unlink then create a new file with a label such that the
##      MLS relationship between the file and the test process is defined by the
##      mlsop variable (dom, domby, incomp)
##  2.  Exectue the test process and attempt the unlinkat() syscall, verify the
##      results
##  3.  Check the audit log for the correct syscall result
## TESTCASE:    remove a file from a labeled directory, mac success
+ unlinkat perm=dir_remove_name at=1 entry=file expres=success mlsop=eq
## TESTCASE:    remove a file from a labeled directory, mac failure (dom)
+ unlinkat perm=dir_remove_name at=1 entry=file expres=fail mlsop=dom err=EACCES
## TESTCASE:    remove a file from a labeled directory, mac failure (domby)
+ unlinkat perm=dir_remove_name at=1 entry=file expres=fail mlsop=domby err=EACCES
## TESTCASE:    remove a file from a labeled directory, mac failure (incomp)
+ unlinkat perm=dir_remove_name at=1 entry=file expres=fail mlsop=incomp err=EACCES
## TESTCASE:    remove a file, mac success
+ unlinkat perm=file_unlink at=1 expres=success mlsop=eq
## TESTCASE:    remove a file, mac failure (dom)
+ unlinkat perm=file_unlink at=1 expres=fail mlsop=dom err=EACCES
## TESTCASE:    remove a file, mac failure (domby)
+ unlinkat perm=file_unlink at=1 expres=fail mlsop=domby err=EACCES
## TESTCASE:    remove a file, mac failure (incomp)
+ unlinkat perm=file_unlink at=1 expres=fail mlsop=incomp err=EACCES

## SYSCALL:	uselib()
## PURPOSE:	verify audit of attempts to load a shared library
## NOTE:	The kernel only accepts obsolete formats, so the true success
##		case is difficult to reproduce. Permission checks happen before
##		the format checks, so verifying ENOEXEC is sufficient to
##		demonstrate DAC/MAC success.
if [[ $HOSTTYPE != x86_64 ]]; then
## TESTCASE:	mac success (eq)
+ uselib perm=file_exec expres=fail mlsop=eq err=ENOEXEC \
  tag=uselib__file_exec_success_subj_eq_obj
## TESTCASE:	mac success (dom)
+ uselib perm=file_exec expres=fail mlsop=dom err=ENOEXEC \
  tag=uselib__file_exec_success_subj_dom_obj
## TESTCASE:	mac failure (domby)
+ uselib perm=file_exec expres=fail mlsop=domby err=EACCES
## TESTCASE:	mac failure (incomp)
+ uselib perm=file_exec expres=fail mlsop=incomp err=EACCES
fi

##
## IPC syscalls
##

## SYSCALL:     msgget()
## PURPOSE:     verify audit of attempts to get a message queue id
if [[ $MODE == 64 ]]; then
+ msgget perm=msg_key_read expres=success mlsop=eq
+ msgget perm=msg_key_read expres=success mlsop=dom
+ msgget perm=msg_key_read expres=fail mlsop=domby err=EACCES
+ msgget perm=msg_key_read expres=fail mlsop=incomp err=EACCES
+ msgget perm=msg_key_write expres=success mlsop=eq
+ msgget perm=msg_key_write expres=fail mlsop=dom err=EACCES
+ msgget perm=msg_key_write expres=fail mlsop=domby err=EACCES
+ msgget perm=msg_key_write expres=fail mlsop=incomp err=EACCES
else
+ ipc op=msgget perm=msg_key_read expres=success mlsop=eq
+ ipc op=msgget perm=msg_key_read expres=success mlsop=dom
+ ipc op=msgget perm=msg_key_read expres=fail mlsop=domby err=EACCES
+ ipc op=msgget perm=msg_key_read expres=fail mlsop=incomp err=EACCES
+ ipc op=msgget perm=msg_key_write expres=success mlsop=eq
+ ipc op=msgget perm=msg_key_write expres=fail mlsop=dom err=EACCES
+ ipc op=msgget perm=msg_key_write expres=fail mlsop=domby err=EACCES
+ ipc op=msgget perm=msg_key_write expres=fail mlsop=incomp err=EACCES
fi

## SYSCALL:     msgrcv()
## PURPOSE:     verify audit of attempts to receive messages from a message queue
if [[ $MODE == 64 ]]; then
+ msgrcv perm=msg_id_recv expres=success mlsop=eq
+ msgrcv perm=msg_id_recv expres=success mlsop=dom
+ msgrcv perm=msg_id_recv expres=fail mlsop=domby err=EACCES
+ msgrcv perm=msg_id_recv expres=fail mlsop=incomp err=EACCES
else
+ ipc op=msgrcv perm=msg_id_recv expres=success mlsop=eq
+ ipc op=msgrcv perm=msg_id_recv expres=success mlsop=dom
+ ipc op=msgrcv perm=msg_id_recv expres=fail mlsop=domby err=EACCES
+ ipc op=msgrcv perm=msg_id_recv expres=fail mlsop=incomp err=EACCES
fi

## SYSCALL:     msgsnd()
## PURPOSE:     verify audit of attempts to send messages to a message queue
if [[ $MODE == 64 ]]; then
+ msgsnd perm=msg_id_send msg="this is a test" expres=success mlsop=eq \
  testfunc=test_mac_msg_send
+ msgsnd perm=msg_id_send msg="this is a test" expres=fail mlsop=dom \
  err=EACCES testfunc=test_mac_msg_send
+ msgsnd perm=msg_id_send msg="this is a test" expres=fail mlsop=domby \
  err=EACCES testfunc=test_mac_msg_send
+ msgsnd perm=msg_id_send msg="this is a test" expres=fail mlsop=incomp \
  err=EACCES testfunc=test_mac_msg_send
else
+ ipc op=msgsnd perm=msg_id_send msg="this is a test" expres=success mlsop=eq \
  testfunc=test_mac_msg_send
+ ipc op=msgsnd perm=msg_id_send msg="this is a test" expres=fail mlsop=dom \
  err=EACCES testfunc=test_mac_msg_send
+ ipc op=msgsnd perm=msg_id_send msg="this is a test" expres=fail mlsop=domby \
  err=EACCES testfunc=test_mac_msg_send
+ ipc op=msgsnd perm=msg_id_send msg="this is a test" expres=fail mlsop=incomp \
  err=EACCES testfunc=test_mac_msg_send
fi

## SYSCALL:     semget()
## PURPOSE:     verify audit of attempts to get a semaphore set id
if [[ $MODE == 64 ]]; then
+ semget perm=sem_key_read expres=success mlsop=eq
+ semget perm=sem_key_read expres=success mlsop=dom
+ semget perm=sem_key_read expres=fail mlsop=domby err=EACCES
+ semget perm=sem_key_read expres=fail mlsop=incomp err=EACCES
+ semget perm=sem_key_write expres=success mlsop=eq
+ semget perm=sem_key_write expres=fail mlsop=dom err=EACCES
+ semget perm=sem_key_write expres=fail mlsop=domby err=EACCES
+ semget perm=sem_key_write expres=fail mlsop=incomp err=EACCES
else
+ ipc op=semget perm=sem_key_read expres=success mlsop=eq
+ ipc op=semget perm=sem_key_read expres=success mlsop=dom
+ ipc op=semget perm=sem_key_read expres=fail mlsop=domby err=EACCES
+ ipc op=semget perm=sem_key_read expres=fail mlsop=incomp err=EACCES
+ ipc op=semget perm=sem_key_write expres=success mlsop=eq
+ ipc op=semget perm=sem_key_write expres=fail mlsop=dom err=EACCES
+ ipc op=semget perm=sem_key_write expres=fail mlsop=domby err=EACCES
+ ipc op=semget perm=sem_key_write expres=fail mlsop=incomp err=EACCES
fi

## SYSCALL:     semop()
## PURPOSE:     verify audit of attempts to perform an operation on a semaphore
if [[ $MODE == 64 ]]; then
+ semop perm=sem_id_read expres=success mlsop=eq
+ semop perm=sem_id_read expres=success mlsop=dom
+ semop perm=sem_id_read expres=fail mlsop=domby err=EACCES
+ semop perm=sem_id_read expres=fail mlsop=incomp err=EACCES
else
+ ipc op=semop perm=sem_id_read expres=success mlsop=eq
+ ipc op=semop perm=sem_id_read expres=success mlsop=dom
+ ipc op=semop perm=sem_id_read expres=fail mlsop=domby err=EACCES
+ ipc op=semop perm=sem_id_read expres=fail mlsop=incomp err=EACCES
fi

## SYSCALL:     semtimedop()
## PURPOSE:     verify audit of attempts to perform an operation on a semaphore
if [[ $MODE == 64 ]]; then
+ semtimedop perm=sem_id_write expres=success mlsop=eq
+ semtimedop perm=sem_id_write expres=fail mlsop=dom err=EACCES
+ semtimedop perm=sem_id_write expres=fail mlsop=domby err=EACCES
+ semtimedop perm=sem_id_write expres=fail mlsop=incomp err=EACCES
else
+ ipc op=semtimedop perm=sem_id_write expres=success mlsop=eq
+ ipc op=semtimedop perm=sem_id_write expres=fail mlsop=dom err=EACCES
+ ipc op=semtimedop perm=sem_id_write expres=fail mlsop=domby err=EACCES
+ ipc op=semtimedop perm=sem_id_write expres=fail mlsop=incomp err=EACCES
fi

## SYSCALL:     shmat()
## PURPOSE:     verify audit of attempts to attach a shared memory segment
if [[ $MODE == 64 ]]; then
+ shmat perm=shm_id_read expres=success mlsop=eq
+ shmat perm=shm_id_read expres=success mlsop=dom
+ shmat perm=shm_id_read expres=fail mlsop=domby err=EACCES
+ shmat perm=shm_id_read expres=fail mlsop=incomp err=EACCES
+ shmat perm=shm_id_write expres=success mlsop=eq
+ shmat perm=shm_id_write expres=fail mlsop=dom err=EACCES
+ shmat perm=shm_id_write expres=fail mlsop=domby err=EACCES
+ shmat perm=shm_id_write expres=fail mlsop=incomp err=EACCES
else
+ ipc op=shmat perm=shm_id_read expres=success mlsop=eq
+ ipc op=shmat perm=shm_id_read expres=success mlsop=dom
+ ipc op=shmat perm=shm_id_read expres=fail mlsop=domby err=EACCES
+ ipc op=shmat perm=shm_id_read expres=fail mlsop=incomp err=EACCES
+ ipc op=shmat perm=shm_id_write expres=success mlsop=eq
+ ipc op=shmat perm=shm_id_write expres=fail mlsop=dom err=EACCES
+ ipc op=shmat perm=shm_id_write expres=fail mlsop=domby err=EACCES
+ ipc op=shmat perm=shm_id_write expres=fail mlsop=incomp err=EACCES
fi

## SYSCALL:     shmget()
## PURPOSE:     verify audit of attempts to get a shared memory segment id
## TESTCASE:    get for read, mac success (dom)
## TESTCASE:    get for read, mac failure (domby)
if [[ $MODE == 64 ]]; then
+ shmget perm=shm_key_read expres=success mlsop=eq
+ shmget perm=shm_key_read expres=success mlsop=dom
+ shmget perm=shm_key_read expres=fail mlsop=domby err=EACCES
+ shmget perm=shm_key_read expres=fail mlsop=incomp err=EACCES
+ shmget perm=shm_key_write expres=success mlsop=eq
+ shmget perm=shm_key_write expres=fail mlsop=dom err=EACCES
+ shmget perm=shm_key_write expres=fail mlsop=domby err=EACCES
+ shmget perm=shm_key_write expres=fail mlsop=incomp err=EACCES
else
+ ipc op=shmget perm=shm_key_read expres=success mlsop=eq
+ ipc op=shmget perm=shm_key_read expres=success mlsop=dom
+ ipc op=shmget perm=shm_key_read expres=fail mlsop=domby err=EACCES
+ ipc op=shmget perm=shm_key_read expres=fail mlsop=incomp err=EACCES
+ ipc op=shmget perm=shm_key_write expres=success mlsop=eq
+ ipc op=shmget perm=shm_key_write expres=fail mlsop=dom err=EACCES
+ ipc op=shmget perm=shm_key_write expres=fail mlsop=domby err=EACCES
+ ipc op=shmget perm=shm_key_write expres=fail mlsop=incomp err=EACCES
fi

##
## MQ syscalls
##

## SYSCALL:     mq_open()
## PURPOSE:     verify audit of attempts to create/open a message queue
+ mq_open perm=mq_create flag=create expres=success mlsop=eq
+ mq_open perm=mq_create flag=create expres=fail mlsop=dom err=EACCES
+ mq_open perm=mq_create flag=create expres=fail mlsop=domby err=EACCES
+ mq_open perm=mq_create flag=create expres=fail mlsop=incomp err=EACCES
+ mq_open perm=mq_read flag=read expres=success mlsop=eq
+ mq_open perm=mq_read flag=read expres=success mlsop=dom
+ mq_open perm=mq_read flag=read expres=fail mlsop=domby err=EACCES
+ mq_open perm=mq_read flag=read expres=fail mlsop=incomp err=EACCES
+ mq_open perm=mq_write flag=write expres=success mlsop=eq
+ mq_open perm=mq_write flag=write expres=fail mlsop=dom err=EACCES

## SYSCALL:     mq_unlink()
## PURPOSE:     verify audit of attempts to remove a message queue
+ mq_unlink perm=mq_write expres=success mlsop=eq
+ mq_unlink perm=mq_write expres=fail mlsop=domby err=EACCES
+ mq_unlink perm=mq_write expres=fail mlsop=incomp err=EACCES

##
## PROCESS syscalls
##

## SYSCALL:     kill()
## PURPOSE:     verify audit of attempts to send signals to processes
+ kill perm=process_sigusr1 expres=success mlsop=eq
+ kill perm=process_sigusr1 expres=fail mlsop=dom err=EACCES
+ kill perm=pgrp_sigkill expres=success mlsop=eq testfunc=test_mac_kill_pgrp
+ kill perm=pgrp_sigkill expres=fail mlsop=dom err=EACCES testfunc=test_mac_kill_pgrp

## SYSCALL:     ptrace()
## PURPOSE:     verify audit of attempts to trace a process
+ ptrace perm=process_attach expres=success mlsop=eq
+ ptrace perm=process_attach expres=fail mlsop=dom err=EPERM
+ ptrace perm=process_attach expres=fail mlsop=domby err=EPERM
+ ptrace perm=process_attach expres=fail mlsop=incomp err=EPERM

## SYSCALL:     tgkill()
## PURPOSE:     verify audit of attempts to send a signal to a process 
+ tgkill perm=process_sigkill expres=success mlsop=eq
+ tgkill perm=process_sigkill expres=fail mlsop=domby err=EACCES

## SYSCALL:     tkill()
## PURPOSE:     verify audit of attempts to send a signal to a process
+ tkill perm=process_sigstop expres=success mlsop=eq
+ tkill perm=process_sigstop expres=fail mlsop=incomp err=EACCES

##
## XATTR syscalls
##
## SYSCALL:	getxattr(), lgetxattr(), listxattr(), llistxattr()
## PURPOSE:
## Verify that the mls read constraints are enforced when attempts are made to
## retrieve extended attribute values. Additionally verify that successful and
## unsuccessful attempts are properly audited.
##
## TESTCASE:	mac success (dom)
+ getxattr perm=file_read flag=security.selinux expres=success mlsop=dom
## TESTCASE:	mac failure (domby)
+ getxattr perm=file_read flag=security.selinux expres=fail mlsop=domby err=EACCES
## TESTCASE:	mac success (eq)
+ lgetxattr perm=file_read flag=security.selinux expres=success mlsop=eq
## TESTCASE:	mac failure (incomp)
+ lgetxattr perm=file_read flag=security.selinux expres=fail mlsop=incomp err=EACCES
## TESTCASE:	mac success (dom)
+ listxattr perm=file_read expres=success mlsop=dom
## TESTCASE:	mac failure (domby)
+ listxattr perm=file_read expres=fail mlsop=domby err=EACCES
## TESTCASE:	mac success (eq)
+ llistxattr perm=file_read expres=success mlsop=eq
## TESTCASE:	mac failure (incomp)
+ llistxattr perm=file_read expres=fail mlsop=incomp err=EACCES
##
## SYSCALL:	removexattr(), fremovexattr(), lremovexattr()
## 		setxattr(), fsetxattr(), lsetxattr()
## PURPOSE:
## Verify that regular users cannot modify the values of security attributes on
## files they don't own. Additionally verify that attempts are properly audited.
##

+ fremovexattr perm=priv_modify flag=security.selinux expres=fail owner=user err=EACCES
+ fsetxattr perm=priv_modify flag=security.selinux expres=fail owner=user \
  err=EPERM testfunc=test_set_secattr
+ lremovexattr perm=priv_modify flag=security.selinux expres=fail owner=user err=EACCES
+ lsetxattr perm=priv_modify flag=security.selinux expres=fail owner=user \
  err=EPERM testfunc=test_set_secattr
+ removexattr perm=priv_modify flag=security.selinux expres=fail owner=user err=EACCES
+ setxattr perm=priv_modify flag=security.selinux expres=fail owner=user \
  err=EPERM testfunc=test_set_secattr
