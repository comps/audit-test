#!/bin/bash
# =============================================================================
# (c) Copyright Hewlett-Packard Development Company, L.P., 2005, 2006, 2007
#
#   This program is free software;  you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY;  without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
#   the GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program;  if not, write to the Free Software
#   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
# =============================================================================

# Rename the original run.bash + function to run+ and create our own + function
# that generates a tag for the test based on the named parameters.
eval "function run+ $(type + | sed '1,2d')"
function + {
    declare test=$1 tag # make sure it is not inherited from caller
    shift
    eval "$(parse_named "$@")" && [[ ${#unnamed[@]} -eq 0 ]] || exit_error
    set -- "$@" permtype="$permtype"

    # use tag supplied in run.conf
    if [[ -n $tag ]]; then
        run+ $test "$@"

    # otherwise, extract the named args that identify a unique testcase
    elif [[ -n $owner ]]; then
        run+ $test tag="${test}__${perm}_${expres}_${owner}" "$@"
    elif [[ -n $mlsop ]]; then
        run+ $test tag="${test}__${perm}_${expres}_subj_${mlsop}_obj" "$@"
    else
        run+ $test tag="${test}__${perm}_${expres}" "$@"
    fi
}

function show_test {
    if ! $opt_verbose; then
	declare tag # make sure it is not inherited from caller
	eval "$(parse_named "$@")" || exit_error
	[[ -n $tag ]] && set -- "$tag"
    fi
    fmt_test "[$TESTNUM]" "$@"
}

function run_test { 
    source syscall_functions.bash || exit_error

    declare status

    syscall=$1
    shift
    eval "$(parse_named "$@")" && [[ ${#unnamed[@]} -eq 0 ]] || exit_error

    # Force the audit log to rotate
    rotate_audit_logs || exit_error

    # Add our rule.
    auditctl -a entry,always ${MODE:+-F arch=b$MODE} -S $syscall || exit_error
    prepend_cleanup "auditctl -d entry,always ${MODE:+-F arch=b$MODE} -S $syscall"

    if [[ -n $mlsop ]]; then
	compute_contexts $mlsop
    fi

    # This is kind of ugly and there is a lot of common code between the dac and
    # mac functions for creating objects. It should all be combined into a
    # single function someday.

    # Set up objects for test op based on specified permission.
    case $perm in
        dir_*|file_*|symlink_*|mount_*|priv_modify|xattr_*)
	    create_fs_objects_$permtype $perm ;;
        msg_*|sem_*|shm_*)
	    create_ipc_objects_$permtype $perm ;;
        mq_*)
	    create_mq_objects_$permtype $perm ;;
        process_*|pgrp_*)
	    create_process_objects_$permtype $perm ;;
        *) exit_error "unknown perm to test: $perm" ;;
    esac

    # Set up variables for augrok
    case $expres in
        success) success=yes ;;
        fail)    success=no ;;
        *)       exit_error "unknown expected result for $0: $expres" ;;
    esac
    log_mark=$(stat -c %s $audit_log)

    # Run this in a subshell so that exit_* doesn't abort early
    (
        declare testres exitval pid
        set -x

        # Run the test callback (which has access to the named params)
        # or run the default test
	if [[ -n $testfunc ]]; then
	    $testfunc
	elif [[ -n $mlsop ]]; then
	    test_mac_default
	elif [[ -n $owner ]]; then
	    test_dac_default
	else
	    read testres exitval pid \
		<<<"$(do_$syscall $op $dirname $source $target $flag)"
        fi

        [[ -z $testres || -z $exitval || -z $pid ]] && exit_error
        check_result $expres $testres $exitval $err

        if [[ -n $augrokfunc ]]; then
            $augrokfunc || exit_fail "missing syscall record"
        else
            augrok_default || exit_fail "missing syscall record"
        fi

        exit_pass
    )
    status=$?

    # Display the log items
    if [[ $status != 0 ]]; then
        echo
        echo augrok output
        echo -------------
        augrok type!=DAEMON_ROTATE
    fi

    return $status
}

permtype=dac
source dac-run.conf
if [[ $PPROFILE == lspp ]]; then
    permtype=mac
    source mac-run.conf
fi
