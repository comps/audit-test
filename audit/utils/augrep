#!/usr/bin/perl -w
# =============================================================================
# (c) Copyright Hewlett-Packard Development Company, L.P., 2005
# Written by Aron Griffis <aron@hp.com>
#
#   This program is free software;  you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY;  without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
#   the GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program;  if not, write to the Free Software
#   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
# =============================================================================

use POSIX;
use Getopt::Long;
use strict;

######################################################################
# Global vars
######################################################################

(my $version = '$Revision$') =~ s/.*?(\d.*\d).*/augrep version $1\n/;
my $found = 0;
my %opt = (
    'f' => '/var/log/audit/audit.log',
);
my $usage = <<EOT;
usage: augrep [options...] condition...

    -c     --count         Only print a count of matching lines
    -f     --file=logfile  Search a log other than /var/log/audit/audit.log
    -h     --help          Show this help message
    -m     --max-count=NUM stop after NUM matches
    -q     --quiet         No output, just set exit status (like grep)
           --seek=offset   Seek to offset before starting search
           --raw           Show raw lines instead of merged record
    -V     --version       Show version information
EOT

######################################################################
# Audit Reader
######################################################################

package AuditReader;

use FileHandle;

sub new {
    my ($class, $filename) = @_;
    my ($self) = {
        filename => $filename,
        fh => undef,
        records => [],
    };
    bless $self, $class;

    $self->{'fh'} = FileHandle->new($filename, 'r') 
        or die "failed to open $filename: $!";

    return $self;
}

sub seek {
    my ($self, $pos) = @_;
    my ($fh) = $self->{'fh'};

    if ($pos == 0) {
        $fh->seek(0, 0) or die "failed to seek: $!";
    } else {
        $fh->seek($pos-1, 0) or die "failed to seek: $!";
        # move to the next line
        scalar <$fh>;
    }
}

sub next_record {
    my ($self) = @_;
    my ($fh) = $self->{'fh'};
    my ($record);

    # populate the array; low-water=30, high-water=60
    if (@{$self->{'records'}} < 30) {
        while (@{$self->{'records'}} < 60 and !$fh->eof) {
            push @{$self->{'records'}}, AuditRecord->new(scalar <$fh>);
        }
    }
    return undef unless (@{$self->{'records'}});

    # take the top record from the list
    $record = shift @{$self->{'records'}};

    # merge following records with duplicate ids
    for (my $i = 0; $i < @{$self->{'records'}}; ) {
        my ($other) = $self->{'records'}[$i];
        if ($other->get('msg') eq $record->get('msg')) {
            $record->merge($other);
            splice @{$self->{'records'}}, $i, 1;
        } else {
            $i++;
        }
    }

    # return the merged record
    return $record;
}

######################################################################
# Audit Record
######################################################################

package AuditRecord;

sub new {
    my ($class, $line) = @_;
    my ($self) = {
        _raw => ($line || ''),
        _order => [],
    };
    bless $self, $class;

    $self->parse($line) if (defined $line);

    return $self;
}

sub parse {
    my ($self, $line) = @_;
    my ($orig) = $line;
    while (
            $line =~ s/   # -- simple value --
        \A\s*             # skip leading ws
        (\S[^"'=]*)       # $1 = key: no quotes (but might have ws!)
        (?<!\s)           # last char of key should not be ws
            =             # no ws around equal sign
        ()                # $2 = empty
        (                 # $3 = value
         [^'"\s]          # first char cannot be a quote
         (?:
            [^\\\s] |           # normal chars; no ws allowed
            (?:\\[0-8]{1,3}) |  # escaped octal
            (?:\\.)             # escaped character
         )*                     # repeat to capture all of value
        )
        \s*               # skip ws trailing value
        (?=\z|\S[^"']*=)  # next should be end or key
                //x or
            $line =~ s/   # -- quoted value--
        \A\s*             # skip leading ws
        (\S[^"'=]*)       # $1 = key: no quotes (but might have ws!)
        (?<!\s)           # last char of key should not be ws
            =             # no ws around equal sign
        (['"])            # $2 = leading quote
        (                 # $3 = value
         (?:
            [^\2\\] |           # normal chars
            (?:\\[0-8]{1,3}) |  # escaped octal
            (?:\\.)             # escaped character
         )*                     # repeat to capture all of value
        )
        \2                # backreference to end quote
        \s*               # skip ws trailing value
        (?=\z|\S[^"']*=)  # next should be end or key
                //x
    ) {
        my ($k, $v) = ($1, $3);
        $v =~ s/^(['"])(.*)\1$/$2/;
        $self->merge_kv($k, $v);
    }

    return if length($line) == 0;
    chomp($line);
    print STDERR "augrep: WARNING: could not parse [$line] from: $orig";
}

sub merge_kv {
    my ($self, $k, $v) = @_;

    print STDERR "Merging [$k] = [$v]\n" if $opt{'debug'};

    # concatenate raw lines
    if ($k eq '_raw') { $self->{$k} .= $v; return; }

    # only merge other special fields once
    elsif (substr($k, 0, 1) eq '_' and exists $self->{$k}) { return; }

    # handle duplicate keys
    elsif (exists $self->{$k}) {
        # simply concatenate types
        if ($k eq 'type') {
            $self->{$k} .= ',' . $v;
            return;
        }

        # handle other duplicates generically by appending a serial number
        my ($serial, $new_k) = 1;
        $serial++ while ($new_k = $k.'_'.$serial and
            exists $self->{$new_k} and $self->{$new_k} ne $v);
        $k = $new_k;
    }

    # remember the order in which fields were seen
    push @{$self->{'_order'}}, $k unless $self->{$k};
        
    # specials cases handled, add to our hash
    $self->{$k} = $v;
}

sub merge {
    my ($self, $other) = @_;
    for my $k ($other->keys) {
        $self->merge_kv($k, $other->get($k));
    }
}

sub raw {
    my ($self) = @_;
    return $self->{'_raw'};
}

sub get {
    my ($self, $k) = @_;
    return $self->{$k};
}

sub keys {
    my ($self, $k) = @_;
    return CORE::keys %$self;
}

sub to_s {
    my ($self) = @_;
    return join(' ', map {
            (my $v = $self->{$_}) =~ s/.*\s.*/"$&"/;
            "$_=$v" } @{$self->{'_order'}});
}

sub test {
    my ($self) = @_; shift;
    my ($prev_was_cond, $negate);

    for my $a (@ARGV) {
        print STDERR "Parsing [$a]\n" if $opt{'debug'};

        if ($a eq 'and' or $a eq 'or' or
            $a eq '!' or $a eq 'not' or
            $a =~ /^\(+$/ or $a =~ /^\)+$/)
        { $prev_was_cond = 0; next; }

        # handle equality negations generically
        $a =~ s{^([\w\s]+)!=(.*)}{$1==$2} and $negate = 1;

        # string comparison, handling surrouding quotes
        if ($a =~ s{^([\w\s]+)==(.*)}{}) {
            if ($1 eq 'msg_time' or $1 eq 'msg_seq') {
                $a = "$1==$2";      # punt to numeric comparison
            } else {
                $a = qq(
                    ((substr(\$self->{'$1'}, 0, 1) =~ /['"]/) ?
                     (substr(\$self->{'$1'}, 1, -1) eq q{$2}) :
                     (\$self->{'$1'} eq q{$2}))
                );
                goto end_subs;
            }
        }

        # numeric comparison
        if ($a =~ s{^([\w\s]+)(<=|>=|==|<|>)(.*)}{}) {
            if ($1 eq 'msg_time') {
                my ($op, $seconds) = ($2, $3);
                $seconds = `date +\%s -d '$seconds'` if $seconds =~ /[^\d.]/;
                chomp($seconds);
                $a = qq(
                    do {
                        my (\$time, \$seq) = (split /[(:)]/, \$self->{'msg'})[1,2];
                        defined \$seq and \$time $op $seconds;
                    }
                );
                goto end_subs;
            } 
            if ($1 eq 'msg_seq') {
                $a = qq(
                    do {
                        my (\$time, \$seq) = (split /[(:)]/, \$self->{'msg'})[1,2];
                        defined \$seq and \$seq $2 $3;
                    }
                );
                goto end_subs;
            }
            $a = qq( \$self->{'$1'} $2 $3 );
            goto end_subs;
        };

        # regex comparions
        if ($a =~ s{^([\w\s]+)(!~|=~)(.*)}{}) {
            $a = qq(
                ((substr(\$self->{'$1'}, 0, 1) =~ /['"]/) ?
                 (substr(\$self->{'$1'}, 1, -1) $2 m{$3}) :
                 (\$self->{'$1'} $2 m{$3}))
            );
            goto end_subs;
        }

        die "Error evaluating expression: $a";

end_subs:

        # handle negations
        $a = "not ($a)" if $negate;
        $negate = 0;

        # make 'and' implicit, like the find command
        $a =~ s/^/and / if $prev_was_cond;
        $prev_was_cond = 1;

        print STDERR "Became [$a]\n" if $opt{'debug'};
    }
    my ($test) = "@ARGV";

    # in theory this should be (significantly) faster than eval'ing
    # repeatedly
    local $^W = 0;      # we're redefining test; don't complain
    eval "sub test { my (\$self) = \@_; local \$^W = 0; $test }";
    if ($@) {
        print STDERR "Error in expression: $@" if $@;
        print STDERR "Full test was:\n";
        print STDERR "$test";
        die;
    }

    # this only *appears* recursive
    $self->test(@_);
}

######################################################################
# Main
######################################################################

package main;

# Allow bundling of options
Getopt::Long::Configure("bundling");

# Parse the options on the cmdline.  Put the short versions first in
# each optionstring so that the hash keys are created using the short
# versions.  For example, use 'q|qar', not 'qar|q'.
my ($result) = GetOptions(
    \%opt,
    'c|count',
    'debug',
    'f|file=s',
    'h|help',
    'm|max-count=i',
    'q|quiet',
    'raw',
    'seek=i',
    'V|version',
);
if ($opt{'h'}) { print STDERR $usage; exit 0 }
if ($opt{'V'}) { print STDERR $version; exit 0 }
die "augrep: argument required\n$usage" unless @ARGV;

my ($reader) = AuditReader->new($opt{'f'});
$reader->seek($opt{'seek'} || $ENV{'AUDIT_SEEK'} || 0);

while (my $record = $reader->next_record) {
    next unless $record->test();
    $found++;
    if ($opt{'raw'}) {
        if ($opt{'c'}) {
            $found += ($record->raw =~ tr/\n//) - 1;
        } else {
            print $record->raw unless $opt{'q'};
        }
    } else {
        print $record->to_s."\n" unless $opt{'q'} or $opt{'c'};
    }
    last if $opt{'q'} or (defined($opt{'m'}) and $found >= $opt{'m'});
}

print $found, "\n" if $opt{'c'};
exit !$found;

__END__

=head1 NAME

augrep - audit.log search tool

=head1 SYNOPSIS

B<augrep> [I<-chqvV>] 
[I<--count --help --quiet --raw --version>] 
[I<-f logfile | --file logfile>] [I<--seek offset>] expression...

=head1 DESCRIPTION

This tool provides a command-line interface for search audit logs for
interesting records, similar to ausearch but slower and possibly more flexible.

=head2 EXPRESSIONS

The primitive expression syntax is <key><op><value>, where <key> is one of the
keys from audit.log, <op> is an operator (==, !=, <, >, <=, >=, =~) and <value>
is the value against which to compare.  There should be no whitespace between
the key, operator and value.  The value should not be quoted beyond the quoting
required by the shell.  For example, "type=~SYSCALL" is valid but
"type=~'SYSCALL'" is not.  In particular, make sure to quote any primitive
expression containing < or >, otherwise you're redirecting stdin/stdout, which
is probably not what you intended.

Complex expressions can be constructed using a combination of primitive
expressions and logical operators (not, and, or, and parentheses).  Note that
parentheses may need to be quoted to escape interpretation by the shell, for
example: '(' type=~SYSCALL ')'

In addition to the keys in audit.log, two special keys are provided: msg_time
and msg_seq.  These are the time and sequence values extracted from the msg
entry.  In particular, msg_time is special because augrep will automatically
parse the comparison value into the seconds-since-epoch format used by augrep,
for example, the following will find all messages that occurred during the
specified half-hour: 'msg_time>=14:00' 'msg_time<14:30'

=head1 OPTIONS

=over

=item B<-c --count>

Suppress normal output; instead print a count of matching lines.

=item B<-f> I<logfile> B<--file> I<logfile>

Search a logfile other than /var/log/audit/audit.log

=item B<-h --help>

Show usage information

=item B<-q --quiet>

Quiet; do not write anything to standard output.  Exit immediately with zero
status if any match is found, otherwise exit with non-zero status.

=item B<--raw>

Output the raw lines related to the search, rather than merging them into a
single record.  Note this means that the search expression might contain keys
not present in the output (such as inode_1)

=item B<--seek> I<offset>

Start the search at the first line at or after offset (bytes).

=item B<-V --version>

Show version information.

=back

=head1 EXAMPLES

To count the number of records with type=SYSCALL:

    $ augrep -c type=~SYSCALL
    537

To find a specific record:

    $ augrep msg=='audit(1124137373.408:565):'
    type=SYSCALL,FS_WATCH,FS_INODE,CWD,PATH msg=audit(1124137373.408:565):
    arch=c0000032 syscall=1210 success=yes exit=0 a0=6000000000006388
    a1=6000000000006390 a2=c00000000000048c a3=2000000000244238 items=1
    pid=28239 auid=1001 uid=0 gid=0 euid=0 suid=0 fsuid=0 egid=0 sgid=0 fsgid=0
    comm=chmod exe=/bin/chmod watch_inode=573461 watch=foo perm_mask=1
    filterkey= perm=1 inode_dev=08:06 inode_gid=0 inode=573461 inode_uid=0
    inode_rdev=00:00 cwd=/tmp rdev=00:00 ouid=0 dev=08:06 flags=1 mode=0100777
    name=foo/a ogid=0 inode_1=573504

=head1 ENVIRONMENT VARIABLES

=over

=item AUDIT_SEEK

If --seek is not specified and AUDIT_SEEK is set in the environemnt, its value
will be used as the default offset.

=back
