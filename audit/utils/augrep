#!/usr/bin/perl -w
# =============================================================================
# (c) Copyright Hewlett-Packard Development Company, L.P., 2005
# Written by Aron Griffis <aron@hp.com>
#
#   This program is free software;  you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY;  without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
#   the GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program;  if not, write to the Free Software
#   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
# =============================================================================

use POSIX;
use Getopt::Long;
use strict;

######################################################################
# Global vars
######################################################################

(my $zero = $0) =~ s|.*/||;
(my $version = '$Revision$') =~ s{.*?(\d.*\d).*}
                                       {augrok version 1.0 (svn $1)\n};
my $found = 0;
my %opt = (
    'f' => '/var/log/audit/audit.log',
);
my $usage = <<EOT;
usage: augrok [options...] condition...

    -c     --count         Only print a count of matching lines
    -f     --file=logfile  Search a log other than /var/log/audit/audit.log
    -h     --help          Show this help message
    -i     --interpret     Convert numbers to names when possible
    -m     --max-count=NUM stop after NUM matches
           --nosync        don't wait for auditd to finish flushing
    -q     --quiet         No output, just set exit status (like grep)
           --resolve=name  Resolve syscall name/number
           --seek=offset   Seek to offset before starting search
           --raw           Show raw lines instead of merged record
    -V     --version       Show version information
EOT
my $ausearch_usage = <<EOT;
usage: ausearch [options]
       -a  <audit event id>
       -c  <comm name>
       -f  <file name>
       -ga <all group id>
       -ge <effective group id>
       -gi <group id>
       -h
       -hn <host name>
       -i
       -if <input file name>
       -m  <message type>
       -p  <process id>
       -sc <syscall name>
       -sv <success value>
       -te [end date] [end time]
       -ts [start date] [start time]
       -tm <terminal>
       -ua <all user id>
       -ue <effective user id>
       -ui <user id>
       -ul <login id>
       -v
       -w
       -x <executable name>
EOT

$SIG{'__DIE__'} = sub {
    $! = 2;
    die(@_);
};

######################################################################
# Syscall Table (singleton)
######################################################################

package SyscallTable;

our $singleton;

sub new {
    my ($class) = @_;

    unless (defined $singleton) {
        $singleton = {};
        bless $singleton, $class;

        open(S, "gcc -E -dM /usr/include/syscall.h |") or die;
        my $line;
        while (defined($line = <S>)) {
            next unless $line =~ /^#define\s+__NR_(\w+)\s+(\w+)/;
            $singleton->{$1} = $2;
        }
        close S;

        my $changed;
        do {
            my ($v, $new_v);
            $changed = 0;
            for my $k (keys %$singleton) {
                next unless ($v = $singleton->{$k}) =~ /\D/;
                if (defined($new_v = $singleton->{$singleton->{$k}})) {
                    $singleton->{$k} = $new_v;
                    $changed = 1;
                } else {
                    print STDERR "Removing syscall{$k} = $v\n" if $opt{'debug'};
                    delete $singleton->{$k};
                }
            }
        } while ($changed);

        my (%rev) = ();
        while (my ($k, $v) = each %$singleton) {
            $rev{$v} ||= [];
            push @{$rev{$v}}, $k;
        }
        $singleton->{'_reverse'} = \%rev;
    }

    return $singleton;
}

sub resolve {
    my ($self, $k) = @_;
    return $self->{$k};
}

sub reverse {
    my ($self, $k) = @_;
    return $self->{'_reverse'}{$k};
}

######################################################################
# Audit Reader
######################################################################

package AuditReader;

use FileHandle;

sub new {
    my ($class, $filename) = @_;
    my $self = {
        filename => $filename,
        fh => undef,
        records => [],
    };
    bless $self, $class;

    $self->{'fh'} = FileHandle->new($filename, 'r') 
        or die "failed to open $filename: $!";

    return $self;
}

sub seek {
    my ($self, $pos) = @_;
    my $fh = $self->{'fh'};

    if ($pos == 0) {
        $fh->seek(0, 0) or die "failed to seek: $!";
    } else {
        $fh->seek($pos-1, 0) or die "failed to seek: $!";
        # move to the next line
        scalar <$fh>;
    }
}

sub next_record {
    my ($self) = @_;
    my $fh = $self->{'fh'};
    my ($line, $record, $msg, $other, $o_msg);

    # populate the array; low-water=30, high-water=60
    if (@{$self->{'records'}} < 30) {
        while (@{$self->{'records'}} < 60) {
            $line = <$fh>;
            # Make sure we got a line and that it was complete.
            # Incomplete lines can be found when the filesystem is full and
            # auditd couldn't write the entire record.
            last unless defined($line) and substr($line,-1) eq "\n";
            push @{$self->{'records'}}, AuditRecord->new($line);
        }
    }
    return undef unless (@{$self->{'records'}});

    # take the top record from the list
    $record = shift @{$self->{'records'}};

    # merge following records with duplicate ids
    if (defined($msg = $record->_get('msg'))) {
        for (my $i = 0; $i < @{$self->{'records'}}; $i++) {
            $other = $self->{'records'}[$i];
            next unless defined($o_msg = $other->_get('msg'));
            if ($o_msg eq $msg) {
                $record->merge($other);
                splice @{$self->{'records'}}, $i, 1;
                $i--;
            }
        }
    }

    # return the merged record
    return $record;
}

######################################################################
# Audit Parser
######################################################################

package AuditParser;

sub new {
    my ($class, $line) = @_;
    my $self = \$line;
    bless $self, $class;
    return $self;
}

our $key_re = q{
    [^\s"'=]+ |         # normal keys
    auditd\ pid |       # DAEMON_START, DAEMON_END
    sending\ pid |      # DAEMON_END
    login\ pid |        # LOGIN
    (?:old|new)\ auid | # LOGIN
    user\ pid           # USER_AUTH
};

sub next_field {
    my ($self) = @_;
    if (
            $$self =~ s/  # -- simple value --
        \A(\s*)           # $1 = leading ws
        ($key_re)         # $2 = key, incl known keys with ws
            =             # no ws around equal sign
        (?!['"])          # first char of value cannot be a quote
        ()                # $3 = empty (no quotes)
        (                 # $4 = value
            (?:
                [^\\\s]+ |          # normal chars; no ws allowed
                (?:\\[0-7]{1,3})+ | # escaped octal
                (?:\\.)             # escaped character
            )*                      # repeat to capture all of value
        )
                //xo or
            $$self =~ s/  # -- quoted value--
        \A(\s*)           # $1 = leading ws
        ($key_re)         # $2 = key, incl known keys with ws
            =             # no ws around equal sign
        (['"])            # $3 = leading quote
        (                 # $4 = value
            (?: [^\\] |             # normal chars
                (?:\\[0-7]{1,3}) |  # escaped octal
                (?:\\.)             # escaped character
            )*?           # repeat to capture all of value
        )
        \3                # backreference to end quote
                //xo or
            $$self =~ s/  # -- extra text --
        \A(\s*)           # $1 = leading ws
        (\S+)             # $2 = only capture one token at a time
                //x
    ) {
        return $2, $4, $1, $3;  # key, value, leading ws, quotes
    }

    if ($$self =~ /\S/) {
        chomp($$self);
        print STDERR "$zero: WARNING: could not parse [$$self]";
    }

    return ();
}

######################################################################
# Audit Record
######################################################################

package AuditRecord;

sub new {
    my ($class, $line) = @_;
    my $self = {
        _order => [],
    };
    bless $self, $class;

    if (defined $line) {
        $self->{'_raw'} = $line if $opt{'raw'} or $opt{'ausearch'};
        $self->merge($line);
    }

    return $self;
}

sub merge {
    my ($self, $other) = @_;

    # argument is an AuditRecord reference
    if (ref($other) eq 'AuditRecord') {
        for my $k ($other->keys) {
            $self->merge_kv($k, $other->_get($k));
        }
    }

    # argument is (presumably) a string to parse
    else {
        my $parser = AuditParser->new($other);
        while (my ($k, $v) = $parser->next_field) {
            if (defined $v) {
                $k =~ s/\s+/_/g;
                $v =~ s/^(['"])(.*)\1$/$2/;
                $self->merge_kv($k, $v);
            } else {
                $self->merge_kv('extra_text', $k);
            }
        }
    }
}

sub merge_kv {
    my ($self, $k, $v) = @_;

    print STDERR "Merging [$k] = [$v]\n" if $opt{'debug'};

    # concatenate raw lines
    if ($k eq '_raw') { $self->{$k} .= $v; return; }

    # only merge other special fields once
    elsif (substr($k, 0, 1) eq '_' and exists $self->{$k}) { return; }

    # handle duplicate keys
    elsif (exists $self->{$k}) {
        # simply concatenate types
        if ($k eq 'type') {
            $self->{$k} .= ',' . $v;
            return;
        }

        # concatenate extra_text with spaces
        if ($k eq 'extra_text') {
            $self->{$k} .= ' ' . $v;
            return;
        }

        # handle other duplicates generically by appending a serial number
        my ($new_k, $serial) = ($k, 0);
        while (exists $self->{$new_k} and $self->{$new_k} ne $v) {
            $new_k = $k.'_'.(++$serial);
        }
        $k = $new_k;
    }

    # fix up auditd-generated records which use a comma-space separator
    my $type = $self->{'type'};
    if (defined $type 
            and ($type eq 'DAEMON_START' or $type eq 'DAEMON_END') 
            and $k ne 'extra_text'
            and substr($v, -1) eq ',') {
        chop($v);
    }

    # remember the order in which fields were seen
    push @{$self->{'_order'}}, $k unless $self->{$k};

    # specials cases handled, add to our hash
    $self->{$k} = $v;
}

sub _raw {
    my ($self) = @_;
    return $self->{'_raw'};
}

sub raw {
    my ($self) = @_;
    my $raw = $self->{'_raw'};

    return $raw unless $opt{'i'};

    # since we're interpreting the fields, run the text through the parser
    # again, this time interpreting the values.  Doing this as a second pass
    # ensures that we're not wasting effort interpreting more records than are
    # matched by the expression on the command-line.
    my $parser = AuditParser->new($raw);
    my $type = $self->{'type'};
    $raw = '';

    while (my ($k, $v, $ws, $q) = $parser->next_field) {
        if (defined $v) {
            # Fix up auditd-generated records which use a comma-space separator.
            # This is necessary for interp to work!
            if (defined $type 
                    and ($type eq 'DAEMON_START' or $type eq 'DAEMON_END') 
                    and $k ne 'extra_text'
                    and substr($v, -1) eq ',') {
                chop($v);
            }
            $raw .= "$ws$k=$q".interp($k, $v)."$q";
        } else {
            $raw .= $ws.$k; # misc text
        }
    }
    return $raw."\n";
}

sub _get {
    my ($self, $k) = @_;
    return $self->{$k};
}

sub get {
    my ($self, $k) = @_;
    my $v = $self->{$k};

    return (defined $v and $opt{'i'}) ? interp($k, $v) : $v;
}

# This list should be fairly static.  It was generated using
# gcc -E -dM /usr/include/linux/audit.h | grep '^#define AUDIT_ARCH_'
our (%archtab) = (
    'c0009026' => 'alpha',
    '40000028' => 'arm',
    '28'       => 'armeb',
    '4000004c' => 'cris',
    '2e'       => 'h8300',
    '40000003' => 'i386',
    'c0000032' => 'ia64',
    '58'       => 'm32r',
    '4'        => 'm68k',
    '8'        => 'mips',
    '40000008' => 'mipsel',
    '80000008' => 'mips64',
    'c0000008' => 'mipsel64',
    'f'        => 'parisc',
    '8000000f' => 'parisc64',
    '14'       => 'ppc',
    '80000015' => 'ppc64',
    '16'       => 's390',
    '80000016' => 's390x',
    '2a'       => 'sh',
    '4000002a' => 'shel',
    '8000002a' => 'sh64',
    'c000002a' => 'shel64',
    '2'        => 'sparc',
    '40000057' => 'v850',
    'c000003e' => 'x86_64',
);
our (%archtab_r);
while (my ($bits, $name) = each %archtab) {
    $archtab_r{$name} = $bits;
}

# This list should be fairly static.  It was retrieved from audit-1.0.12
our (@flagtab) = (
    'follow',     # 0x0001
    'directory',  # 0x0002
    'continue',   # 0x0004
    'parent',     # 0x0008
    'noalt',      # 0x0010
    'atomic',     # 0x0020
    'open',       # 0x0040
    'create',     # 0x0080
    'access',     # 0x0100
);
our %flagtab_r;
{ my $ctr=0; %flagtab_r = map { $_ => (1<<$ctr++) } @flagtab; }

# This list should be fairly static (and hopefully platform-independent).  It
# was generated using
# gcc -E -dM /usr/include/sys/stat.h | grep '^#define __S_IF' | sort -n -k3
our (%modetab) = (
    0010000 => 'fifo',
    0020000 => 'char',
    0040000 => 'dir',
    0060000 => 'block',
    0100000 => 'file',
    0120000 => 'symlink',
    0140000 => 'socket',
);
our (%modetab_r);
while (my ($bits, $name) = each %modetab) {
    $modetab_r{$name} = $bits;
}

# Forward interpretations should return interpreted text or undef if there was
# no interpretation to be done.
#
# Reverse interpretations (those starting with '_') should interpreted text or
# undef if there was no interpretation to be done.  Unlike forward
# interpretations, reverse interpretations should die if there is a problem.
our (%interptab) = (
    'id'          => sub { scalar getpwuid $_[0]; },
    '_id'         => sub {
        return undef unless $_[0] =~ /\D/;
        my $id = getpwnam $_[0];
        die "$zero: Error: unknown user \"$_[0]\"\n" unless defined $id;
        $id; },
    'uid'         => sub { scalar getpwuid $_[0]; },
    '_uid'        => sub {
        return undef unless $_[0] =~ /\D/;
        my $id = getpwnam $_[0];
        die "$zero: Error: unknown user \"$_[0]\"\n" unless defined $id;
        $id; },
    'auid'        => sub { scalar getpwuid $_[0]; },
    '_auid'       => sub {
        return undef unless $_[0] =~ /\D/;
        my $id = getpwnam $_[0];
        die "$zero: Error: unknown user \"$_[0]\"\n" unless defined $id;
        $id; },
    'euid'        => sub { scalar getpwuid $_[0]; },
    '_euid'       => sub {
        return undef unless $_[0] =~ /\D/;
        my $id = getpwnam $_[0];
        die "$zero: Error: unknown user \"$_[0]\"\n" unless defined $id;
        $id; },
    'fsuid'       => sub { scalar getpwuid $_[0]; },
    '_fsuid'      => sub {
        return undef unless $_[0] =~ /\D/;
        my $id = getpwnam $_[0];
        die "$zero: Error: unknown user \"$_[0]\"\n" unless defined $id;
        $id; },
    'inode_uid'   => sub { scalar getpwuid $_[0]; },
    '_inode_uid'  => sub {
        return undef unless $_[0] =~ /\D/;
        my $id = getpwnam $_[0];
        die "$zero: Error: unknown user \"$_[0]\"\n" unless defined $id;
        $id; },
    'iuid'        => sub { scalar getpwuid $_[0]; },
    '_iuid'       => sub {
        return undef unless $_[0] =~ /\D/;
        my $id = getpwnam $_[0];
        die "$zero: Error: unknown user \"$_[0]\"\n" unless defined $id;
        $id; },
    'ouid'        => sub { scalar getpwuid $_[0]; },
    '_ouid'       => sub {
        return undef unless $_[0] =~ /\D/;
        my $id = getpwnam $_[0];
        die "$zero: Error: unknown user \"$_[0]\"\n" unless defined $id;
        $id; },
    'suid'        => sub { scalar getpwuid $_[0]; },
    '_suid'       => sub {
        return undef unless $_[0] =~ /\D/;
        my $id = getpwnam $_[0];
        die "$zero: Error: unknown user \"$_[0]\"\n" unless defined $id;
        $id; },

    'gid'         => sub { scalar getgrgid $_[0]; },
    '_gid'        => sub {
        return undef unless $_[0] =~ /\D/;
        my $id = getgrnam $_[0];
        die "$zero: Error: unknown group \"$_[0]\"\n" unless defined $id;
        $id; },
    'egid'        => sub { scalar getgrgid $_[0]; },
    '_egid'       => sub {
        return undef unless $_[0] =~ /\D/;
        my $id = getgrnam $_[0];
        die "$zero: Error: unknown group \"$_[0]\"\n" unless defined $id;
        $id; },
    'fsgid'       => sub { scalar getgrgid $_[0]; },
    '_fsgid'      => sub {
        return undef unless $_[0] =~ /\D/;
        my $id = getgrnam $_[0];
        die "$zero: Error: unknown group \"$_[0]\"\n" unless defined $id;
        $id; },
    'inode_gid'   => sub { scalar getgrgid $_[0]; },
    '_inode_gid'  => sub {
        return undef unless $_[0] =~ /\D/;
        my $id = getgrnam $_[0];
        die "$zero: Error: unknown group \"$_[0]\"\n" unless defined $id;
        $id; },
    'igid'        => sub { scalar getgrgid $_[0]; },
    '_igid'       => sub {
        return undef unless $_[0] =~ /\D/;
        my $id = getgrnam $_[0];
        die "$zero: Error: unknown group \"$_[0]\"\n" unless defined $id;
        $id; },
    'ogid'        => sub { scalar getgrgid $_[0]; },
    '_ogid'       => sub {
        return undef unless $_[0] =~ /\D/;
        my $id = getgrnam $_[0];
        die "$zero: Error: unknown group \"$_[0]\"\n" unless defined $id;
        $id; },
    'sgid'        => sub { scalar getgrgid $_[0]; },
    '_sgid'       => sub {
        return undef unless $_[0] =~ /\D/;
        my $id = getgrnam $_[0];
        die "$zero: Error: unknown group \"$_[0]\"\n" unless defined $id;
        $id; },

    'arch'        => sub { $archtab{$_[0]}; },
    '_arch'       => sub {
        $archtab_r{$_[0]} or
        ($_[0] =~ /[[:^xdigit:]]/
                and die "$zero: Error: unknown arch \"$_[0]\"\n") or
        undef; },

    'flags'       => sub {
        my (@flags);
        for (my $i = 0; $i < @flagtab; $i++) {
            push @flags, $flagtab[$i] if ($_[0] & (1<<$i));
        }
        join(',', @flags) || 'none'; },
    '_flags'      => sub {
        return undef if $_[0] =~ /^\d+$/;
        my $value = 0;
        for my $f (split ',', $_[0]) {
            my $bits = $flagtab_r{$f};
            die "$zero: Error: unknown flag \"$f\"\n" unless defined $bits;
            $value |= $bits;
        }
        $value; },

    'mode'        => sub {
        my $mode = $modetab{oct($_[0]) & 0170000};
        $mode ? sprintf("%s,%03o", $mode, oct($_[0]) & 0777) : undef; },
    '_mode'       => sub {
        return undef if $_[0] =~ /^[0-7]+$/;
        my ($s, $bits) = split ',', $_[0];
        my $type = $modetab_r{$s};
        die "$zero: Error: unknown type \"$type\"\n" unless defined $type;
        sprintf("%07o", ($type << 4) | oct($bits)); },

    'msg'         => sub {
        my $v = $_[0];
        return undef unless $v =~ s/^(audit\()(\d+)(?=\.\d+:\d+\))/
            $1 . POSIX::strftime('%D %T', localtime($2))/e;
        $v; },

    'syscall'     => sub {
        my $name = SyscallTable->new->reverse($_[0]);
        defined($name) ? $name->[0] : undef; },
    '_syscall'    => sub {
        return undef if $_[0] =~ /^\d+$/;
        my $num = SyscallTable->new->resolve($_[0]);
        die "$zero: Error: unknown syscall \"$_[0]\"\n" unless defined $num;
        $num; },
);

# NB: this is not a method
sub interp {
    my ($k, $v) = @_;
    my ($subr, $iv);

    # deserialize keys so the interpretation routine is found
    $k =~ s/_\d+$//;

    $iv = &$subr($v) if $subr = $interptab{$k};
    return defined $iv ? $iv : $v;
}

# NB: this is not a method
sub rinterp {
    my ($k, $v) = @_;
    my ($subr, $iv);

    # deserialize keys so the interpretation routine is found
    $k =~ s/_\d+$//;

    $iv = &$subr($v) if $subr = $interptab{"_$k"};
    return defined $iv ? $iv : $v;
}

sub keys {
    my ($self, $k) = @_;
    return CORE::keys %$self;
}

# NB: this is not a method
sub quote {
    my ($v) = @_;
    if ($v =~ /".*'|'.*"/) {
        # escape contained double-quotes then wrap in double-quotes
        $v =~ s/"/\\"/g; $v = "\"$v\"";
    }
    elsif ($v =~ /"/) {
        # wrap in single-quotes
        $v = "'$v'";
    }
    elsif ($v =~ /[\s']/) {
        # wrap in double-quotes
        $v = "\"$v\"";
    }
    return $v;
}

sub to_s {
    my ($self) = @_;
    return join(' ',
        map "$_=".quote($self->get($_)), @{$self->{'_order'}});
}

sub test {
    my ($self) = @_;
    my ($prev_was_cond, $negate);

    for my $a (@ARGV) {
        print STDERR "Parsing [$a]\n" if $opt{'debug'};

        if ($a eq 'and' or $a eq 'or' or
            $a eq '!' or $a eq 'not' or
            $a =~ /^\(+$/ or $a =~ /^\)+$/)
        { $prev_was_cond = 0; next; }

        # handle equality negations generically
        $a =~ s{^(\w+)!=(.*)}{$1==$2} and $negate = 1;

        # string comparison, handling surrouding quotes
        if ($a =~ s{^(\w+)=(?:=|(?!~))(.*)}{}) {
            my ($k, $v) = ($1, rinterp($1, $2));
            if ($k eq 'msg_time' or $k eq 'msg_seq') {
                $a = "$k==$v";      # punt to numeric comparison
            } else {
                $a = qq(
                    ((substr(\$self->{'$k'}, 0, 1) =~ /['"]/) ?
                     (substr(\$self->{'$k'}, 1, -1) eq q{$v}) :
                     (\$self->{'$k'} eq q{$v}))
                );
                goto end_subs;
            }
        }

        # numeric comparison
        if ($a =~ s{^(\w+)(<=|>=|=(?:=|(?!~))|<|>)(.*)}{}) {
            my ($k, $op, $v) = ($1, $2, rinterp($1, $3));
            if ($k eq 'msg_time') {
                chomp($v = `date +\%s -d '$v'`) if $v =~ /[^\d.]/;
                $a = qq(
                    do {
                        my (\$time, \$seq) = (split /[(:)]/, \$self->{'msg'})[1,2];
                        defined \$seq and \$time $op $v;
                    }
                );
                goto end_subs;
            } 
            if ($k eq 'msg_seq') {
                $a = qq(
                    do {
                        my (\$time, \$seq) = (split /[(:)]/, \$self->{'msg'})[1,2];
                        defined \$seq and \$seq $op $v;
                    }
                );
                goto end_subs;
            }
            $a = qq( \$self->{'$k'} $op $v );
            goto end_subs;
        };

        # regex comparions
        if ($a =~ s{^(\w+)(!~|=~|~)(.*)}{}) {
            my ($k, $op, $v) = ($1, $2, rinterp($1, $3));
            $a = qq(
                ((substr(\$self->{'$k'}, 0, 1) =~ /['"]/) ?
                 (substr(\$self->{'$k'}, 1, -1) $op m{$v}) :
                 (\$self->{'$k'} $op m{$v}))
            );
            goto end_subs;
        }

        die "Error evaluating expression: $a";

end_subs:

        # handle negations
        $a = "not ($a)" if $negate;
        $negate = 0;

        # make 'and' implicit, like the find command
        $a =~ s/^/and / if $prev_was_cond;
        $prev_was_cond = 1;

        print STDERR "Became [$a]\n" if $opt{'debug'};
    }
    my $test = "@ARGV";

    # in theory this should be (significantly) faster than eval'ing
    # repeatedly
    local $^W = 0;      # we're redefining test; don't complain
    eval "sub test { my (\$self) = \@_; local \$^W = 0; $test }";
    if ($@) {
        print STDERR "Error in expression: $@" if $@;
        print STDERR "Full test was:\n";
        print STDERR "$test";
        die;
    }

    # this only *appears* recursive
    $self->test(@_);
}

######################################################################
# Main
######################################################################

package main;

if ($zero eq 'ausearch' or grep {$_ eq '--ausearch'} @ARGV) {
    $opt{'ausearch'} = 1;

    my $eq = '=~';
    Getopt::Long::Configure("default", "pass_through");
    die unless GetOptions(
        'w'     => sub { $eq = '==' },
    );

    push @ARGV, '--' unless grep {$_ eq '--'} @ARGV;

    Getopt::Long::Configure("default", "bundling_override");
    die unless GetOptions(
        'ausearch' => sub { },                                  # just ignore
        'a=i'   => sub { push @ARGV, "msg_seq==$_[1]" },
        'c=s'   => sub { push @ARGV, "comm==$_[1]" },
        'f=s'   => sub { push @ARGV, "name$eq$_[1]" },
        'ga=s'  => sub { push @ARGV, "(", "gid==$_[1]", "or",
                                          "egid==$_[1]", ")" },
        'ge=s'  => sub { push @ARGV, "egid==$_[1]" },
        'gi=s'  => sub { push @ARGV, "gid==$_[1]" },
        'h'     => sub { print STDERR $ausearch_usage; exit 0 },
        'hn=s'  => sub { push @ARGV, "hostname$eq$_[1]" },      # XXX msg_1?
        'i'     => sub { $opt{'i'} = 1; },
        'if=s'  => sub { $opt{'f'} = $_[1] },
        'm=s'   => sub { push @ARGV, ($_[1] eq 'ALL') ?
                         "type!=" : "type=~\\b$_[1]\\b" },
        'p=i'   => sub { push @ARGV, "pid==$_[1]" },
        'sc=s'  => sub { push @ARGV, "syscall==$_[1]" },        # XXX names
        'sv=s'  => sub { push @ARGV, "success==$_[1]" },
        'ts'    => sub { push @ARGV, "msg_time>=" },            # see <> below
        'te'    => sub { push @ARGV, "msg_time<=" },            # see <> below
        'tm'    => sub { push @ARGV, ($eq eq '==')
                            ? "msg_1=~\\bterminal=$_[1]\\b"
                            : "msg_1=~\\bterminal=\\S*$_[1]" },
        'ua=s'  => sub { push @ARGV, "(", "uid==$_[1]", "or",
                                          "euid==$_[1]", "or",
                                          "auid==$_[1]", ")" },
        'ue=s'  => sub { push @ARGV, "euid==$_[1]" },
        'ui=s'  => sub { push @ARGV, "uid==$_[1]" },
        'ul=s'  => sub { push @ARGV, "auid==$_[1]" },
        'v'     => sub { print STDERR $version; exit 0 },
        'w'     => sub { },                                     # handled above
        'x=s'   => sub { push @ARGV, "exe==$_[1]" },
        'debug' => sub { $opt{'debug'} = 1 },
        'nosync' => sub { $opt{'nosync'} = 1 },
        '<>'    => sub {
            die "I don't understand $_[0]\n" unless
            $ARGV[-1] =~ s/^(msg_time.=)(.*)/$1.(length($2)?"$2 ":"").$_[0]/e
        },
    );
    die "$zero: argument required\n$ausearch_usage" unless @ARGV;

} else {
    Getopt::Long::Configure("default", "bundling");
    die unless GetOptions(
        \%opt,
        'c|count',
        'debug',
        'f|file=s',
        'h|help',
        'i|interpret',
        'm|max-count=i',
        'nosync',
        'q|quiet',
        'raw',
        'resolve:s',
        'seek=i',
        'V|version',
    );
    if ($opt{'h'}) { print STDERR $usage; exit 0 }
    if ($opt{'V'}) { print STDERR $version; exit 0 }
    if (defined $opt{'resolve'}) {
        if ($opt{'resolve'} =~ /\D/) {
            my $num = SyscallTable->new->resolve($opt{'resolve'});
            if (defined $num) {
                print $num, "\n";
                exit 0;
            }
        } else {
            my $name = SyscallTable->new->reverse($opt{'resolve'});
            if (defined $name) {
                print join("\n", @$name), "\n";
                exit 0;
            }
        }
        exit 1; # could not resolve
    }
    die "$zero: argument required\n$usage" unless @ARGV;
}

# Unless --nosync is given, wait for the auditd backlog to reach zero, as
# reported by auditctl -s
if ($> == 0 and not $opt{'nosync'}) {
    my ($i, $backlog);
    for ($i = 0; $i < 30; $i++) {
        ($backlog = `/sbin/auditctl -s`) =~ s/.*?\bbacklog=(\d+).*/$1/s;
        last if $backlog == 0;
        if ($i % 10 == 0 and $opt{'debug'}) {
            print STDERR "$zero: waiting on backlog ($backlog)\n";
        }
        select(undef, undef, undef, 0.1);
    }
    if ($i == 30) {
        print STDERR "$zero: WARNING: backlog=$backlog after 3 seconds\n";
    }
}

my $reader = AuditReader->new($opt{'f'});
$reader->seek($opt{'seek'} || $ENV{'AUDIT_SEEK'} || 0);

while (my $record = $reader->next_record) {
    next unless $record->test();
    $found++;
    if ($opt{'raw'}) {
        if ($opt{'c'}) {
            $found += ($record->raw =~ tr/\n//) - 1;
        } else {
            print $record->raw unless $opt{'q'};
        }
    } elsif ($opt{'ausearch'}) {
        my ($time, $seq) = (split /[(:)]/, $record->get('msg'))[1,2];
        if ($opt{'i'}) {
            printf "----\n%s", $record->raw;
        } else {
            printf "----\ntime->%s%s", 
                defined($time) ? ctime(int $time) : "(null)\n", $record->raw;
        }
    } else {
        print $record->to_s."\n" unless $opt{'q'} or $opt{'c'};
    }
    last if $opt{'q'} or (defined($opt{'m'}) and $found >= $opt{'m'});
}

print $found, "\n" if $opt{'c'};
exit !$found;

__END__

=head1 NAME

augrok - audit.log search tool

=head1 SYNOPSIS

B<augrok> [I<-chqvV>] 
[I<--ausearch --count --help --quiet --raw --version>] 
[I<-f logfile | --file logfile>] [I<--seek offset>] expression...

B<augrok> I<--resolve syscall>

B<augrok> I<--ausearch options...>

=head1 DESCRIPTION

This tool provides a command-line interface for searching audit logs, similar to
ausearch but slower and possibly more flexible.

=head2 EXPRESSIONS

The primitive expression syntax is <key><op><value>, where <key> is one of the
keys from audit.log, <op> is an operator (==, !=, <, >, <=, >=, =~) and <value>
is the value against which to compare.  There should be no whitespace between
the key, operator and value.  The value should not be quoted beyond the quoting
required by the shell.  For example, "type=~SYSCALL" is valid but
"type=~'SYSCALL'" is not.  In particular, make sure to quote any primitive
expression containing < or >, otherwise you're redirecting stdin/stdout, which
is probably not what you intended.

Complex expressions can be constructed using a combination of primitive
expressions and logical operators (not, and, or, and parentheses).  Note that
parentheses may need to be quoted to escape interpretation by the shell, for
example: '(' type=~SYSCALL ')'

In addition to the keys in audit.log, two special keys are provided: msg_time
and msg_seq.  These are the time and sequence values extracted from the msg
entry.  In particular, msg_time is special because augrok will automatically
parse the comparison value into the seconds-since-epoch format used by augrok,
for example, the following will find all messages that occurred during the
specified half-hour: 'msg_time>=14:00' 'msg_time<14:30'

=head1 OPTIONS

=over

=item B<--ausearch>

If this is found anywhere on the command-line, all of the other options are
interpeted in ausearch mode.  For the usage, try --ausearch -h or read
ausearch(8).  Another way of invoking ausearch mode is to run augrok through
a symbolic link called ausearch.

=item B<-c --count>

Suppress normal output; instead print a count of matching lines.

=item B<-f> I<logfile> B<--file> I<logfile>

Search a logfile other than /var/log/audit/audit.log

=item B<-h --help>

Show usage information

=item B<--nosync>

Don't wait for auditd backlog to reach zero, as reported by auditctl -s

=item B<-q --quiet>

Quiet; do not write anything to standard output.  Exit immediately with zero
status if any match is found, otherwise exit with non-zero status.

=item B<--raw>

Output the raw lines related to the search, rather than merging them into a
single record.  Note this means that the search expression might contain keys
not present in the output (such as inode_1)

=item B<--resolve> I<syscall>

Resolve the syscall from name to number for the current architecture.  If
a number is given, resolve it back to the list of names.

=item B<--seek> I<offset>

Start the search at the first line at or after offset (bytes).

=item B<-V --version>

Show version information.

=back

=head1 EXAMPLES

To count the number of records with type=SYSCALL:

    $ augrok -c type=~SYSCALL
    537

To find a specific record:

    $ augrok msg=='audit(1124137373.408:565):'
    type=SYSCALL,FS_WATCH,FS_INODE,CWD,PATH msg=audit(1124137373.408:565):
    arch=c0000032 syscall=1210 success=yes exit=0 a0=6000000000006388
    a1=6000000000006390 a2=c00000000000048c a3=2000000000244238 items=1
    pid=28239 auid=1001 uid=0 gid=0 euid=0 suid=0 fsuid=0 egid=0 sgid=0 fsgid=0
    comm=chmod exe=/bin/chmod watch_inode=573461 watch=foo perm_mask=1
    filterkey= perm=1 inode_dev=08:06 inode_gid=0 inode=573461 inode_uid=0
    inode_rdev=00:00 cwd=/tmp rdev=00:00 ouid=0 dev=08:06 flags=1 mode=0100777
    name=foo/a ogid=0 inode_1=573504

=head1 ENVIRONMENT VARIABLES

=over

=item AUDIT_SEEK

If --seek is not specified and AUDIT_SEEK is set in the environemnt, its value
will be used as the default offset.

=back
