#!/usr/bin/perl -w
# =============================================================================
# (c) Copyright Hewlett-Packard Development Company, L.P., 2005
# Written by Aron Griffis <aron@hp.com>
#
#   This program is free software;  you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY;  without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
#   the GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program;  if not, write to the Free Software
#   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
# =============================================================================

use POSIX;
use Getopt::Long;
use strict;

######################################################################
# Global vars
######################################################################

(my $zero = $0) =~ s|.*/||;
(my $version = '$Revision$') =~ s/.*?(\d.*\d).*/augrep version $1\n/;
my $found = 0;
my %opt = (
    'f' => '/var/log/audit/audit.log',
);
my $usage = <<EOT;
usage: augrep [options...] condition...

    -c     --count         Only print a count of matching lines
    -f     --file=logfile  Search a log other than /var/log/audit/audit.log
    -h     --help          Show this help message
    -i     --interpret     Interpret uid/gid to name/group
      --interpret-syscalls Interpret syscall numbers to name
    -m     --max-count=NUM stop after NUM matches
           --nosync        don't wait for auditd to finish flushing
    -q     --quiet         No output, just set exit status (like grep)
           --resolve=name  Resolve syscall name/number
           --seek=offset   Seek to offset before starting search
           --raw           Show raw lines instead of merged record
    -V     --version       Show version information
EOT
my $ausearch_usage = <<EOT;
usage: ausearch [options]
       -a  <audit event id>
       -c  <comm name>
       -f  <file name>
       -ga <all group id>
       -ge <effective group id>
       -gi <group id>
       -h
       -hn <host name>
       -i
       -if <input file name>
       -m  <message type>
       -p  <process id>
       -sc <syscall name>
       -sv <success value>
       -te [end date] [end time]
       -ts [start date] [start time]
       -tm <terminal>
       -ua <all user id>
       -ue <effective user id>
       -ui <user id>
       -ul <login id>
       -v
       -w
       -x <executable name>
EOT

$SIG{'__DIE__'} = sub {
    $! = 2;
    die(@_);
};

######################################################################
# Syscall Table (singleton)
######################################################################

package SyscallTable;

our $singleton;

sub new {
    my ($class) = @_;

    unless (defined $singleton) {
        $singleton = {};
        bless $singleton, $class;

        open(S, "gcc -E -dM /usr/include/syscall.h |") or die;
        while (<S>) {
            next unless /^#define\s+__NR_(\w+)\s+(\w+)/;
            $singleton->{$1} = $2;
        }
        close S;

        my ($changed);
        do {
            my ($v, $new_v);
            $changed = 0;
            for my $k (keys %$singleton) {
                next unless ($v = $singleton->{$k}) =~ /\D/;
                if (defined($new_v = $singleton->{$singleton->{$k}})) {
                    $singleton->{$k} = $new_v;
                    $changed = 1;
                } else {
                    print STDERR "Removing syscall{$k} = $v\n" if $opt{'debug'};
                    delete $singleton->{$k};
                }
            }
        } while ($changed);

        my (%rev) = ();
        while (my ($k, $v) = each %$singleton) {
            $rev{$v} = $k;
        }
        $singleton->{'_reverse'} = \%rev;
    }

    return $singleton;
}

sub resolve {
    my ($self, $k) = @_;
    return $self->{$k};
}

sub reverse {
    my ($self, $k) = @_;
    return $self->{'_reverse'}{$k};
}

######################################################################
# Audit Reader
######################################################################

package AuditReader;

use FileHandle;

sub new {
    my ($class, $filename) = @_;
    my ($self) = {
        filename => $filename,
        fh => undef,
        records => [],
    };
    bless $self, $class;

    $self->{'fh'} = FileHandle->new($filename, 'r') 
        or die "failed to open $filename: $!";

    return $self;
}

sub seek {
    my ($self, $pos) = @_;
    my ($fh) = $self->{'fh'};

    if ($pos == 0) {
        $fh->seek(0, 0) or die "failed to seek: $!";
    } else {
        $fh->seek($pos-1, 0) or die "failed to seek: $!";
        # move to the next line
        scalar <$fh>;
    }
}

sub next_record {
    my ($self) = @_;
    my ($fh) = $self->{'fh'};
    my ($line, $record, $msg, $other, $o_msg);

    # populate the array; low-water=30, high-water=60
    if (@{$self->{'records'}} < 30) {
        while (@{$self->{'records'}} < 60) {
            $line = <$fh>;
            # Make sure we got a line and that it was complete.
            # Incomplete lines can be found when the filesystem is full and
            # auditd couldn't write the entire record.
            last unless defined($line) and substr($line,-1) eq "\n";
            push @{$self->{'records'}}, AuditRecord->new($line);
        }
    }
    return undef unless (@{$self->{'records'}});

    # take the top record from the list
    $record = shift @{$self->{'records'}};

    # merge following records with duplicate ids
    if (defined($msg = $record->get('msg'))) {
        for (my $i = 0; $i < @{$self->{'records'}}; $i++) {
            $other = $self->{'records'}[$i];
            next unless defined($o_msg = $other->get('msg'));
            if ($o_msg eq $msg) {
                $record->merge($other);
                splice @{$self->{'records'}}, $i, 1;
                $i--;
            }
        }
    }

    # return the merged record
    return $record;
}

######################################################################
# Audit Record
######################################################################

package AuditRecord;

sub new {
    my ($class, $line) = @_;
    my ($self) = {
        _order => [],
    };
    bless $self, $class;

    if (defined $line) {
        $self->{'_raw'} = $line;
        $self->parse($line);
    }

    return $self;
}

sub parse {
    my ($self, $line) = @_;
    my ($orig) = $line;
    my ($key_re) = q{
            [^\s"'=]+ |         # normal keys
            auditd\ pid |       # DAEMON_START, DAEMON_END
            sending\ pid |      # DAEMON_END
            login\ pid |        # LOGIN
            (?:old|new)\ auid | # LOGIN
            user\ pid           # USER_AUTH
        };

    while (
            $line =~ s/   # -- simple value --
        \A\s*             # skip leading ws
        ($key_re)         # $1 = key, incl known keys with ws
            =             # no ws around equal sign
        (?!['"])          # first char of value cannot be a quote
        ()                # $2 = empty (no quotes)
        (                 # $3 = value
            (?:
                [^\\\s]+ |          # normal chars; no ws allowed
                (?:\\[0-7]{1,3})+ | # escaped octal
                (?:\\.)             # escaped character
            )*                      # repeat to capture all of value
        )
                //xo or
            $line =~ s/   # -- quoted value--
        \A\s*             # skip leading ws
        ($key_re)         # $1 = key, incl known keys with ws
            =             # no ws around equal sign
        (['"])            # $2 = leading quote
        (                 # $3 = value
            (?: [^\\] |             # normal chars
                (?:\\[0-7]{1,3}) |  # escaped octal
                (?:\\.)             # escaped character
            )*?           # repeat to capture all of value
        )
        \2                # backreference to end quote
                //xo or
            $line =~ s/   # -- extra text --
        \A\s*             # skip leading ws
        (\S+)             # only capture one token at a time
                //x
    ) {
        my ($k, $v) = ($1, $3);
        if (defined $v) {
            $k =~ s/\s+/_/g;
            $v =~ s/^(['"])(.*)\1$/$2/;
            $self->merge_kv($k, $v);
        } else {
            $self->merge_kv('extra_text', $k);
        }
    }

    return unless $line =~ /\S/;
    chomp($line);
    print STDERR "augrep: WARNING: could not parse [$line] from: $orig";
}

sub merge_kv {
    my ($self, $k, $v) = @_;

    print STDERR "Merging [$k] = [$v]\n" if $opt{'debug'};

    # concatenate raw lines
    if ($k eq '_raw') { $self->{$k} .= $v; return; }

    # only merge other special fields once
    elsif (substr($k, 0, 1) eq '_' and exists $self->{$k}) { return; }

    # handle duplicate keys
    elsif (exists $self->{$k}) {
        # simply concatenate types
        if ($k eq 'type') {
            $self->{$k} .= ',' . $v;
            return;
        }

        # concatenate extra_text with spaces
        if ($k eq 'extra_text') {
            $self->{$k} .= ' ' . $v;
            return;
        }

        # handle other duplicates generically by appending a serial number
        my ($serial, $new_k) = 1;
        $serial++ while ($new_k = $k.'_'.$serial and
            exists $self->{$new_k} and $self->{$new_k} ne $v);
        $k = $new_k;
    }

    # fix up auditd-generated records which use a comma-space separator
    my ($type) = $self->{'type'};
    if (defined $type 
            and ($type eq 'DAEMON_START' or $type eq 'DAEMON_END') 
            and $k ne 'extra_text'
            and substr($v, -1) eq ',') {
        chop($v);
    }

    # remember the order in which fields were seen
    push @{$self->{'_order'}}, $k unless $self->{$k};
        
    # specials cases handled, add to our hash
    $self->{$k} = $v;
}

sub merge {
    my ($self, $other) = @_;
    for my $k ($other->keys) {
        $self->merge_kv($k, $other->get($k));
    }
}

sub raw {
    my ($self) = @_;
    my ($raw) = $self->{'_raw'};
    my ($name);

    if ($opt{'i'}) {
        # These are hardcoded so perl won't have to repeatedly compile the regex
        $raw =~ s/\b(uid=)(\d+)\b/
                  $1 . (defined($name = getpwuid($2)) ? $name : $2)/ge
                  if exists $self->{'uid'};
        $raw =~ s/\b(gid=)(\d+)\b/
                  $1 . (defined($name = getgrgid($2)) ? $name : $2)/ge
                  if exists $self->{'gid'};
        $raw =~ s/\b(auid=)(\d+)\b/
                  $1 . (defined($name = getpwuid($2)) ? $name : $2)/ge
                  if exists $self->{'auid'};
        $raw =~ s/\b(egid=)(\d+)\b/
                  $1 . (defined($name = getgrgid($2)) ? $name : $2)/ge
                  if exists $self->{'egid'};
        $raw =~ s/\b(euid=)(\d+)\b/
                  $1 . (defined($name = getpwuid($2)) ? $name : $2)/ge
                  if exists $self->{'euid'};
        $raw =~ s/\b(fsgid=)(\d+)\b/
                  $1 . (defined($name = getgrgid($2)) ? $name : $2)/ge
                  if exists $self->{'fsgid'};
        $raw =~ s/\b(fsuid=)(\d+)\b/
                  $1 . (defined($name = getpwuid($2)) ? $name : $2)/ge
                  if exists $self->{'fsuid'};
        $raw =~ s/\b(ogid=)(\d+)\b/
                  $1 . (defined($name = getgrgid($2)) ? $name : $2)/ge
                  if exists $self->{'ogid'};
        $raw =~ s/\b(ouid=)(\d+)\b/
                  $1 . (defined($name = getpwuid($2)) ? $name : $2)/ge
                  if exists $self->{'ouid'};
        $raw =~ s/\b(sgid=)(\d+)\b/
                  $1 . (defined($name = getgrgid($2)) ? $name : $2)/ge
                  if exists $self->{'sgid'};
        $raw =~ s/\b(suid=)(\d+)\b/
                  $1 . (defined($name = getpwuid($2)) ? $name : $2)/ge
                  if exists $self->{'suid'};
    }

    if ($opt{'interpret-syscalls'}) {
        $raw =~ s/\b(syscall=)(\d+)\b/
                  $1 . (defined($name = SyscallTable->new->reverse($2))
                  ? $name : $2)/ge
                  if exists $self->{'syscall'};
    }

    return $raw;
}

sub get {
    my ($self, $k) = @_;
    return $self->{$k};
}

sub keys {
    my ($self, $k) = @_;
    return CORE::keys %$self;
}

sub to_s {
    my ($self) = @_;
    return join(' ', 
        map {
            my $v = $self->{$_};
            $v =~ /"/ and $v = "'$v'"
                or $v =~ /['\s]/ and $v = "\"$v\""
                or $v =~ /,$/ and $v = "\"$v\"";
            "$_=$v"
        } @{$self->{'_order'}});
}

sub test {
    my ($self) = @_; shift;
    my ($prev_was_cond, $negate);

    for my $a (@ARGV) {
        print STDERR "Parsing [$a]\n" if $opt{'debug'};

        if ($a eq 'and' or $a eq 'or' or
            $a eq '!' or $a eq 'not' or
            $a =~ /^\(+$/ or $a =~ /^\)+$/)
        { $prev_was_cond = 0; next; }

        # handle equality negations generically
        $a =~ s{^(\w+)!=(.*)}{$1==$2} and $negate = 1;

        # string comparison, handling surrouding quotes
        if ($a =~ s{^(\w+)=(?:=|(?!~))(.*)}{}) {
            my ($k, $v) = ($1, $2);
            if ($k eq 'msg_time' or $k eq 'msg_seq') {
                $a = "$k==$v";      # punt to numeric comparison
            } elsif ($k =~ /^(?:uid|auid|euid|fsuid|ouid|suid)$/
                    and $v =~ /\D/) {
                my ($uid) = scalar getpwnam($v);
                die "User does not exist: $v\n" unless defined $uid;
                $a = "$k==$uid";
                # fall through to numeric comparison
            } elsif ($k =~ /^(?:gid|egid|fsgid|ogid|sgid)$/
                    and $v =~ /\D/) {
                my ($gid) = scalar getgrnam($v);
                die "Group does not exist: $v\n" unless defined $gid;
                $a = "$k==$gid";
                # fall through to numeric comparison
            } elsif ($k eq 'syscall' and $v =~ /\D/) {
                my ($num) = SyscallTable->new->resolve($v);
                die "Unknown syscall: $v\n" unless defined $num;
                $a = "$k==$num";
                # fall through to numeric comparison
            } else {
                $a = qq(
                    ((substr(\$self->{'$k'}, 0, 1) =~ /['"]/) ?
                     (substr(\$self->{'$k'}, 1, -1) eq q{$v}) :
                     (\$self->{'$k'} eq q{$v}))
                );
                goto end_subs;
            }
        }

        # numeric comparison
        if ($a =~ s{^(\w+)(<=|>=|=(?:=|(?!~))|<|>)(.*)}{}) {
            my ($k, $op, $v) = ($1, $2, $3);
            if ($k eq 'msg_time') {
                chomp($v = `date +\%s -d '$v'`) if $v =~ /[^\d.]/;
                $a = qq(
                    do {
                        my (\$time, \$seq) = (split /[(:)]/, \$self->{'msg'})[1,2];
                        defined \$seq and \$time $op $v;
                    }
                );
                goto end_subs;
            } 
            if ($k eq 'msg_seq') {
                $a = qq(
                    do {
                        my (\$time, \$seq) = (split /[(:)]/, \$self->{'msg'})[1,2];
                        defined \$seq and \$seq $op $v;
                    }
                );
                goto end_subs;
            }
            $a = qq( \$self->{'$k'} $op $v );
            goto end_subs;
        };

        # regex comparions
        if ($a =~ s{^(\w+)(!~|=~|~)(.*)}{}) {
            my ($k, $op, $v) = ($1, $2, $3);
            $a = qq(
                ((substr(\$self->{'$k'}, 0, 1) =~ /['"]/) ?
                 (substr(\$self->{'$k'}, 1, -1) $op m{$v}) :
                 (\$self->{'$k'} $op m{$v}))
            );
            goto end_subs;
        }

        die "Error evaluating expression: $a";

end_subs:

        # handle negations
        $a = "not ($a)" if $negate;
        $negate = 0;

        # make 'and' implicit, like the find command
        $a =~ s/^/and / if $prev_was_cond;
        $prev_was_cond = 1;

        print STDERR "Became [$a]\n" if $opt{'debug'};
    }
    my ($test) = "@ARGV";

    # in theory this should be (significantly) faster than eval'ing
    # repeatedly
    local $^W = 0;      # we're redefining test; don't complain
    eval "sub test { my (\$self) = \@_; local \$^W = 0; $test }";
    if ($@) {
        print STDERR "Error in expression: $@" if $@;
        print STDERR "Full test was:\n";
        print STDERR "$test";
        die;
    }

    # this only *appears* recursive
    $self->test(@_);
}

######################################################################
# Main
######################################################################

package main;

if ($zero eq 'ausearch' or grep {$_ eq '--ausearch'} @ARGV) {
    $opt{'ausearch'} = 1;

    my $eq = '=~';
    Getopt::Long::Configure("default", "pass_through");
    die unless GetOptions(
        'w'     => sub { $eq = '==' },
    );

    push @ARGV, '--' unless grep {$_ eq '--'} @ARGV;

    Getopt::Long::Configure("default", "bundling_override");
    die unless GetOptions(
        'ausearch' => sub { },                                  # just ignore
        'a=i'   => sub { push @ARGV, "msg_seq$_[1]" },
        'c=s'   => sub { push @ARGV, "comm==$_[1]" },
        'f=s'   => sub { push @ARGV, "name$eq$_[1]" },
        'ga=s'  => sub { push @ARGV, "(", "gid==$_[1]", "or",
                                          "egid==$_[1]", ")" },
        'ge=s'  => sub { push @ARGV, "egid==$_[1]" },
        'gi=s'  => sub { push @ARGV, "gid==$_[1]" },
        'h'     => sub { print STDERR $ausearch_usage; exit 0 },
        'hn=s'  => sub { push @ARGV, "hostname$eq$_[1]" },      # XXX msg_1?
        'i'     => sub { $opt{'i'} = 1 },
        'if=s'  => sub { $opt{'f'} = $_[1] },
        'm=s'   => sub { push @ARGV, ($_[1] eq 'ALL') ?
                         "type!=" : "type=~\\b$_[1]\\b" },
        'p=i'   => sub { push @ARGV, "pid==$_[1]" },
        'sc=s'  => sub { push @ARGV, "syscall==$_[1]" },        # XXX names
        'sv=s'  => sub { push @ARGV, "success==$_[1]" },
        'ts'    => sub { push @ARGV, "msg_time>=" },            # see <> below
        'te'    => sub { push @ARGV, "msg_time<=" },            # see <> below
        'tm'    => sub { push @ARGV, ($eq eq '==')
                            ? "msg_1=~\\bterminal=$_[1]\\b"
                            : "msg_1=~\\bterminal=\\S*$_[1]" },
        'ua=s'  => sub { push @ARGV, "(", "uid==$_[1]", "or",
                                          "euid==$_[1]", ")" },
        'ue=s'  => sub { push @ARGV, "euid==$_[1]" },
        'ui=s'  => sub { push @ARGV, "uid==$_[1]" },
        'ul=s'  => sub { push @ARGV, "auid==$_[1]" },
        'v'     => sub { print STDERR $version; exit 0 },
        'w'     => sub { },                                     # handled above
        'x'     => sub { push @ARGV, "exe==$_[1]" },
        'debug' => sub { $opt{'debug'} = 1 },
        'nosync' => sub { $opt{'nosync'} = 1 },
        '<>'    => sub {
            die "I don't understand $_[0]\n" unless
            $ARGV[-1] =~ s/^(msg_time.=)(.*)/$1.(length($2)?"$2 ":"").$_[0]/e
        },
    );

} else {
    Getopt::Long::Configure("default", "bundling");
    die unless GetOptions(
        \%opt,
        'c|count',
        'debug',
        'f|file=s',
        'h|help',
        'i|interpret',
        'interpret-syscalls',
        'm|max-count=i',
        'nosync',
        'q|quiet',
        'raw',
        'resolve:s',
        'seek=i',
        'V|version',
    );
    if ($opt{'h'}) { print STDERR $usage; exit 0 }
    if ($opt{'V'}) { print STDERR $version; exit 0 }
    if (defined $opt{'resolve'}) {
        my ($resolution);
        if ($opt{'resolve'} =~ /\D/) {
            $resolution = SyscallTable->new->resolve($opt{'resolve'});
        } else {
            $resolution = SyscallTable->new->reverse($opt{'resolve'});
        }
        if (defined $resolution) {
            print $resolution, "\n";
            exit 0;
        } else {
            exit 1;
        }
    }
}
die "augrep: argument required\n$usage" unless @ARGV;

# Unless --nosync is given, wait for the auditd backlog to reach zero, as
# reported by auditctl -s
if ($> == 0 and not $opt{'nosync'}) {
    my ($i, $backlog);
    for ($i = 0; $i < 30; $i++) {
        ($backlog = `/sbin/auditctl -s`) =~ s/.*?\bbacklog=(\d+).*/$1/s;
        last if $backlog == 0;
        if ($i % 10 == 0 and $opt{'debug'}) {
            print STDERR "augrep: waiting on backlog ($backlog)\n";
        }
        select(undef, undef, undef, 0.1);
    }
    if ($i == 30) {
        print STDERR "augrep: WARNING: backlog=$backlog after 3 seconds\n";
    }
}

my ($reader) = AuditReader->new($opt{'f'});
$reader->seek($opt{'seek'} || $ENV{'AUDIT_SEEK'} || 0);

while (my $record = $reader->next_record) {
    next unless $record->test();
    $found++;
    if ($opt{'raw'}) {
        if ($opt{'c'}) {
            $found += ($record->raw =~ tr/\n//) - 1;
        } else {
            print $record->raw unless $opt{'q'};
        }
    } elsif ($opt{'ausearch'}) {
        my ($time, $seq) = (split /[(:)]/, $record->get('msg'))[1,2];
        printf "----\ntime->%s%s", 
            defined($time) ? ctime(int $time) : "(null)\n", $record->raw;
    } else {
        print $record->to_s."\n" unless $opt{'q'} or $opt{'c'};
    }
    last if $opt{'q'} or (defined($opt{'m'}) and $found >= $opt{'m'});
}

print $found, "\n" if $opt{'c'};
exit !$found;

__END__

=head1 NAME

augrep - audit.log search tool

=head1 SYNOPSIS

B<augrep> [I<-chqvV>] 
[I<--count --help --quiet --raw --version>] 
[I<-f logfile | --file logfile>] [I<--seek offset>] expression...

=head1 DESCRIPTION

This tool provides a command-line interface for search audit logs for
interesting records, similar to ausearch but slower and possibly more flexible.

=head2 EXPRESSIONS

The primitive expression syntax is <key><op><value>, where <key> is one of the
keys from audit.log, <op> is an operator (==, !=, <, >, <=, >=, =~) and <value>
is the value against which to compare.  There should be no whitespace between
the key, operator and value.  The value should not be quoted beyond the quoting
required by the shell.  For example, "type=~SYSCALL" is valid but
"type=~'SYSCALL'" is not.  In particular, make sure to quote any primitive
expression containing < or >, otherwise you're redirecting stdin/stdout, which
is probably not what you intended.

Complex expressions can be constructed using a combination of primitive
expressions and logical operators (not, and, or, and parentheses).  Note that
parentheses may need to be quoted to escape interpretation by the shell, for
example: '(' type=~SYSCALL ')'

In addition to the keys in audit.log, two special keys are provided: msg_time
and msg_seq.  These are the time and sequence values extracted from the msg
entry.  In particular, msg_time is special because augrep will automatically
parse the comparison value into the seconds-since-epoch format used by augrep,
for example, the following will find all messages that occurred during the
specified half-hour: 'msg_time>=14:00' 'msg_time<14:30'

=head1 OPTIONS

=over

=item B<-c --count>

Suppress normal output; instead print a count of matching lines.

=item B<-f> I<logfile> B<--file> I<logfile>

Search a logfile other than /var/log/audit/audit.log

=item B<-h --help>

Show usage information

=item B<--nosync>

Don't wait for auditd backlog to reach zero, as reported by auditctl -s

=item B<-q --quiet>

Quiet; do not write anything to standard output.  Exit immediately with zero
status if any match is found, otherwise exit with non-zero status.

=item B<--raw>

Output the raw lines related to the search, rather than merging them into a
single record.  Note this means that the search expression might contain keys
not present in the output (such as inode_1)

=item B<--seek> I<offset>

Start the search at the first line at or after offset (bytes).

=item B<-V --version>

Show version information.

=back

=head1 EXAMPLES

To count the number of records with type=SYSCALL:

    $ augrep -c type=~SYSCALL
    537

To find a specific record:

    $ augrep msg=='audit(1124137373.408:565):'
    type=SYSCALL,FS_WATCH,FS_INODE,CWD,PATH msg=audit(1124137373.408:565):
    arch=c0000032 syscall=1210 success=yes exit=0 a0=6000000000006388
    a1=6000000000006390 a2=c00000000000048c a3=2000000000244238 items=1
    pid=28239 auid=1001 uid=0 gid=0 euid=0 suid=0 fsuid=0 egid=0 sgid=0 fsgid=0
    comm=chmod exe=/bin/chmod watch_inode=573461 watch=foo perm_mask=1
    filterkey= perm=1 inode_dev=08:06 inode_gid=0 inode=573461 inode_uid=0
    inode_rdev=00:00 cwd=/tmp rdev=00:00 ouid=0 dev=08:06 flags=1 mode=0100777
    name=foo/a ogid=0 inode_1=573504

=head1 ENVIRONMENT VARIABLES

=over

=item AUDIT_SEEK

If --seek is not specified and AUDIT_SEEK is set in the environemnt, its value
will be used as the default offset.

=back
